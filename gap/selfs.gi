#############################################################################
##
#W  selfs.gi             automata package                      Yevgen Muntyan
#W                                                             Dmytro Savchuk
##  automata v 0.91 started June 07 2004
##
#Y  Copyright (C) 2003-2006 Yevgen Muntyan, Dmytro Savchuk
##



InstallOtherMethod(\^,"list^perm",true,[IsList,IsPerm],0,
function(l,p)
  return Permuted(l,p);
end);

################################################################################
##
#F ReduceWord . . . . . . . . . . . . . . . . . . . . . . .cuts 1s from the word
##
InstallGlobalFunction(ReduceWord,
function(v)
  local i,b;
  b:=[];
  for i in [1..Length(v)] do
    if v[i]<>1 then
      Add(b,v[i]);
    fi;
  od;
  return b;
end);


################################################################################
##
#F ProjectWord. . . . . . . . . . . . . . . .computes the projection of the word
##                                     onto a subtree #s in a self-similar group

InstallGlobalFunction(ProjectWord, function(w,s,G)
  local i,perm,d,proj;
  d:=Length(G[1])-1;
  if s>d then
    Error("Incorrect index of a subtree");
  fi;
  proj:=[];
  perm:=();
  for i in [1..Length(w)] do
    Add(proj,G[w[i]][s^perm]);
    perm:=perm*G[w[i]][d+1];
  od;
  return proj;
end);

################################################################################
##
#F WordActionOnFirstLevel . . . . . . . . . . . .computes the permutation of the
##          first level vertices generated by an element of a self-similar group

InstallGlobalFunction(WordActionOnFirstLevel,function(w,G)
  local i,perm,d;
  d:=Length(G[1])-1;
  perm:=();
  for i in [1..Length(w)] do perm:=perm*G[w[i]][d+1]; od;
  return perm;
end);


################################################################################
##
#F WordActionOnVertex . . . . . . . . . . . . . computes the image of the vertex
##                        under the action of an element of a self-similar group

InstallGlobalFunction(WordActionOnVertex,function(w,ver,G)
  local i, cur_w, new_ver, perm;
  new_ver:=[];
  cur_w:=ShallowCopy(w);
  for i in [1..Length(ver)] do
    perm:=WordActionOnFirstLevel(cur_w,G);
    new_ver[i]:=ver[i]^perm;
    cur_w:=ProjectWord(cur_w,ver[i],G);
  od;
  return new_ver;
end);


################################################################################
##
#M OrbitOfVertex . . . .Computes the first n elements of the orbit of vertex
##                                   under the element g of self-similat group G

InstallMethod(OrbitOfVertex, "OrbitOfVertex(IsList,IsAutomaton,IsCyclotomic)", true, [IsList,IsAutomaton,IsCyclotomic],
function(ver,g,n)
  local i, ver_tmp, orb;
  i:=0; orb:=[];
  ver_tmp:=ver;
  while i<n and (ver<>ver_tmp or i=0) do
    Add(orb, ver_tmp);
    ver_tmp:=ver_tmp^g;
    i:=i+1;
  od;
  return orb;
end);

################################################################################
##
#M OrbitOfVertex . . . .Computes the orbit of vertex
##                                   under the element g of self-similat group G

InstallMethod(OrbitOfVertex, "OrbitOfVertex(IsList,IsAutomaton)", [IsList,IsAutomaton],
function(ver,g)
  return OrbitOfVertex(ver,g,infinity);
end);


################################################################################
##
#M OrbitOfVertex . . . .Computes the first n elements of the orbit of vertex
##                                   under the element g of self-similat group G

InstallMethod(OrbitOfVertex, "OrbitOfVertex(IsString,IsAutomaton,IsCyclotomic)", true, [IsString,IsAutomaton,IsCyclotomic],
function(ver,g,n)
  local i, ver_tmp, orb, ch;

  ver_tmp:=[];
  for i in [1..Length(ver)] do
    ch:=Int(String([ver[i]]));
    if ch<1 or ch>g!.deg then
      Error("received string ", ver, " does not represent a valid vertex");
    fi;
    Add(ver_tmp,ch);
  od;
  ver:=ver_tmp;

  i:=0; orb:=[];
  ver_tmp:=ver;
  while i<n and (ver<>ver_tmp or i=0) do
    Add(orb, ver_tmp);
    ver_tmp:=ver_tmp^g;
    i:=i+1;
  od;
  return orb;
end);

################################################################################
##
#M OrbitOfVertex . . . .Computes the orbit of vertex
##                                   under the element g of self-similat group G

InstallMethod(OrbitOfVertex, "OrbitOfVertex(IsString,IsAutomaton)", [IsString,IsAutomaton],
function(ver,g)
  return OrbitOfVertex(ver,g,infinity);
end);



################################################################################
##
#F PrintOrbitOfVertex . . . .Computes the first n elements of the orbit of vertex ver
##                                   under the element w of self-similat group G

InstallGlobalFunction(PrintOrbitOfVertex,function(ver,w,n)
  local orb,i,j;
  orb:=OrbitOfVertex(ver,w,n);
  if w!.deg=2 then
    for i in [1..Length(orb)] do
      for j in [1..Length(orb[1])] do
        #  Print(orb[i][j]);
        if orb[i][j]=1 then Print(" "); else Print("x"); fi;
      od;
      Print("\n");
    od;
  else
     for i in [1..Length(orb)] do
      for j in [1..Length(orb[1])] do
        Print(orb[i][j]);
      od;
      Print("\n");
    od;
  fi;
#  Return true;
end);

################################################################################
##
#F IsOneWordSelfSim. . . . . . . . . . . . . . . . checks if the word is trivial
##                             in any self-similar group (exponential algorithm)

InstallGlobalFunction(IsOneWordSelfSim,function(w,G)
  local i,IsOneWordIter,ReachedWords,d;

  IsOneWordIter:=function(v)
  local i,j,perm;
    if v in ReachedWords then return true;
    else
      perm:=();
      for i in [1..Length(v)] do perm:=perm*G[v[i]][d+1]; od;
      if perm<>() then return false; fi;
      Add(ReachedWords,v);
      for j in [1..d] do
        if not IsOneWordIter(ProjectWord(v,j,G)) then return false; fi;
      od;
      return true;
    fi;
  end;

  d:=Length(G[1])-1;
  if Length(w)=0 then return true; fi;
  ReachedWords:=[];
  return IsOneWordIter(w);
end);


################################################################################
##
#F IsOneWordContr. . . . . . . . . . . . . . . . . checks if the word is trivial
##                                                          in contracting group

InstallGlobalFunction(IsOneWordContr,function(word,G)
  local IsOneWordContrLocal;

  IsOneWordContrLocal:=function(word)
    local i,b,l,v,c,k,res,t,w;
    w:=ShallowCopy(word);
    if Length(w)=0 then return true; fi;
    if Length(w)=1 then
      if w=[1] then return true;
               else return false;
      fi;
    fi;
    if Length(w) mod 2=1 then Add(w,1); fi;
    l:=[];
    for i in [1..Length(w)/2] do
      Add(l,StructuralCopy(G[w[2*i-1]][w[2*i]]));
    od;
  #  Print("l=",l);
  # list c contains permutations c[i+1]=pi[1]*pi[2]*...*pi[i]
    c:=[(),l[1][Length(l[1])]];
    t:=Length(l);
    for i in [2..t] do
  #    Print("c[",i,"]=",c[i],",l[",i,"]=",l[i][Length(l[i])],";");
      Add(c,c[i]*l[i][Length(l[i])]);
      l[i][Length(l[i])]:=c[i];
    od;
    if c[Length(c)]<>() then
      return false;
    fi;
    l[1][Length(l[1])]:=();
    b:=[];
    for i in [1..Length(l)] do
      b[i]:=l[i]^((l[i][Length(l[i])])^(-1));
    od;
    i:=1;
    res:=true;
    while res and (i<=Length(b[1])-1) do
      v:=[];
      for k in [1..Length(b)] do
        Add(v,b[k][i]);
      od;
      v:=ReduceWord(v);
      res:=IsOneWordContrLocal(v);
      i:=i+1;
    od;
    return res;
  end;

  return IsOneWordContrLocal(word);
end);


################################################################################
##
#F IS_ONE_LIST. . . . . . . . . . . . . . . . . . . .checks if the word is trivial
##                     in any self-similar group (chooses appropriate algorithm)

InstallGlobalFunction(IS_ONE_LIST,function(w,G)
  if IsList(G[1][1]) then return IsOneWordContr(w,G);
                     else return IsOneWordSelfSim(w,G);
  fi;
end);


################################################################################
##
#M  MINIMIZED_AUTOMATON_LIST                 AddInversesTrack(AutomatonList(H));
##

InstallMethod(MINIMIZED_AUTOMATON_LIST, "MINIMIZED_AUTOMATON_LIST(IsAutomGroup)", [IsAutomGroup],
function(H)
  return AddInversesTrack(AutomatonList(H));
end);


################################################################################
##
#F CONVERT_ASSOCW_TO_LIST. . . . . . .Converts elements of AutomGroup into lists
##
InstallGlobalFunction(CONVERT_ASSOCW_TO_LIST,function(w)
  local w_list, w_ext, i, j, numstates, cur_gen;
  numstates:=FamilyObj(w)!.numstates;
  w_list:=[];
  w_ext:=ExtRepOfObj(w!.word);
  for i in [1..Length(w_ext)/2] do
    if w_ext[2*i]>0 then
      cur_gen:=w_ext[2*i-1];
    else
      cur_gen:=w_ext[2*i-1]+numstates;
    fi;
    for j in [1..AbsInt(w_ext[2*i])] do Add(w_list,cur_gen); od;
  od;
  return w_list;
end);


###############################################################################
##
#M  IsOneContr(a)      for contracting groups
##
InstallGlobalFunction(IsOneContr,
function(a)
  local a_list, a_list_orig, track_l, Gi, i;
  if not UseContraction(GroupOfAutomFamily(FamilyObj(a))) then TryNextMethod(); fi;

  a_list_orig:=CONVERT_ASSOCW_TO_LIST(a);


  Gi:=MINIMIZED_AUTOMATON_LIST(GroupOfAutomFamily(FamilyObj(a)));
  track_l:=Gi[3];

  a_list:=[];
  for i in [1..Length(a_list_orig)] do Add(a_list,track_l[a_list_orig[i]]); od;

  return IsOneWordContr(a_list,ContractingTable(GroupOfAutomFamily(FamilyObj(a))));
end);


###############################################################################
##
#M  IS_ONE_LIST(w,G)      (IsList, IsAutomGroup)
##
#InstallGlobalFunction(IS_ONE_LIST,
#function(w,G)
#  if HasIsContracting(G) and IsContracting(G) and UseContraction(G) then
#    return IsOneWordContr(w,ContractingTable(G));
#  else
#    return IsOneWordSelfSim(w,MINIMIZED_AUTOMATON_LIST(G)[1]);
#  fi;
#end);



###############################################################################
##
#M  CHOOSE_AUTOMATON_LIST(G)      [IsAutomGroup]
##
InstallGlobalFunction(CHOOSE_AUTOMATON_LIST,
function(G)
  if HasIsContracting(G) and IsContracting(G) and UseContraction(G) then
    return ContractingTable(G);
  else
    return MINIMIZED_AUTOMATON_LIST(G)[1];
  fi;
end);



################################################################################
##
#F PowerOfWord. . . . . . . . . . . . . . . . . . Construct n-th power of a given word
##                                                It is NOT sophisticated at all

InstallGlobalFunction(PowerOfWord,function(v,n)
  local w,k;
  v:=ReduceWord(v);
  w:=StructuralCopy(v); k:=1;
  for k in [1..n-1] do Append(w,v); od;
  return w;
end);



################################################################################
##
#M ORDER_OF_ELEMENT. . . . . . . Tries to find the order of a periodic element
##                                                       Checks up to order size

InstallMethod(ORDER_OF_ELEMENT, "ORDER_OF_ELEMENT(IsList, IsList, IsCyclotomic)", true,
              [IsList, IsList, IsCyclotomic],
function(v,G,size)
  local w,k;
  v:=ReduceWord(v);
  w:=StructuralCopy(v); k:=1;
  if Length(G[1])=3 then
    while (not IS_ONE_LIST(w,G)) and k<size do
      Append(w,w);
#     Print(w,";");
      k:=2*k;
    od;
  else
    while (not IS_ONE_LIST(w,G)) and k<size do
      Append(w,v);
#     Print(w,";");
      k:=k+1;
    od;
  fi;
  if IS_ONE_LIST(w,G) then return k; else return fail; fi;
end);


################################################################################
##
#M ORDER_OF_ELEMENT. . . . . . . . . . . . . . . . . .Finds the order of a periodic element
##
InstallMethod(ORDER_OF_ELEMENT, "OrderOfElementMain(IsList, IsList, IsPosInt)",
              [IsList, IsList],
function(v,G)
  return ORDER_OF_ELEMENT(v,G,infinity);
end);


################################################################################
##
#F GeneratorActionOnVertex. . . . . . . . . . . . . . . . Computes the action of
##                                             the generator on the fixed vertex
InstallGlobalFunction(GeneratorActionOnVertex,function(G,g,w)
  local i,v,gen,d;
  d:=Length(G[1])-1;
  gen:=g; v:=[];
  for i in [1..Length(w)] do
    Add(v,(w[i]+1)^G[gen][d+1]-1);
    gen:=G[gen][w[i]+1];
  od;
  return v;
end);


################################################################################
##
#F NumberOfWord. . . . . . . . . . . . . . .Computes the number (1..d^Length(w))
##                                           of a given vertex w of a d-ary tree

InstallGlobalFunction(NumberOfWord,function(w,d)
  local i,s;
  s:=0;
  for i in [1..Length(w)] do
    s:=s+w[i]*d^(Length(w)-i);
  od;
  return s;
end);


################################################################################
##
#F VertexNumber. . . . . . . . . . . . . Constructs the vertex on the n-th level
##                                               of the d-ary tree with number k

InstallGlobalFunction(VertexNumber,function(k,n,d)
  local i,l,l1,t;
  t:=k; l:=[];
  while t>0 do
    Add(l,t mod d);
    t:=(t-(t mod d))/d;
  od;
  for i in [Length(l)+1..n] do Add(l,0); od;
  l1:=[];
  for i in [1..n] do l1[i]:=l[n-i+1]; od;
  return l1;
end);


################################################################################
##
#F GeneratorActionOnLevel . . . . . . . . . . . . . . . . Computes the action of
##                                               the generator on the n-th level

InstallGlobalFunction(GeneratorActionOnLevel,function(G,g,n)
  local l,d,i,s,v,w,k;
  s:=(); d:=Length(G[1])-1;
  l:=[];
  for i in [1..d^n] do Add(l,0); od;
  i:=0;
  while i<d^n do
    k:=0;
    while l[k+1]>0 do
      k:=k+1;
    od;
    w:=VertexNumber(k,n,d);
    v:=StructuralCopy(w);
    i:=i+1;
    repeat
      l[NumberOfWord(v,d)+1]:=1;
      v:=GeneratorActionOnVertex(G,g,v);
      if v<>w then
        s:=s*(k+1,NumberOfWord(v,d)+1);
        i:=i+1;
      fi;
    until v=w;
  od;
  return s;
end);


################################################################################
##
#F PermActionOnLevel            Given a permutation on <big_lev>-th level
##of <deg>-ary tree computes a permutation on <sm_lev>-th level, sm_lev<=big_lev
##
InstallGlobalFunction(PermActionOnLevel,function(perm,big_lev,sm_lev,deg)
  local l,i;
  l:=[];
  for i in [0..deg^sm_lev-1] do
    Add(l,Int(((1+i*deg^(big_lev-sm_lev))^perm-1)/(deg^(big_lev-sm_lev)))+1);
  od;
  return PermList(l);
end);



################################################################################
##
#F WordActionOnLevel . . . . . . . . . . . . . . . . . . .Computes the action of
##                                              the given word on the n-th level

InstallGlobalFunction(WordActionOnLevel,function(G,w,n)
  local gen,perm;
  perm:=();
  for gen in w do
    perm:=perm*GeneratorActionOnLevel(G,gen,n);
  od;
  return perm;
end);


################################################################################
##
#F IsWordTransitiveOnLevel. . . . . . . . . .Returns true if element w of G acts
##                                 transitively on level lev and false otherwise

InstallGlobalFunction(IsWordTransitiveOnLevel,function(G,w,lev)
  return Length(OrbitPerms([WordActionOnLevel(G,w,lev)],1))=(Length(G[1])-1)^lev;
end);



################################################################################
##
#F GeneratorActionOnLevelAsMatrix. . . . . . . . . . . . . Computes the action of
##                       the generator on the n-th level as permutational matrix

InstallGlobalFunction(GeneratorActionOnLevelAsMatrix,function(G,g,n)
  local perm,i,j,m,d;
  perm:=GeneratorActionOnLevel(G,g,n);
  d:=Length(G[1])-1;
  m:=[];
  for i in [1..d^n] do Add(m,[]); od;
  for i in [1..d^n] do
    for j in [1..d^n] do m[i][j]:=0; od;
    m[i][i^perm]:=1;
  od;
  return m;
end);



################################################################################
##
#F NthFactor  . . . . . . . . . . . . . . . . . .Computes Factor group G/St_n(G)
##

InstallGlobalFunction(NthFactor,function(G,n)
  local  i,l;
  l:=[];
  for i in [1..Length(G)] do
    Add(l,GeneratorActionOnLevel(G,i,n));
  od;
  return Group(l);
end);



################################################################################
##
#F SubgroupNthFactor  . . . . . . . . . . . . . .Computes Factor group H/St_n(H)
##                     for a subgroup H of G generated by words from a list gens

InstallGlobalFunction(SubgroupNthFactor,function(G,gens,n)
  local  i,l;
  l:=[];
  for i in [1..Length(gens)] do
    Add(l,WordActionOnLevel(G,gens[i],n));
  od;
  return Group(l);
end);


################################################################################
##
#F InvestigatePairs . . . . . . . . . . . . . . . . . . . Searches out relations
##                                               in the recurent group like ab=c

InstallGlobalFunction(InvestigatePairs,function(G)
  local i,j,k,i1,j1,k1,Pairs,Trip,n,IsPairEq,d,res,tmp;

  IsPairEq:=function(i,j,k)   # ij=k?
    local t,res;
    if (not IsList(Pairs[i][j])) or (IsList(Pairs[i][j])
                                     and (Pairs[i][j][1]<>k)) then
      if (not IsList(Pairs[i][j])) and (Pairs[i][j]<>-1) then
        if Pairs[i][j]=k then return true;
                         else return false;
        fi;
      fi;
      if IsList(Pairs[i][j]) then
        if Length(Pairs[i][j])=1 then
          Trip[i][j][Pairs[i][j][1]]:=0;
        else
          Trip[i1][j1][k1]:=0;
          return true;
        fi;
      fi;
      if Trip[i][j][k]=0 then return false;
      else
        if G[i][d+1]*G[j][d+1]<>G[k][d+1] then
          Trip[i][j][k]:=0;
          return false;
        fi;
        Pairs[i][j]:=[k];
        t:=1; res:=true;
        while res and (t<=d) do
#          Print("i=",i,",j=",j,",k=",k,",t=",t,";   ");
          res:=IsPairEq(G[i][t],G[j][t^G[i][d+1]],G[k][t]);
          t:=t+1;
        od;
        if res then
          if Trip[i][j][k]<>0 then
            Pairs[i][j]:=[k,1];
            return true;
          else
            Pairs[i][j]:=-1;
            return false;
          fi;
        else
          Trip[i][j][k]:=0;
          Pairs[i][j]:=-1;
          return false;
        fi;
      fi;
    else
      return true;
    fi;
  end;

  Pairs:=[[]]; Trip:=[];
  n:=Length(G);
  d:=Length(G[1])-1;
  for j in [1..n] do Add(Pairs[1],j); od;
  for i in [2..n] do
    Add(Pairs,[i]);
    Trip[i]:=[];
    for j in [2..n] do
      Pairs[i][j]:=-1;
      Trip[i][j]:=[];
      for k in [1..n] do Trip[i][j][k]:=-1; od;
    od;
  od;
#  Print(Pairs);
#  Print(Trip);
  for i1 in [2..n] do for j1 in [2..n] do
    if Pairs[i1][j1]=-1 then
      k1:=1; res:=false;
      while (not res) and (k1<=n) do
        res:=IsPairEq(i1,j1,k1);
#        Print(Pairs,"\n");
        for i in [2..n] do for j in [2..n] do
          if IsList(Pairs[i][j]) then
            if res then Pairs[i][j]:=Pairs[i][j][1];
                   else Pairs[i][j]:=-1;
            fi;
          fi;
        od; od;
        k1:=k1+1;
      od;
      if Pairs[i1][j1]=-1 then Pairs[i1][j1]:=0; fi;
    fi;
  od; od;
  return Pairs;
end);



################################################################################
##
#M ContractingLevel . . . . . . . . . . . . . . . . . . Computes the level where
##                                              all pairs contract to the kernel

InstallMethod(ContractingLevel, "ContractingLevel(IsAutomGroup)", [IsAutomGroup],
function(H)
  local ContractingLevelLocal;

  ContractingLevelLocal:=function(G)
    local i,j,res,ContPairs,d,maxlev,n,Pairs,DoesPairContract;
    DoesPairContract:=function(i,j,lev)
      local t,res,localmaxlev;
      if lev>maxlev then maxlev:=lev; fi;
      if IsList(ContPairs[i][j]) then
        if lev+ContPairs[i][j][1]>maxlev then maxlev:=lev+ContPairs[i][j][1]; fi;
        return true;
      fi;
      if Pairs[i][j]<>0 then
        ContPairs[i][j]:=[0];
        return true;
      fi;
      if ContPairs[i][j]=2 then return false; fi;
      t:=1; res:=true;
      ContPairs[i][j]:=2;
      localmaxlev:=0;
      while res and (t<=d) do
        res:=DoesPairContract(G[i][t],G[j][t^G[i][d+1]],lev+1);
        if res then
          if ContPairs[G[i][t]][G[j][t^G[i][d+1]]][1]+1>localmaxlev then
            localmaxlev:=ContPairs[G[i][t]][G[j][t^G[i][d+1]]][1]+1;
          fi;
        fi;
        t:=t+1;
      od;
      if res then
               ContPairs[i][j]:=[localmaxlev];
               return true;
             else return false;
      fi;
    end;

    res:=true; maxlev:=0; ContPairs:=[];
    Pairs:=InvestigatePairs(G);
    n:=Length(G);
    for i in [1..n] do
      Add(ContPairs,[[0]]);
      for j in [1..n-1] do
        if i=1 then Add(ContPairs[i],[0]);
               else Add(ContPairs[i],-1);
        fi;
      od;
    od;
    #Print(ContPairs,"\n");
    i:=1;
    d:=Length(G[1])-1;
    while res and (i<=n) do
      j:=1;
      while res and (j<=n) do
        if ContPairs[i][j]=0 then return -1; fi;
        if ContPairs[i][j]=-1 then res:=DoesPairContract(i,j,0); fi;
        j:=j+1;
      od;
      i:=i+1;
    od;
    #Print(ContPairs);
    if res then return maxlev;
           else return -1;
    fi;
  end;
################ ContractingLevel itself #################################

  if not HasIsContracting(H) then
    Info(InfoWarning, 1, "If <H> is not contracting, the algorithm will never stop");
  fi;
  return ContractingLevelLocal(NucleusIncludingGeneratingSetAutom(H));
end);




################################################################################
##
#M ContractingTable . . . . . . . . . . . . . . . . . . Computes the contracting
##                                                           table of the kernel
InstallMethod(ContractingTable, "ContractingTable(IsAutomGroup)", [IsAutomGroup],
function(H)
  local ContractingTableLocal;
  ContractingTableLocal:=function(G)
    local lev,n,d,i,j, ContractingPair, Pairs, ContTable;
    ContractingPair:=function(i,j)
      local l,k,t, PairAct, TmpList, g1, g2;
      if Pairs[i][j]<>0 then PairAct:=[Pairs[i][j]];
                        else PairAct:=[[i,j]];
      fi;
      for l in [1..lev] do
        TmpList:=[];
        for t in [1..Length(PairAct)] do
          if not IsList(PairAct[t]) then
            for k in [1..d] do Add(TmpList,G[PairAct[t]][k]); od;
          else
            for k in [1..d] do
              g1:=G[PairAct[t][1]][k];
              g2:=G[PairAct[t][2]][k^G[PairAct[t][1]][d+1]];
              if Pairs[g1][g2]<>0 then Add(TmpList,Pairs[g1][g2]);
                                  else Add(TmpList,[g1,g2]);
              fi;
            od;
          fi;
        od;
        PairAct:=StructuralCopy(TmpList);
      od;
      Add(PairAct,GeneratorActionOnLevel(G,i,lev)*GeneratorActionOnLevel(G,j,lev));
      return PairAct;
    end;

    lev:=ContractingLevel(H);
    Pairs:=InvestigatePairs(G);
    n:=Length(G);
    d:=Length(G[1])-1;
    ContTable:=[];
    for i in [1..n] do
      Add(ContTable,[]);
      for j in [1..n] do Add(ContTable[i],ContractingPair(i,j)); od;
    od;
    return ContTable;
  end;
################ ContractingLevel itself #################################

  if not HasIsContracting(H) then
    Info(InfoWarning, 1, "If <H> is not contracting, the algorithm will never stop");
  fi;
  return ContractingTableLocal(NucleusIncludingGeneratingSetAutom(H));
end);


################################################################################
##
#F MinimizeAutom . . . . . . . . . . . . . . . . . . .Glues equivalent states of
##                                                          noninitial automaton

InstallGlobalFunction(MinimizeAutom,function(G)

  local AreEqualStates,i,j,Pairs,n, tmpG,d,k,l,st;

  AreEqualStates:=function(st1,st2)
    local eq,i;
    if st1=st2 or ([st1,st2] in Pairs) or ([st2,st1] in Pairs) then return true; fi;
    if G[st1][d+1]<>G[st2][d+1] then return false; fi;
    Add(Pairs, [st1,st2]);
    eq:=true;
    for i in [1..d] do
      if not AreEqualStates(G[st1][i],G[st2][i]) then eq:=false; break; fi;
    od;
    return eq;
  end;

  n:=Length(G);
  d:=Length(G[1])-1;
  for i in [1..n-1] do
    for j in [i+1..n] do
      Pairs:=[];
      if AreEqualStates(i,j) then
        tmpG:=[];  #can be maid better by gluing all pairs from Pairs.
        for k in [1..n] do
          if k<>j then
            st:=StructuralCopy(G[k]);
            for l in [1..d] do
              if st[l]=j then st[l]:=i;
              elif st[l]>j then st[l]:=st[l]-1;
              fi;
            od;
            Add(tmpG,st);
          fi;
        od;
        return MinimizeAutom(tmpG);
      fi;
    od;
  od;
  return G;
end);

################################################################################
##
#F MinimizeAutomTrack  . . . . . . . . . . . . . . . .Glues equivalent states of
##   noninitial automaton and returns correspondence between old and new numbers
##  track_list_short - new generators in terms of old ones
##  track_list_long  - old generators in terms of new ones

InstallGlobalFunction(MinimizeAutomTrack,function(G,track_list_short,track_list_long)

  local AreEqualStates,i,j,Pairs,n, tmpG,d,k,l,st, track_s, track_l;

  AreEqualStates:=function(st1,st2)
    local eq,i;
    if st1=st2 or ([st1,st2] in Pairs) or ([st2,st1] in Pairs) then return true; fi;
    if G[st1][d+1]<>G[st2][d+1] then return false; fi;
    Add(Pairs, [st1,st2]);
    eq:=true;
    for i in [1..d] do
      if not AreEqualStates(G[st1][i],G[st2][i]) then eq:=false; break; fi;
    od;
    return eq;
  end;


  if Length(track_list_short)<>Length(G) then
    Error("length of track_list_short is wrong\n");
  fi;

  n:=Length(G);
  d:=Length(G[1])-1;
  track_s:=StructuralCopy(track_list_short);
  track_l:=StructuralCopy(track_list_long);
  for i in [1..n-1] do
    for j in [i+1..n] do
      Pairs:=[];
      if AreEqualStates(i,j) then
        tmpG:=[];  #can be maid better by gluing all pairs from Pairs.
        for k in [1..n] do
          if k<>j then
            st:=StructuralCopy(G[k]);
            for l in [1..d] do
              if st[l]=j then st[l]:=i;
              elif st[l]>j then st[l]:=st[l]-1;
              fi;
            od;
            Add(tmpG,st);
          fi;
        od;
        track_s:=[];
        for k in [1..Length(track_list_short)] do
          if k<j then track_s[k]:=StructuralCopy(track_list_short[k]);
            elif k>j then track_s[k-1]:=StructuralCopy(track_list_short[k]);
          fi;
        od;
        for k in [1..Length(track_list_long)] do
          if track_l[k]>j then track_l[k]:=track_l[k]-1;
            elif track_l[k]=j then track_l[k]:=i;
          fi;
        od;
        return MinimizeAutomTrack(tmpG,track_s,track_l);
      fi;
    od;
  od;
  return [G,track_s,track_l];
end);


################################################################################
##
#F AddInverses. . . . . . . . . . Adds to the generating set of the self-similar
##                               group inverse elements and the identity element

InstallGlobalFunction(AddInverses,function(H)
  local d,n,G,idEl,st,i,perm,inv;

  d:=Length(H[1])-1;
  n:=Length(H);
  if n<1 or d<1 then return fail; fi;
  idEl:=[];
  for i in [1..d] do Add(idEl,1); od;
  Add(idEl,());
  G:=[idEl];
  for i in [1..n] do Add(G,StructuralCopy(H[i])); od;

  for st in [2..n+1] do
    for i in [1..d] do G[st][i]:=G[st][i]+1; od;
  od;

  for st in [2..n+1] do
    inv:=[];
    perm:=G[st][d+1]^(-1);
    for i in [1..d] do Add(inv, G[st][i^perm]+n); od;
    Add(inv,perm);
    Add(G,inv);
  od;

  return MinimizeAutom(G);
end);



################################################################################
##
#F AddInversesTrack. . . . . . . .Adds to the generating set of the self-similar
##                               group inverse elements and the identity element

InstallGlobalFunction(AddInversesTrack,function(H)
  local d,n,G,idEl,st,i,perm,inv, track_s, track_l;

##  track_s - new generators in terms of old ones
##  track_l - old generators in terms of new ones

  d:=Length(H[1])-1;
  n:=Length(H);
  if n<1 or d<1 then return fail; fi;
  idEl:=[];
  for i in [1..d] do Add(idEl,1); od;
  Add(idEl,());
  G:=[idEl];
  for i in [1..n] do Add(G,StructuralCopy(H[i])); od;

  for st in [2..n+1] do
    for i in [1..d] do G[st][i]:=G[st][i]+1; od;
  od;

  for st in [2..n+1] do
    inv:=[];
    perm:=G[st][d+1]^(-1);
    for i in [1..d] do Add(inv, G[st][i^perm]+n); od;
    Add(inv,perm);
    Add(G,inv);
  od;
#  Print("G=",G,"\n");
  track_s:=[0];
  Append(track_s,[1..Length(G)-1]);
  return MinimizeAutomTrack(G,track_s,[2..Length(G)]);
end);


################################################################################
##
#M UseContraction . . . . . . . . . .internal use only
##
InstallMethod(UseContraction, "UseContraction(IsTreeAutomorphismGroup)", true,
              [IsTreeAutomorphismGroup], 
function(G)
  if IsContracting(G) then 
    return false;
  else return fail;
  fi;
end);



################################################################################
##
#M INFO_FLAG . . . . . . . . . .internal use only
##
InstallMethod(INFO_FLAG, "INFO_FLAG(IsTreeAutomorphismGroup)", true,
              [IsTreeAutomorphismGroup], function(G) return 0; end);



################################################################################
##
#M FindNucleus. . . . . . . . . . . . . . . . . . . . .Tries to find the nucleus
##                                                     of the self-similar group
InstallMethod(FindNucleus, "for [IsAutomatonGroup, IsCyclotomic]", true,
                                    [IsAutomatonGroup, IsCyclotomic],
function(H,max_nucl)
  local G,g,Pairs,i,j,PairsToAdd,AssocWPairsToAdd,res,ContPairs,n,d,found,num,IsPairContracts,AddPairs,lev,maxlev,tmp,Nucl,IsElemInNucleus,
    nucl_final, cur_nucl, cur_nucl_tmp, Hi, track_s, track_l, G_track, automgens, cur_nucl_length, info;
  IsPairContracts:=function(i,j,lev)
    local t,res;
    if lev>maxlev then maxlev:=lev; fi;

    # ContPairs[i][j] may take the following values:
    # -1 - [i,j] was not met before
    # 1  - [i,j] contracts
    # 2  - [i,j] was met above in the tree

    if (ContPairs[i][j]=1) then return true; fi;
    if Pairs[i][j]<>0 then
      ContPairs[i][j]:=1;
      return true;
    fi;
    if ContPairs[i][j]=2 then return false; fi;
    t:=1; res:=true;
    ContPairs[i][j]:=2;
    while res and (t<=d) do
      res:=IsPairContracts(G[i][t],G[j][t^G[i][d+1]],lev+1);
      t:=t+1;
    od;
    if res then
             ContPairs[i][j]:=1;
             return true;
           else return false;
    fi;
  end;

  AddPairs:=function(i,j)
    local tmp,l,CurNum;
    if Pairs[i][j]>0 then return Pairs[i][j]; fi;
    Pairs[i][j]:=num;
    CurNum:=num;
    Add(PairsToAdd,[]);
    num:=num+1;
    tmp:=[];
    for l in [1..d] do
      Add(tmp,AddPairs(G[i][l],G[j][l^G[i][d+1]]));
    od;
    Add(tmp,G[i][d+1]*G[j][d+1]);
    Append(PairsToAdd[CurNum-n],tmp);
    AssocWPairsToAdd[CurNum-n]:=cur_nucl[i]*cur_nucl[j];
    return CurNum;
  end;

  IsElemInNucleus:=function(g)
    local i,res;
    if g in tmp then
      for i in [Position(tmp,g)..Length(tmp)] do
        if not (tmp[i] in Nucl) then Add(Nucl,tmp[i]); fi;
      od;
      return g=tmp[1];
    fi;
    Add(tmp,g);
    res:=false; i:=1;
    while (not res) and i<=d do
      res:=IsElemInNucleus(G[g][i]);
      i:=i+1;
    od;
    tmp:=tmp{[1..Length(tmp)-1]};
    return res;
  end;

#  ******************  FindNucleus itself *******************************

  if HasIsContracting(H) and not IsContracting(H) then 
    return fail;
  fi;


  info:=InfoLevel(InfoAutomata);
  if INFO_FLAG(H)=0 then SetInfoLevel(InfoAutomata,5); fi;

  automgens:=UnderlyingAutomFamily(H)!.automgens;
  d:=UnderlyingAutomFamily(H)!.deg;
  cur_nucl:=[One(UnderlyingAutomFamily(H))];

  Hi:=StructuralCopy(MINIMIZED_AUTOMATON_LIST(H));
#  Print("Gi=",Gi,"\n");
  G:=Hi[1];

  track_s:=Hi[2];
  track_l:=Hi[3];

  for i in [2..Length(track_s)] do Add(cur_nucl,automgens[track_s[i]]); od;

  found:=false;

  while (not found) and Length(G)<max_nucl do
    res:=true; maxlev:=0; ContPairs:=[];
    Pairs:=InvestigatePairs(G);
    n:=Length(G);
#    Print("n=",n,"\n");
    Info(InfoAutomata, 3, "n=",n);
    for i in [1..n] do
      Add(ContPairs,[1]);
      for j in [1..n-1] do
        if i=1 then Add(ContPairs[i],1);
               else Add(ContPairs[i],-1);
        fi;
      od;
    od;
    i:=1;

    while res and (i<=n) do
      j:=1;
      while res and (j<=n) do
        #Print("i=",i,",j=",j,"\n");
        if ContPairs[i][j]=-1 then res:=IsPairContracts(i,j,0); fi;
        if not res then
          PairsToAdd:=[];
          AssocWPairsToAdd:=[];
#  num represents current number of generators
          num:=n+1;
          AssocWPairsToAdd:=[];
          AddPairs(i,j);
          Info(InfoAutomata, 3, "Elements added:",List(AssocWPairsToAdd,x->x!.word));
          Append(G,PairsToAdd);
#          Print("G=",G,"\n");
          Append(cur_nucl,AssocWPairsToAdd);
          G_track:=AddInversesTrack(G);
#          Print("G_track=",G_track,"\n");
          G:=G_track[1];
          cur_nucl_tmp:=[];
          cur_nucl_tmp:=[One(UnderlyingAutomFamily(H))];
          cur_nucl_length:=Length(cur_nucl);
          for i in [2..Length(G_track[2])] do
            if G_track[2][i]<=cur_nucl_length then
              Add(cur_nucl_tmp,cur_nucl[G_track[2][i]]);
            else
              Add(cur_nucl_tmp,cur_nucl[G_track[2][i]-cur_nucl_length]^-1);
            fi;
          od;
          cur_nucl:=StructuralCopy(cur_nucl_tmp);
        fi;
        j:=j+1;
      od;
      i:=i+1;
    od;
    if res then
      found:=true;
    fi;
  od;

  if not found then return fail; fi;
  Nucl:=[];
# first add elements of cycles
  for i in [1..Length(G)] do
    tmp:=[];
    if not (i in Nucl) then IsElemInNucleus(i); fi;
  od;

# now add sections of elemen
  repeat
    found:=false;
    for g in Nucl do
      for i in [1..d] do
        if not (G[g][i] in Nucl) then
          found:=true;
          Add(Nucl,G[g][i]);
        fi;
      od;
    od;
  until not found;
#  Print("Nucleus:",Nucl,"\n");

  nucl_final:=[];
  for i in Nucl do Add(nucl_final,cur_nucl[i]); od;

  SetIsContracting(H, true);
  SetAutomNucleus(H, nucl_final);
  SetNucleusIncludingGeneratingSet(H, cur_nucl);
  SetNucleusIncludingGeneratingSetAutom(H, G);
  SetContractingLevel(H, maxlev);
  SetInfoLevel(InfoAutomata,info);

  return [nucl_final,cur_nucl,G];
end);


################################################################################
##
#M FindNucleus. . . . . . . . . . . . . . . . . . . . .Tries to find the nucleus
##                                                     of the self-similar group
InstallMethod(FindNucleus, "for [IsAutomatonGroup]", true,
                                    [IsAutomatonGroup],
function(H)
  return FindNucleus(H,infinity);
end);


################################################################################
##
#M IsContracting . . . . . . . . . .
##

InstallMethod(IsContracting, "IsContracting(IsAutomGroup)", true,
              [IsAutomGroup],
function(G)
  local info, res;
  if IsSelfSimilar(G)=false then
    Info(InfoAutomata,3,"The group <G> is not self-similar, so it is not contracting");
    return false;
  elif not IsAutomatonGroup(G) then
    Info(InfoAutomata,3,"Represent <G> as a group generated by finite automaton");
    return fail;
  fi;
  info:=INFO_FLAG(G);
  SetINFO_FLAG(G, 1);
  res:=FindNucleus(G,50);
  SetINFO_FLAG(G, info);
  if res<>fail then return true; fi;
  res:=IsNoncontracting(G,10,10);
  if res=true then return false; fi;
  Info(InfoAutomata,1,"You can try FindNucleus(<G>,<max_nucl>) or");
  Info(InfoAutomata,1,"            IsNoncontracting(<G>,<lengh>,<depth>) with bigger bounds");
  TryNextMethod();
end);


################################################################################
##
#M AutomNucleus . . . . . . . . . . Computes nucleus
##

InstallMethod(AutomNucleus, "IsContracting(IsAutomGroup)", true,
              [IsAutomGroup],
function(G)
  local info,res;
  info:=INFO_FLAG(G);
  SetINFO_FLAG(G, 1);
  FindNucleus(G);
  res:=AutomNucleus(G);
  SetINFO_FLAG(G, info);
  return res;
end);


################################################################################
##
#M NucleusIncludingGeneratingSet . . . . . . . . . . Computes nucleus including
##                                                   generating set
InstallMethod(NucleusIncludingGeneratingSet, "NucleusIncludingGeneratingSet(IsAutomGroup)", true,
              [IsAutomGroup],
function(G)
  local info,res;
  info:=INFO_FLAG(G);
  SetINFO_FLAG(G, 1);
  FindNucleus(G);
  res:=NucleusIncludingGeneratingSet(G);
  SetINFO_FLAG(G, info);
  return res;
end);


################################################################################
##
#M NucleusIncludingGeneratingSetAutom . . . . . . . . . . Computes automaton of nucleus
##
InstallMethod(NucleusIncludingGeneratingSetAutom, "NucleusIncludingGeneratingSetAutom(IsAutomGroup)", true,
              [IsAutomGroup],
function(G)
  local info,res;
  info:=INFO_FLAG(G);
  SetINFO_FLAG(G, 1);
  FindNucleus(G);
  res:=NucleusIncludingGeneratingSetAutom(G);
  SetINFO_FLAG(G, info);
  return res;
end);



################################################################################
##
#F InversePerm. . . . . . . . . . . .Gives permutation on the set of generators
##                                      which pushes each element to its inverse

InstallGlobalFunction(InversePerm,function(G)
  local i,j,viewed,inv,found;
  viewed:=[]; inv:=();
  for i in [1..Length(G)] do
    if not (i in viewed) then
      j:=1; found:=false;
      while j<=Length(G) and not found do
        #Print("[",i,",",j,"]\n");
        if IS_ONE_LIST([i,j],G) then
          found:=true;
          if i<>j then
            inv:=inv*(i,j);
            Append(viewed,[i,j]);
          else
            Add(viewed,i);
          fi;
        fi;
        j:=j+1;
      od;
    fi;
  od;
  return inv;
end);


################################################################################
##
#F PortraitOfWord. . . . . . . . . . . . . . . Finds the portrait boundary of an
##                                                element in a contracting group

InstallGlobalFunction(PortraitOfWord,function(w,G)
  local PortraitIter, bndry,inv,d,PermList;

  PortraitIter:=function(v,lev,plist)
    local i,j,tmpv,sigma;
    for i in [1..Length(G)] do
      tmpv:=StructuralCopy(v);
      Add(tmpv,i);
      if IS_ONE_LIST(tmpv,G) then
        Add(bndry,[lev,i^inv]);
        return;
      fi;
    od;

    for i in [1..d] do
      tmpv:=[]; sigma:=();
      for j in v do
        Add(tmpv,G[j][i^sigma]);
        sigma:=sigma*G[j][d+1];
      od;
      if i=1 then Add(plist,sigma);fi;
      Add(plist,[]);
      PortraitIter(tmpv,lev+1,plist[i+1]);
    od;
  end;

  d:=Length(G[1])-1;
  bndry:=[d];
  PermList:=[];
  inv:=InversePerm(G);
  PortraitIter(w,0,PermList);
  return [bndry,PermList];
end);


################################################################################
##
#F WritePortraitToFile. . . . . . . . . . .Writes portrait in a file in the form
##                                                       understandable by Maple

InstallGlobalFunction(WritePortraitToFile,function(p,file,add)
  local WritePerm;

  WritePerm:=function(perm)
    local j;
    AppendTo(file,"[ ");
    if Length(perm)>0 then
      AppendTo(file,"`",perm[1],"`");
      for j in [2..Length(perm)] do
        AppendTo(file,", ");
        WritePerm(perm[j]);
      od;
    fi;
    AppendTo(file," ]");
  end;


  if add then AppendTo(file,"[ ",p[1],", ");
    else PrintTo(file,"[ ",p[1],", ");
  fi;
  WritePerm(p[2]);
  AppendTo(file, " ]");
end);


################################################################################
##
#F WritePortraitsToFile. . . . . . . . . . . . .Writes portraitso of elements of
##                          a list in a file in the form understandable by Maple

InstallGlobalFunction(WritePortraitsToFile,function(lst,G,file,add)
  local WritePerm,i,p;

  if add then AppendTo(file,"[ ");
    else PrintTo(file,"[ ");
  fi;

  for i in [1..Length(lst)] do
    if i=1 then
        AppendTo(file,"[ ",lst[i],", ");
    else
        AppendTo(file,", [ ",lst[i],", ");
    fi;
    p:=PortraitOfWord(lst[i],G);
    WritePortraitToFile(p,file,true);
    AppendTo(file,"]");

  od;
end);


################################################################################
##
#F PortraitsOfWordPowers. . . . . . Finds the sequence of portrait boundaries of
##                                          word's powers in a contracting group

InstallGlobalFunction(PortraitsOfWordPowers,function(w,G)
  local list,d,v;
  v:=StructuralCopy(w);
  d:=Length(G[1])-1;
  list:=[StructuralCopy(w),PortraitOfWord(v,G)];
  while list[Length(list)]<>[[d,[0,1]],[]] do
    Append(v,w);
    Add(list, PortraitOfWord(v,G));
  od;
  return list;
end);


################################################################################
##
#F AutomGroupGrowth. . . . . . . . . . . . . . . . . . . . . . . .Finds number of elements
##                                                         of the length up to n

InstallGlobalFunction(AutomGroupGrowth,function(n,G)
  local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,inverse,H;

  inverse:=function(w)
    local i, iw;
    iw:=[];
    for i in [1..Length(w)] do
      iw[i]:=w[Length(w)-i+1]^inv;
    od;
    return iw;
  end;

  gr:=1; len:=1;
  H:=AddInverses(G);
  if G<>H then
    Info(InfoAutomata, 3, "Inverses were added. Automaton was minimized. Now generator set is:\n",H);
    G:=H;
  fi;
  inv:=InversePerm(G);
  GrList:=[1,Length(G)];
  ElList:=[];
  for i in [1..Length(G)] do
    Add(ElList,[i]);
  od;

  while len<n do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for j in [2..Length(G)] do
        v:=StructuralCopy(ElList[i]);
        Add(v,j);
        New:=true;
        k:=1;
        while New and k<=oldgr do
          tmpv:=StructuralCopy(v);
          Append(tmpv,inverse(ElList[k]));
          if IS_ONE_LIST(tmpv,G) then New:=false; fi;
          k:=k+1;
        od;
        if New then Add(ElList,v); fi;
      od;
    od;
    Add(GrList,Length(ElList));
    Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList));
    len:=len+1;
  od;

  return GrList;
end);


################################################################################
##
#F AutomGroupGrowthFast. . . . . . . . . .Computes the growth function while the number of
##               elements is not greater than n and length is not greater than m

InstallGlobalFunction(AutomGroupGrowthFast,function(n,m,G)
  local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,inverse,H;

  inverse:=function(w)
    local i, iw;
    iw:=[];
    for i in [1..Length(w)] do
      iw[i]:=w[Length(w)-i+1]^inv;
    od;
    return iw;
  end;

  gr:=1; len:=1;
  H:=AddInverses(G);
  if G<>H then
    Info(InfoAutomata, 3, "Inverses were added. Now generator set is:\n",H);
    G:=H;
  fi;
  inv:=InversePerm(G);
  GrList:=[1,Length(G)];
  ElList:=[];
  for i in [1..Length(G)] do
    Add(ElList,[i]);
  od;

  while Length(ElList)<n and len<m do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for j in [2..Length(G)] do
        v:=StructuralCopy(ElList[i]);
        Add(v,j);
        New:=true;
        k:=1;
        while New and k<=oldgr do
          tmpv:=StructuralCopy(v);
          Append(tmpv,inverse(ElList[k]));
          if IS_ONE_LIST(tmpv,G) then New:=false; fi;
          k:=k+1;
        od;
        if New then Add(ElList,v); fi;
      od;
    od;
    Add(GrList,Length(ElList));
    Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList));
    len:=len+1;
  od;

  return GrList;
end);



################################################################################
##
#F AutomGroupElements . . . . . . . . . . . . . . . . . . .Enumerates all elements of
##                                     a self-similar group up to a given length

InstallGlobalFunction(AutomGroupElements,function(n,G)
  local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,inverse,H;

  inverse:=function(w)
    local i, iw;
    iw:=[];
    for i in [1..Length(w)] do
      iw[i]:=w[Length(w)-i+1]^inv;
    od;
    return iw;
  end;

  gr:=1; len:=1;
  H:=AddInverses(G);
  if G<>H then
    Info(InfoAutomata, 3, "Inverses were added. Automaton was minimized. Now generator set is:\n",H);
    G:=H;
  fi;
  inv:=InversePerm(G);
  GrList:=[1,Length(G)];
  ElList:=[];
  for i in [1..Length(G)] do
    Add(ElList,[i]);
  od;

  while len<n do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for j in [2..Length(G)] do
        v:=StructuralCopy(ElList[i]);
        Add(v,j);
        New:=true;
        if len=1 then k:=1; else k:=GrList[len-1]; fi;
        while New and k<=oldgr do
          tmpv:=StructuralCopy(v);
          Append(tmpv,inverse(ElList[k]));
          if IS_ONE_LIST(tmpv,G) then New:=false; fi;
          k:=k+1;
        od;
        if New then Add(ElList,v); fi;
      od;
    od;
    Add(GrList,Length(ElList));
    Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList));
    len:=len+1;
  od;

  return ElList;
end);


################################################################################
##
#M FiniteGroupId . . . . . . . . . . Computes a finite group of permutations
##    generated by a self-similar group (in case of infinite group doesn't stop)

InstallMethod(FiniteGroupId, "FiniteGroupId(IsAutomGroup, IsPosInt)", true,
              [IsAutomGroup, IsCyclotomic],
function(H,size)
  local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,IsNewRel,inverse,G,FinG,tmpl,push,ProductEls,act,rels, LongCycle;

  inverse:=function(w)
    local i, iw;
    iw:=[];
    for i in [1..Length(w)] do
      iw[i]:=w[Length(w)-i+1]^inv;
    od;
    return iw;
  end;

  ProductEls:=function(i,j)
    local t,v,tmpv;
    v:=StructuralCopy(ElList[i]);
    Append(v,ElList[j]);
    for t in [1..Length(ElList)] do
      tmpv:=StructuralCopy(v);
      Append(tmpv,inverse(ElList[t]));
      if IS_ONE_LIST(tmpv,G) then return t; fi;
    od;
  end;

  LongCycle:=function(n)
    local l,i;
    l:=[];
    for i in [2..n] do Add(l,i); od;
    Add(l,1);
    return PermList(l);
  end;

  IsNewRel:=function(v)
    local  tmp,i,j,cyc,cycr,v_cyc,r_cyc,r,r_cyc_inv;
    cyc:=LongCycle(Length(v));
    for i in [0..Length(v)-1] do
      v_cyc:=Permuted(v,cyc^i);
      if v_cyc[1]=v_cyc[Length(v)]^inv then return false; fi;
      for r in rels do
        cycr:=LongCycle(Length(r));
        for j in [0..Length(r)-1] do
          r_cyc:=Permuted(r,cycr^j);
          r_cyc_inv:=inverse(Permuted(r,cycr^j));
          if PositionSublist(v_cyc,r_cyc) <> fail or PositionSublist(v_cyc,r_cyc_inv) <> fail then
            return false;
          fi;
        od;
      od;
    od;
    return true;
  end;

#######################   FiniteGroupId  itself #########################################
  gr:=1; len:=1;

  G:=CHOOSE_AUTOMATON_LIST(H);

  inv:=InversePerm(G);
  if not HasIsFinite(H) then
    Info(InfoWarning,2,"warning, if <H> is infinite the algorithm will never stop");
  fi;
  GrList:=[1,Length(G)];
  ElList:=[]; rels:=[];
  for i in [1..Length(G)] do
    Add(ElList,[i]);
  od;
  while GrList[len+1]>GrList[len] and GrList[len+1]<size do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for j in [2..Length(G)] do
        v:=StructuralCopy(ElList[i]);
        if j<>v[Length(v)]^inv then
          Add(v,j);
          New:=true;
          if len=1 then k:=1; else k:=GrList[len-1]+1; fi;
          while New and k<=oldgr do
            tmpv:=StructuralCopy(v);
            Append(tmpv,inverse(ElList[k]));
            if IS_ONE_LIST(tmpv,G) then
              New:=false;
## show relations
              if IsNewRel(tmpv) then
                Add(rels,tmpv);
                Info(InfoAutomata, 3, v,"*",ElList[k],"^(-1)=1");
#               Print(tmpv,"\n");
              fi;
            fi;
            k:=k+1;
          od;
          if New then Add(ElList,v); fi;
        fi;
      od;
    od;
    Add(GrList,Length(ElList));
    Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList));
    len:=len+1;
  od;

  if GrList[len+1]>GrList[len] then return fail; fi;
# in case of finite group construct Cayley table


  FinG:=[];
  for i in [2..UnderlyingAutomFamily(H)!.numstates+1] do
    act:=();
    tmpl:=[];
    while Length(tmpl)<Length(ElList) do
      j:=1;
      while j in tmpl do j:=j+1; od;
      Add(tmpl,j);
      push:=ProductEls(j,i);
      while push<>j do
        Add(tmpl,push);
        act:=act*(j,push);
        push:=ProductEls(push,i);
      od;
    od;
    Add(FinG,act);
  od;

  SetIsFinite(H,true);
  return GroupWithGenerators(FinG);
end);



##  Inefficient regular representation
################################################################################
##
#F IsomorphismPermGroup . . . . . . . . Computes an isomorphism from AutomGroup G
##    to a permutational group via regular representation (if G is finite)
#InstallMethod(IsomorphismPermGroup, "IsomorphismPermGroup(IsAutomGroup)",
#              [IsAutomGroup],
#function(G)
#  local H;
#  H:=FiniteGroupId(G);
#  return GroupHomomorphismByImagesNC(G,H,GeneratorsOfGroup(G),GeneratorsOfGroup(H));
#end);





################################################################################
##
#F FiniteGroupId . . . . . . . . . . . . Computes a finite group of permutations
##    generated by a self-similar group (in case of infinite group doesn't stop)


InstallMethod(FiniteGroupId, "FiniteGroupId(IsAutomGroup)",
              [IsAutomGroup],
function(G)
  return FiniteGroupId(G,infinity);
end);


################################################################################
##
#F MarkovOperator. . . . . . . . . . . . . .Computes a matrix of Markov operator
##                                related to group G on the n-th level of a tree

InstallGlobalFunction(MarkovOperator,function(G,n)
  local H,inv,i,el,j,m,d;
  d:=Length(G[1])-1;
  H:=AddInverses(G);
  inv:= InversePerm(H);
  m:=[];
  for i in [1..d^n] do Add(m,[]); od;
  for i in [1..d^n] do
    for j in [1..d^n] do m[i][j]:=0; od;
  od;
  for el in [2..Length(H)] do
    m:=m+GeneratorActionOnLevelAsMatrix(H,el,n);
  od;
  return m;
end);


################################################################################
##
#F IsOneWordSubs. . . . . . . . . . . . Determines if the word in terms of given
##                                                         generators is trivial

InstallGlobalFunction(IsOneWordSubs,function(w,subs,G)
  local i,v;
  v:=[];
  for i in w do Append(v,subs[i]); od;
  return IS_ONE_LIST(v,G);
end);


################################################################################
##
#M FindRelsSubs. . . . . . . . . . . .Finds group relations between given elements
##                                     stops after investigating elements of length max_len
##                                      or when it finds "num_of_rels" relations

InstallMethod(FindRelsSubs, "FindRelsSubs(subs_words,names,G,max_len,num_of_rels)", true,
              [IsList, IsList, IsAutomGroup, IsCyclotomic, IsCyclotomic],
function(subs_words,names,G,max_len,num_of_rels)
  local gens, Gi, H, rel, rels, rels0, k, track_s, track_l, AssocW, FindRelsLocal, gens_autom, i, j, subs, subs1, w_list, FindRelsSubsLocal, w_ext, w, automgens, numstates, F, cur_gen;

  AssocW:=function(w)
     return Product(List(w, i -> gens[i]));
  end;

  FindRelsSubsLocal:=function(subs,G)
    local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,IsNewRelS,inverse,inverseS,H,FinG,tmpl,push,ProductEls,act,rels, LongCycle,invslist,invs,origlength,w,invadded,AssocWrels;

    inverse:=function(w)
      local i, iw;
      iw:=[];
      for i in [1..Length(w)] do
        iw[i]:=w[Length(w)-i+1]^inv;
      od;
      return iw;
    end;

    inverseS:=function(w)
      local i, iw;
      iw:=[];
      for i in [1..Length(w)] do
        iw[i]:=w[Length(w)-i+1]^invs;
      od;
      return iw;
    end;

    ProductEls:=function(i,j)
      local t,v,tmpv;
      v:=StructuralCopy(ElList[i]);
      Append(v,ElList[j]);
      for t in [1..Length(ElList)] do
        tmpv:=StructuralCopy(v);
        Append(tmpv,inverse(ElList[t]));
        if IS_ONE_LIST(tmpv,G) then return t; fi;
      od;
    end;

    LongCycle:=function(n)
      local l,i;
      l:=[];
      for i in [2..n] do Add(l,i); od;
      Add(l,1);
      return PermList(l);
    end;

    IsNewRelS:=function(v)
      local  tmp,i,j,cyc,cycr,v_cyc,r_cyc,r,r_cyc_inv;
      cyc:=LongCycle(Length(v));
      for i in [0..Length(v)-1] do
        v_cyc:=Permuted(v,cyc^i);
        if v_cyc[1]=v_cyc[Length(v)]^invs then return false; fi;
        for r in rels do
          cycr:=LongCycle(Length(r));
          for j in [0..Length(r)-1] do
            r_cyc:=Permuted(r,cycr^j);
            r_cyc_inv:=inverseS(Permuted(r,cycr^j));
            if PositionSublist(v_cyc,r_cyc) <> fail or PositionSublist(v_cyc,r_cyc_inv) <> fail then
              return false;
            fi;
          od;
        od;
      od;
      return true;
    end;
#************************ FindRelsSubsLocal itself ****************************************************

    rels:=[];
    inv:=InversePerm(G);
  #check if there are any identity elements in subs list
    for i in [1..Length(subs)] do
      if IS_ONE_LIST(subs[i],G) then
        Error(AssocW([i]),"=id, remove this element from a list and try again");
      fi;
    od;

    AssocWrels:=[];

  #check if there are any equal elements in subs list
    invslist:=[];
    for i in [1..Length(subs)] do
      for j in [i..Length(subs)] do
        if i<>j and IS_ONE_LIST(Concatenation(subs[i],inverse(subs[j])),G) then
          Error(AssocW([i]),"=",AssocW([j]),", remove one of these elements from a list and try again");
        fi;

  #      Print(IS_ONE_LIST(Append(StructuralCopy(subs[i]),subs[j]),G),"\n");
  #      Print(Concatenation(subs[i],subs[j]),"\n");

        if IS_ONE_LIST(Concatenation(subs[i],subs[j]),G) then
          invslist[i]:=j; invslist[j]:=i;
          Add(rels,[i,j]);
          Add(AssocWrels,AssocW([i,j]));
          Info(InfoAutomata, 3, AssocW([i,j]));
        fi;
      od;
    od;

  # add inverses to subs list
    origlength:=Length(subs);
    invadded:=false;
    for i in [1..origlength] do
      if not IsBound(invslist[i]) then
        invadded:=true;
        Add(subs,inverse(subs[i]));
        Add(gens,gens[i]^-1);
        invslist[i]:=Length(subs);
        invslist[Length(subs)]:=i;
      fi;
    od;

    invs:=PermList(invslist);

    GrList:=[1,Length(subs)+1];
    ElList:=[];

    gr:=1; len:=1;

    for i in [1..Length(subs)] do
      Add(ElList,[i]);
    od;
    while GrList[len+1]>GrList[len] and len<max_len and Length(rels)<num_of_rels do
      for i in [GrList[len]..GrList[len+1]-1] do
        oldgr:=Length(ElList);
        for j in [1..Length(subs)] do
          v:=StructuralCopy(ElList[i]);
          if j<>v[Length(v)]^invs then
            Add(v,j);
            New:=true;
  #          k:=1;
            if len=1 then k:=1; else k:=GrList[len-1]; fi;
            while New and k<=oldgr do
              tmpv:=StructuralCopy(v);
              Append(tmpv,inverseS(ElList[k]));
              if IsOneWordSubs(tmpv,subs,G) then
                New:=false;
  ## show relations
                if IsNewRelS(tmpv) then
                  Add(rels,tmpv);
                  if Length(AssocW(tmpv))>0 then
                    Add(AssocWrels,AssocW(tmpv));
                    Info(InfoAutomata, 3, AssocW(tmpv));
                  fi;
                fi;
              fi;
              k:=k+1;
            od;
            if New then Add(ElList,v); fi;
          fi;
        od;
      od;
      Add(GrList,Length(ElList)+1);
  #    Print("ElList[",len,"]=",ElList,"\n");
      Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList)+1);
      len:=len+1;
    od;
    return AssocWrels;
  end;


#************************ FindRelsSubsMain itself ****************************************************

  if Length(subs_words)<>Length(names) then
    Error("The number of names must coincide with the number of generators");
  fi;
  F:=FreeGroup(names);

# gens is a mutable list of generators
  gens:=[];
  for i in GeneratorsOfGroup(F) do Add(gens,i); od;

  automgens:=UnderlyingAutomFamily(G)!.automgens;
  numstates:=UnderlyingAutomFamily(G)!.numstates;

  subs1:=[];

#convert associative words into lists
  for w in subs_words do
    Add(subs1,CONVERT_ASSOCW_TO_LIST(w));
  od;


  Gi:=StructuralCopy(MINIMIZED_AUTOMATON_LIST(G));
#  Print("Gi=",Gi,"\n");
  H:=Gi[1];

  track_s:=Gi[2];
  track_l:=Gi[3];

  subs:=[];

  for w in subs1 do
    w_list:=[];
    for i in [1..Length(w)] do Add(w_list,track_l[w[i]]); od;
    Add(subs,ShallowCopy(w_list));
  od;
  rels0:=[];

#  for k in [1..Length(AutomatonList(G))] do
#  Print("Beam\n");
#    if track_l[k]=1 then Add(rels0,AssocW([k]));
#      elif track_s[track_l[k]]<>k then Add(rels0,AssocW([k,track_s[track_l[k]]+Length(AutomatonList(G))]));
#    fi;
#  od;


  rels:=FindRelsSubsLocal(subs,CHOOSE_AUTOMATON_LIST(G));
  if rels=fail then return fail; fi;
  Append(rels0,rels);
#  Print(rels0);
  return rels0;
end);

################################################################################
##
#M FindRelsSubs. . . . . . . . . . . . . .Finds group relations between given elements
##                                     stops after investigating elements of length max_len
##

InstallMethod(FindRelsSubs, "FindRelsSubs(subs_words,names,G,max_len)", true,
              [IsList, IsList, IsAutomGroup, IsCyclotomic],
function(subs_words,names,G,max_len)
  return FindRelsSubs(subs_words,names,G,max_len,infinity);
end);


################################################################################
##
#M FindRelsSubs. . . . . . . . . . . . . .Finds group relations between given elements
##
##
InstallMethod(FindRelsSubs, "FindRelsSubs(subs_words,names,G)",
              [IsList, IsList, IsAutomGroup],
function(subs_words,names,G)
  return FindRelsSubs(subs_words,names,G,infinity,infinity);
end);


################################################################################
##
#M FindRelsSubsSG. . . . . . . . . . .Finds relations between given elements
##                                         in the subsemigroup generated by them
##                                     stops after investigating elements of length max_len
##                                     and when it finds "num_of_rels" relations

InstallOtherMethod(FindRelsSubsSG, "FindRelsSubsSG(subs_words,names,G,max_len,num_of_rels)", true,
              [IsList, IsList, IsAutomGroup, IsCyclotomic, IsCyclotomic],
function(subs_words,names,G,max_len,num_of_rels)
  local gens, Gi, H, rel, rels, rels0, k, track_s, track_l, AssocW, gens_autom, i, j, subs, subs1, w_list, FindRelsSubsSGLocal, w_ext, w, automgens, numstates, F, cur_gen;

  AssocW:=function(w)
     return Product(List(w, i -> gens[i]));
  end;

  FindRelsSubsSGLocal:=function(subs,G)
    local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,IsNewRelS,inverse,inverseS,H,FinG,tmpl,push,ProductEls,act,rels, LongCycle,invslist,invs,origlength,w,invadded,Expand,rel,New_rel,AssocWrels;

    #inverse as a word over generators of automaton
    inverse:=function(w)
      local i, iw;
      iw:=[];
      for i in [1..Length(w)] do
        iw[i]:=w[Length(w)-i+1]^inv;
      od;
      return iw;
    end;

    ProductEls:=function(i,j)
      local t,v,tmpv;
      v:=StructuralCopy(ElList[i]);
      Append(v,ElList[j]);
      for t in [1..Length(ElList)] do
        tmpv:=StructuralCopy(v);
        Append(tmpv,inverse(ElList[t]));
        if IS_ONE_LIST(tmpv,G) then return t; fi;
      od;
    end;

    #rewrites a word over subs in terms of generators of automaton
    Expand:=function(v)
    local i,tmpv;
      tmpv:=[];
      for i in [1..Length(v)] do
        Append(tmpv,subs[v[i]]);
      od;
      return tmpv;
    end;

  #************************ FindRelsSubsSGLocal itself ****************************************************

    rels:=[];
    AssocWrels:=[];

    inv:=InversePerm(G);
  #check if there are any identity elements in subs list
    for i in [1..Length(subs)] do
      if IS_ONE_LIST(subs[i],G) then
        Error(AssocW([i]),"=id, remove this element from the list and try again");
      fi;
    od;

  #check if there are any equal elements in subs list
  #  invslist:=[];
    for i in [1..Length(subs)] do
      for j in [i..Length(subs)] do
        if i<>j and IS_ONE_LIST(Concatenation(subs[i],inverse(subs[j])),G) then
          Error(AssocW([i]),"=",AssocW([j]),", remove one of these elements from the list and try again");
        fi;

  #      Print(IS_ONE_LIST(Append(StructuralCopy(subs[i]),subs[j]),G),"\n");
  #      Print(Concatenation(subs[i],subs[j]),"\n");

  #      if IS_ONE_LIST(Concatenation(subs[i],subs[j]),G) then
  #        invslist[i]:=j; invslist[j]:=i;
  #        Add(rels,[i,j]);
  #        Print("[",i,",",j,"]=1\n");
  #      fi;
      od;
    od;

    GrList:=[1,Length(subs)+1];
    ElList:=[];

    gr:=1; len:=1;

    for i in [1..Length(subs)] do
      Add(ElList,[i]);
    od;
    while GrList[len+1]>GrList[len] and len<max_len and Length(rels)<num_of_rels do
      for i in [GrList[len]..GrList[len+1]-1] do
        oldgr:=Length(ElList);
        for j in [1..Length(subs)] do
          v:=StructuralCopy(ElList[i]);
          Add(v,j);
# New stands for New element
          New:=true;
          if IS_ONE_LIST(Expand(v),G) then
            New:=false;
            Add(rels,[v,1]);
            if Length(AssocW(v))>0 then
              Add(AssocWrels,[AssocW(v),One(F)]);
              Info(InfoAutomata, 3, AssocW(v),"=e");
            fi;
          else
            k:=1;
            while New and k<=oldgr do
              tmpv:=Expand(v);
#              Print("v=",v,"; tmpv=",tmpv,"\n");
              Append(tmpv,inverse(Expand(ElList[k])));
              if IS_ONE_LIST(tmpv,G) then
                New:=false;
## show relations
                New_rel:=true;
                for rel in rels do
                  if PositionSublist(v,rel[1]) <> fail then New_rel:=false; fi;
                od;
                if New_rel then
                  Add(rels,[v,ElList[k]]);
#                  if Length(AssocW(v))>0 then
                  Add(AssocWrels,[AssocW(v),AssocW(ElList[k])]);
                  Info(InfoAutomata, 3, AssocW(v),"=",AssocW(ElList[k]));
#                  fi;
                fi;
              fi;

              k:=k+1;
            od;
          fi;
          if New then Add(ElList,v); fi;
        od;
      od;
      Add(GrList,Length(ElList)+1);
      Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList)+1);
      len:=len+1;
    od;
    return AssocWrels;
  end;

#  *********************** FindRelsSubsSG itself ****************************************************

  if Length(subs_words)<>Length(names) then
    Error("The number of names must coincide with the number of generators");
  fi;
  F:=FreeGroup(names);

# gens is a mutable list of generators
  gens:=[];
  for i in GeneratorsOfGroup(F) do Add(gens,i); od;

  automgens:=UnderlyingAutomFamily(G)!.automgens;
  numstates:=UnderlyingAutomFamily(G)!.numstates;

  subs1:=[];

#convert associative words into lists
  for w in subs_words do
    Add(subs1,CONVERT_ASSOCW_TO_LIST(w));
  od;


  Gi:=StructuralCopy(MINIMIZED_AUTOMATON_LIST(G));
#  Print("Gi=",Gi,"\n");
  H:=Gi[1];

  track_s:=Gi[2];
  track_l:=Gi[3];

  subs:=[];

  for w in subs1 do
    w_list:=[];
    for i in [1..Length(w)] do Add(w_list,track_l[w[i]]); od;
    Add(subs,ShallowCopy(w_list));
  od;
  rels0:=[];

#  for k in [1..Length(AutomatonList(G))] do
#  Print("Beam\n");
#    if track_l[k]=1 then Add(rels0,AssocW([k]));
#      elif track_s[track_l[k]]<>k then Add(rels0,AssocW([k,track_s[track_l[k]]+Length(AutomatonList(G))]));
#    fi;
#  od;


  rels:=FindRelsSubsSGLocal(subs,CHOOSE_AUTOMATON_LIST(G));
  if rels=fail then return fail; fi;
  Append(rels0,rels);
#  Print(rels0);
  return rels0;
end);


################################################################################
##
#M FindRelsSubsSG. . . . . . . . . . .Finds relations between given elements
##                                         in the subsemigroup generated by them
##                                     stops after investigating elements of length max_len

InstallMethod(FindRelsSubsSG, "FindRelsSubsSG(subs_words,names,G,max_len)", true,
              [IsList, IsList, IsAutomGroup, IsCyclotomic],
function(subs_words,names,G,max_len)
  return FindRelsSubsSG(subs_words,names,G,max_len,infinity);
end);


################################################################################
##
#M FindRelsSubsSG. . . . . . . . . . . . .Finds relations between given elements
##                                         in the subsemigroup generated by them

InstallMethod(FindRelsSubsSG, "FindRelsSubsSG(subs_words,names,G)",
              [IsList, IsList, IsAutomGroup],
function(subs_words,names,G)
  return FindRelsSubsSG(subs_words,names,G,infinity,infinity);
end);




################################################################################
##
#M FindRels . . . . . . . . . finds relators in terms of the original generators
##
##
InstallMethod(FindRels, "FindRels(G,max_len,num_of_rels)", true,
              [IsAutomGroup, IsCyclotomic, IsCyclotomic],
function(G,max_len,num_of_rels)
  local gens, Gi, H, rel, rels, rels0, k, track_s, track_l, AssocW, FindRelsLocal;

  AssocW:=function(w)
     #Print(w);
     return Product(List(w, i -> gens[i]));
  end;


  FindRelsLocal:=function(subs,G)
    local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,IsNewRelS,inverse,inverseS,H,FinG,tmpl,push,ProductEls,act,rels, LongCycle,invslist,invs,origlength,w,invadded,tmpv_orig,AssocWrels;

    inverse:=function(w)
      local i, iw;
      iw:=[];
      for i in [1..Length(w)] do
        iw[i]:=w[Length(w)-i+1]^inv;
      od;
      return iw;
    end;

    inverseS:=function(w)
      local i, iw;
      iw:=[];
      for i in [1..Length(w)] do
        iw[i]:=w[Length(w)-i+1]^invs;
      od;
      return iw;
    end;

    ProductEls:=function(i,j)
      local t,v,tmpv;
      v:=StructuralCopy(ElList[i]);
      Append(v,ElList[j]);
      for t in [1..Length(ElList)] do
        tmpv:=StructuralCopy(v);
        Append(tmpv,inverse(ElList[t]));
        if IS_ONE_LIST(tmpv,G) then return t; fi;
      od;
    end;

    LongCycle:=function(n)
      local l,i;
      l:=[2..n];
      Add(l,1);
      return PermList(l);
    end;

    IsNewRelS:=function(v)
      local  tmp,i,j,cyc,cycr,v_cyc,r_cyc,r,r_cyc_inv;
      cyc:=LongCycle(Length(v));
      for i in [0..Length(v)-1] do
        v_cyc:=Permuted(v,cyc^i);
        if v_cyc[1]=v_cyc[Length(v)]^invs then return false; fi;
        for r in rels do
          cycr:=LongCycle(Length(r));
          for j in [0..Length(r)-1] do
            r_cyc:=Permuted(r,cycr^j);
            r_cyc_inv:=inverseS(Permuted(r,cycr^j));
            if PositionSublist(v_cyc,r_cyc) <> fail or PositionSublist(v_cyc,r_cyc_inv) <> fail then
              return false;
            fi;
          od;
        od;
      od;
      return true;
    end;
#************************ FinRelsLocal itself ****************************************************

    rels:=[];
    AssocWrels:=[];
    inv:=InversePerm(G);


    invslist:=[];
    for i in [1..Length(subs)] do
      for j in [i..Length(subs)] do
#        Print(AssocW([Gi[2][i+1],Gi[2][j+1]])!.word,"\n");
        if IS_ONE_LIST(Concatenation(subs[i],subs[j]),G) then
          invslist[i]:=j; invslist[j]:=i;
          if Length(AssocW([Gi[2][i+1],Gi[2][j+1]])!.word)>0 then
            Add(rels,[i,j]);
            Add(AssocWrels,AssocW([Gi[2][i+1],Gi[2][j+1]]));
            Info(InfoAutomata, 3, AssocW([Gi[2][i+1],Gi[2][j+1]])!.word);
          fi;
        fi;
      od;
    od;

    invs:=PermList(invslist);

    GrList:=[1,Length(subs)+1];
    ElList:=[];

    gr:=1; len:=1;

    for i in [1..Length(subs)] do
      Add(ElList,[i]);
    od;
    while GrList[len+1]>GrList[len] and len<max_len and Length(rels)<num_of_rels do
      for i in [GrList[len]..GrList[len+1]-1] do
        oldgr:=Length(ElList);
        for j in [1..Length(subs)] do
          v:=StructuralCopy(ElList[i]);
          if j<>v[Length(v)]^invs then
            Add(v,j);
            New:=true;
 #          k:=1;
            if len=1 then k:=1; else k:=GrList[len-1]; fi;
            while New and k<=oldgr do
              tmpv:=StructuralCopy(v);
              Append(tmpv,inverseS(ElList[k]));
              if IsOneWordSubs(tmpv,subs,G) then
                New:=false;
## show relations
                if IsNewRelS(tmpv) then
# tmpv in the original generators
                  tmpv_orig:=[];
                  for k in [1..Length(tmpv)] do
                    tmpv_orig[k]:=Gi[2][tmpv[k]+1];
                  od;
                  Add(rels,tmpv);
                  if Length(AssocW(tmpv_orig)!.word)>0 then
                    Add(AssocWrels,AssocW(tmpv_orig));
                    Info(InfoAutomata, 3, AssocW(tmpv_orig)!.word);
                  fi;
#                 Print(tmpv,"\n");
                fi;
              fi;
              k:=k+1;
            od;
            if New then Add(ElList,v); fi;
          fi;
        od;
      od;
      Add(GrList,Length(ElList)+1);
 #    Print("ElList[",len,"]=",ElList,"\n");
      Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList)+1);
      len:=len+1;
    od;
    return AssocWrels;
  end;

#************************ FinRels itself ****************************************************

  gens:=UnderlyingAutomFamily(G)!.automgens;

  Gi:=StructuralCopy(MINIMIZED_AUTOMATON_LIST(G));
#  Print("Gi=",Gi,"\n");
  H:=Gi[1];

  track_s:=Gi[2];
  track_l:=Gi[3];
  rels0:=[];

#  for k in [1..Length(AutomatonList(G))] do
#  Print("Beam\n");
#    if track_l[k]=1 then Add(rels0,AssocW([k]));
#      elif track_s[track_l[k]]<>k then Add(rels0,AssocW([k,track_s[track_l[k]]+Length(AutomatonList(G))]));
#    fi;
#  od;


  rels:=FindRelsLocal(List([2..Length(H)],i->[i]),CHOOSE_AUTOMATON_LIST(G));
  Append(rels0,rels);
#  Print(rels0);
  return rels0;
end);


################################################################################
##
#M FindRels . . . . . . . . . Finds relatoins in terms of the original generators
##
##
InstallMethod(FindRels, "FindRels(G,max_len)", true,
              [IsAutomGroup, IsCyclotomic],
function(G,max_len)
  return FindRels(G,max_len,infinity);
end);



################################################################################
##
#M FindRels . . . . . . . . . Finds relatoins in terms of the original generators
##
##
InstallMethod(FindRels, "FindRels(G)",
              [IsAutomGroup],
function(G)
  return FindRels(G,infinity,infinity);
end);


################################################################################
##
#M FindRels . . . . . . . . . Fing relatoins in terms of the original generators
##
##
InstallMethod(FindRels, "FindRels(G)",
              [IsAutomGroup],
function(G)
  return FindRels(G,infinity,infinity);
end);


################################################################################
##
#M HAS_INFINITE_ORDER     returns true if there is a section h<>1 of a
##   such that h^k has h as a section
##

InstallMethod(HAS_INFINITE_ORDER, "HAS_INFINITE_ORDER(IsAutom,IsCyclotomic)", true,
              [IsAutom, IsCyclotomic],
function(a, max_depth)
  local HAS_INFINITE_ORDER_LOCAL, cur_list, F, degs, vertex, AreConjugateUsingSmallRels, gens_ord2, CyclicallyReduce, res;

  CyclicallyReduce:=function(w)
    local i,j,wtmp,reduced;

    for i in [1..Length(w)] do
      if -w[i] in gens_ord2 then w[i]:=-w[i]; fi;
    od;

    repeat
      reduced:=true;
      j:=1;
      while reduced  and j<Length(w) do
        if w[j]=-w[j+1] or (w[j]=w[j+1] and w[j] in gens_ord2) then
          reduced:=false;
          wtmp:=ShallowCopy(w{[1..j-1]});
          Append(wtmp,w{[j+2..Length(w)]});
          w:=wtmp;
        fi;
        j:=j+1;
      od;
    until reduced;

    repeat
      if Length(w)<2 then return w; fi;
      reduced:=true;
      if w[1]=-w[Length(w)] or (w[1]=w[Length(w)] and w[1] in gens_ord2) then
        w:=w{[2..Length(w)-1]};
        reduced:=false;
      fi;
    until reduced;

    return w;
  end;

  AreConjugateUsingSmallRels:=function(g,h)
    local i, g_list, h_list,long_cycle,l;
    g_list:=CyclicallyReduce(LetterRepAssocWord(g));
    h_list:=CyclicallyReduce(LetterRepAssocWord(h));
    if Length(g_list)<>Length(h_list) then return false; fi;
    l:=[2..Length(g_list)];
    Add(l,1);
    long_cycle:=PermList(l);
    for i in [0..Length(g_list)-1] do
      if h_list=Permuted(g_list,long_cycle^i) then return true; fi;
    od;
    return false;
  end;

  HAS_INFINITE_ORDER_LOCAL:=function(g)
    local i,el,orb,Orbs,res,st,reduced_word;
    if IsOne(g) then return fail; fi;
    for i in [1..Length(cur_list)] do
      el:=cur_list[i];
      if (AreConjugateUsingSmallRels(g!.word, el!.word) or AreConjugateUsingSmallRels((g!.word)^(-1), el!.word)) then
        if Product(degs{[i..Length(degs)]})>1 then
          Info(InfoAutomata,3,"(",a!.word,")^",Product(degs{[1..i-1]})," has ", el!.word, " as a section at vertex ",vertex{[1..i-1]});
          Info(InfoAutomata,3,"(",el!.word,")^",Product(degs{[i..Length(degs)]})," has congutate of ",g!.word, " as a section at vertex ",vertex{[i..Length(degs)]});
          SetIsFinite(GroupOfAutomFamily(FamilyObj(a)),false);
          return true;
        else
#          Info(InfoAutomata,3,"The group <G> might not be contracting, ",g," has itself as a section.");
          return fail;
        fi;
      fi;
    od;
    if Length(cur_list)>=max_depth then return fail; fi;
    Add(cur_list,g);
    Orbs:=OrbitsPerms([g!.perm],[1..g!.deg]);

    for orb in Orbs do
      Add(degs,Length(orb));
      Add(vertex,orb[1]);
#      res:=HAS_INFINITE_ORDER_LOCAL(Autom(CyclicallyReducedWord(State(g^Length(orb),orb[1])!.word),FamilyObj(g)));
#      Print(g^Length(orb),"\n");
      st:=State(g^Length(orb),orb[1]);
      reduced_word:=AssocWordByLetterRep(FamilyObj(st!.word),CyclicallyReduce(LetterRepAssocWord(st!.word)));
#      Print(st!.word," at ",vertex,"\n");
      res:=HAS_INFINITE_ORDER_LOCAL(Autom(reduced_word,FamilyObj(g)));
      if res=true then return true; fi;
      Unbind(degs[Length(degs)]);
      Unbind(vertex[Length(vertex)]);
    od;
    Unbind(cur_list[Length(cur_list)]);
    return fail;
  end;

  F:=FamilyObj(a)!.freegroup;
  gens_ord2:=GeneratorsOfOrderTwo(FamilyObj(a));
  cur_list:=[];
# degs traces at what positions we raise to what power
  degs:=[]; vertex:=[];
  res:=HAS_INFINITE_ORDER_LOCAL(a);
  if res=true then SetOrder(a,infinity); fi;
  return res;
end);


################################################################################
##
#F SUSPICIOUS_FOR_NONCONTRACTION   returns 'true' if there is a vertex v,
##                                        such that a(v)=v, a|_v=a or a|_v=a^-1
InstallGlobalFunction(SUSPICIOUS_FOR_NONCONTRACTION, function(a)
  local SUSPICIOUS_FOR_NONCONTRACTION_LOCAL, cur_list, F, vertex;

  SUSPICIOUS_FOR_NONCONTRACTION_LOCAL:=function(g)
  local i,res;
    if IsOne(g) or g!.perm<>() then return false; fi;

    if (g!.word in cur_list) or (g!.word^(-1) in cur_list) then
      if g=a or g=a^-1 then
#        Info(InfoAutomata,3,a!.word," has ",g!.word," as a section at vertex ",vertex);
        return true;
      else return false;  fi;
    fi;

    Add(cur_list,g!.word);

    for i in [1..FamilyObj(a)!.deg] do
      Add(vertex,i);
      res:=SUSPICIOUS_FOR_NONCONTRACTION_LOCAL(State(g,i));
      if res then return true; fi;
      Unbind(vertex[Length(vertex)]);
    od;
    return false;
  end;

  F:=FamilyObj(a)!.freegroup;
  cur_list:=[];
# degs traces at what positions we raise to what power
  vertex:=[];
  return SUSPICIOUS_FOR_NONCONTRACTION_LOCAL(a);
end);



################################################################################
##
#F FindGroupElement              enumerates elements of the group until it finds
##          an element g of length at most n, for which func(g)=val. Returns g
##
InstallGlobalFunction(FindGroupElement,function(G,func,val,n)
  local ElList,GrList,i,j,orig_gens,gen,gens,new_gen,g,len,viewed,oldgr,New,k;

  orig_gens:=ShallowCopy(GeneratorsOfSemigroup(G));
  gens:=[];

# select pairwise different generators
  for i in [1..Length(orig_gens)] do
    if IsOne(orig_gens[i]) then
      new_gen:=false;
    else
      new_gen:=true;
      for j in [1..i-1] do if orig_gens[i]=orig_gens[j] then new_gen:=false; fi; od;
      if new_gen then Add(gens,orig_gens[i]); fi;
    fi;
  od;

  if func(One(G))=val then return One(G); fi;
  for g in gens do
    if func(g)=val then return g; fi;
  od;

  ElList:=[One(G)]; Append(ElList,ShallowCopy(gens));
  GrList:=[1,Length(gens)+1];
  len:=1;

  while len<n do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for gen in gens do
        g:=ElList[i]*gen;
#       Print("g=",g,"\n\n");
        New:=true;
        if len=1 then k:=1; else k:=GrList[len-1]; fi;
        while New and k<=oldgr do
#          Print(g*ElList[k]^-1,"\n");
          if IsOne(g*ElList[k]^-1) then New:=false; fi;
          k:=k+1;
        od;
        if New then
          if func(g)=val then return g; fi;
          Add(ElList,g);
        fi;
      od;
    od;
    Add(GrList,Length(ElList));
    Info(InfoAutomata,3,"Length not greater than ",len+1,": ",Length(ElList));
    len:=len+1;
  od;
  return fail;
end);


################################################################################
##
#F FindGroupElements              enumerates elements of the group of length at most n
##          and returns the list of elements g, for which func(g)=val.
##
InstallGlobalFunction(FindGroupElements,function(G,func,val,n)
  local ElList,GrList,i,j,orig_gens,gen,gens,new_gen,g,len,viewed,oldgr,New,k,cur_els;

  orig_gens:=ShallowCopy(GeneratorsOfSemigroup(G));
  gens:=[];

# select pairwise different generators
  for i in [1..Length(orig_gens)] do
    if IsOne(orig_gens[i]) then
      new_gen:=false;
    else
      new_gen:=true;
      for j in [1..i-1] do if orig_gens[i]=orig_gens[j] then new_gen:=false; fi; od;
      if new_gen then Add(gens,orig_gens[i]); fi;
    fi;
  od;

  if func(One(G))=val then Add(cur_els,One(G)); fi;
  for g in gens do
    if func(g)=val then Add(cur_els,g); fi;
  od;

  ElList:=[One(G)]; Append(ElList,ShallowCopy(gens));
  GrList:=[1,Length(gens)+1];
  cur_els:=[];
  len:=1;

  while len<n do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for gen in gens do
        g:=ElList[i]*gen;
        New:=true;
        if len=1 then k:=1; else k:=GrList[len-1]; fi;
        while New and k<=oldgr do
          if IsOne(g*ElList[k]^-1) then New:=false; fi;
          k:=k+1;
        od;
        if New then
          if func(g)=val then 
            Add(cur_els,g);
            Print(g,"\n");
          fi;
          Add(ElList,g);
        fi;
      od;
    od;
    Add(GrList,Length(ElList));
    Info(InfoAutomata,3,"Length not greater than ",len+1,": ",Length(ElList));
    len:=len+1;
  od;
  return cur_els;
end);



################################################################################
##
#F FindElementOfInfiniteOrder   enumerates elements of the group until it finds
##                              an element of infinite order of length at most <n>
##                              each element is investigated up to depth <depth>
InstallGlobalFunction(FindElementOfInfiniteOrder,function(G,n,depth)
  local CheckOrder, res;
  CheckOrder:=function(g) return HAS_INFINITE_ORDER(g,depth); end;
  res:=FindGroupElement(G,CheckOrder,true,n);
  if res<>fail then SetIsFinite(G,false); fi;
  return res;
end);



################################################################################
##
#F IsNoncontracting             enumerates elements of the group until it finds
##                              an element of infinite order of length at most <n>
##                              which stabilizes some vertex and has itself as a
##                              section at this vertex
##                              each element is investigated up to depth <depth>
InstallGlobalFunction(IsNoncontracting,function(G,n,depth)
  local IsNoncontrElement, res;
  IsNoncontrElement:=function(g)
    if SUSPICIOUS_FOR_NONCONTRACTION(g) then
      return HAS_INFINITE_ORDER(g,depth);
    fi;
    return false;
  end;

  res:=FindGroupElement(G,IsNoncontrElement,true,n);
  if res<>fail then
    SetIsFinite(G,false);
    SetIsContracting(G,false);
    return true;
  fi;
  return fail;
end);


################################################################################
##
#F OrdersOfGroupElementsMain . . . . . Enumerates all elements of a self-similar
##             group up to length n and tries to find their orders up to order O
##                  returns true if all the orders are finite and fail otherwise
##         in case stop=true returns fail as soon as it finds suspicious element

InstallGlobalFunction(OrdersOfGroupElementsMain,function(n,O,stop,G)
  local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,inverse,H, periodic, order_v;

  inverse:=function(w)
    local i, iw;
    iw:=[];
    for i in [1..Length(w)] do
      iw[i]:=w[Length(w)-i+1]^inv;
    od;
    return iw;
  end;

  gr:=1; len:=1; periodic:=true;

  H:=AddInverses(G);
  if G<>H then
    Info(InfoAutomata, 3, "Inverses were added. Automaton was minimized. Now generator set is:\n",H);
    G:=H;
  fi;
  inv:=InversePerm(G);
  GrList:=[1,Length(G)];
  ElList:=[];
  for i in [1..Length(G)] do
    Add(ElList,[i]);
  od;

  for v in ElList do
    order_v:=ORDER_OF_ELEMENT(v,G,O);
    Info(InfoAutomata, 3, "Order of ", v, ": ", order_v);
    if order_v = fail then
      if stop then return fail;
        else periodic:=fail;
      fi;
    fi;
  od;

  while len<n do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for j in [2..Length(G)] do
        v:=StructuralCopy(ElList[i]);
        Add(v,j);
        New:=true;
        if len=1 then k:=1; else k:=GrList[len-1]; fi;
        while New and k<=oldgr do
          tmpv:=StructuralCopy(v);
          Append(tmpv,inverse(ElList[k]));
          if IS_ONE_LIST(tmpv,G) then New:=false; fi;
          k:=k+1;
        od;
        if New then
          Add(ElList,v);
          order_v:=ORDER_OF_ELEMENT(v,G,O);
          Info(InfoAutomata, 3, "Order of ", v, ": ", order_v);

          if order_v = fail then
            if stop then return fail;
              else periodic:=fail;
            fi;
          fi;

        fi;
      od;
    od;
    Add(GrList,Length(ElList));
#    Print("Length not greater than ",len+1,": ",Length(ElList),"\n");
    len:=len+1;
  od;

  return periodic;
end);





################################################################################
##
#F OrdersOfGroupElements . . . . . . . Enumerates all elements of a self-similar
##             group up to length n and tries to find their orders up to order O
##                  returns true if all the orders are finite and fail otherwise

InstallGlobalFunction(OrdersOfGroupElements,function(n,O,G)
  return OrdersOfGroupElementsMain(n,O,false,G);
end);


################################################################################
##
#F PeriodicityGuess. . . . . . . . . . Enumerates all elements of a self-similar
##             group up to length n and tries to find their orders up to order O
##                  returns true if all the orders are finite and fail otherwise
##                           returns fail as soon as it finds suspicious element

InstallGlobalFunction(PeriodicityGuess,function(n,O,G)
  return OrdersOfGroupElementsMain(n,O,true,G);
end);


################################################################################
##
#F FindTransitiveElements . . . . . . .Finds all elements of a group G which are
##                      transitive on a level lev and have length no more than n
##                in case stop=true stops when it finds first transitive element

InstallGlobalFunction(FindTransitiveElements,function(n,lev,stop,G)
  local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,inverse,H, TransElList;

  inverse:=function(w)
    local i, iw;
    iw:=[];
    for i in [1..Length(w)] do
      iw[i]:=w[Length(w)-i+1]^inv;
    od;
    return iw;
  end;

  gr:=1; len:=1;

  H:=AddInverses(G);
  if G<>H then
    Info(InfoAutomata, 3, "Inverses were added. Automaton was minimized. Now generator set is:\n",H);
    G:=H;
  fi;
  inv:=InversePerm(G);
  GrList:=[1,Length(G)];
  ElList:=[];
  TransElList:=[];

  for i in [1..Length(G)] do
    Add(ElList,[i]);
  od;

  for v in ElList do
    if IsWordTransitiveOnLevel(G,v,lev) then
      if stop then return v;
        else Add(TransElList,v);
      fi;
    fi;
  od;

  while len<n do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for j in [2..Length(G)] do
        v:=StructuralCopy(ElList[i]);
        Add(v,j);
        New:=true;
        if len=1 then k:=1; else k:=GrList[len-1]; fi;
        while New and k<=oldgr do
          tmpv:=StructuralCopy(v);
          Append(tmpv,inverse(ElList[k]));
          if IS_ONE_LIST(tmpv,G) then New:=false; fi;
          k:=k+1;
        od;
        if New then
          Add(ElList,v);

          if IsWordTransitiveOnLevel(G,v,lev) then
            if stop then return v;
              else Add(TransElList,v);
            fi;
          fi;

        fi;
      od;
    od;
    Add(GrList,Length(ElList));
#    Print("Length not greater than ",len+1,": ",Length(ElList),"\n");
    len:=len+1;
  od;

  return TransElList;
end);


################################################################################
##
#M IsGeneratedByAutomatonOfPolynomialGrowth
##
##

InstallMethod(IsGeneratedByAutomatonOfPolynomialGrowth,"IsGeneratedByAutomatonOfPolynomialGrowth(IsAutomatonGroup)",true,
              [IsAutomatonGroup],
function(G)
  local i,d,ver,nstates,cycles,cycle_of_vertex, IsNewCycle,known_vertices,aut_list,HasPolyGrowth,cycle_order,next_cycles,cur_cycles,cur_path,cycles_of_level,lev;

  IsNewCycle:=function(C)
    local i, l, cur_cycle, long_cycle;
    l:=[2..Length(C)];
    Add(l,1);
    long_cycle:=PermList(l);

    for cur_cycle in cycles do
      if Intersection(cur_cycle,C)<>[] then
#        if Length(C)<>Length(cur_cycle) then return fail; fi;
#        for i in [0..Length(C)-1] do
#          if cur_cycle=Permuted(C,long_cycle^i) then return false; fi;
#        od;
        Print("cycle1=",cur_cycle,"cycle2=",C,"\n");
        return fail;
      fi;
    od;
    return true;
  end;

#  Example:
#  cycles = [[1,2,4],[3,5,6],[7]]
#  cur_cycles = [1,3] (the first and the third cycles)
#  cycle_order = [[2,3],[3],[]] (means 1->2->3,  1->3)

  HasPolyGrowth:=function(v)
    local i,v_next,is_new,C,ver;
#    Print("v=",v,"\n");
    Add(cur_path,v);
    for i in [1..d] do
      v_next:=aut_list[v][i];
      if not (v_next in known_vertices or v_next=2*nstates+1) then
        if v_next in cur_path then
          C:=cur_path{[Position(cur_path,v_next)..Length(cur_path)]};
          is_new:=IsNewCycle(C);
          if is_new=fail then
            return false;
          else
            Add(cycles,C);
            Add(cycle_order,[]);
            for ver in C do
#              Print("next_cycles = ",next_cycles);
              UniteSet(cycle_order[Length(cycles)],next_cycles[ver]);
              cycle_of_vertex[ver]:=Length(cycles);
              next_cycles[ver]:=[Length(cycles)];
            od;
          fi;
        else
          if not HasPolyGrowth(v_next) then
            return false;
          fi;
          if cycle_of_vertex[v]=0 then
            UniteSet(next_cycles[v],next_cycles[v_next]);
          elif cycle_of_vertex[v]<>cycle_of_vertex[v_next] then
            UniteSet(cycle_order[cycle_of_vertex[v]],next_cycles[v_next]);
            Info(InfoAutomata,5,"v=",v,"; v_next=",v_next,"\n");
            Info(InfoAutomata,5,"cycle_order (local) = ",cycle_order);
          fi;
        fi;
      elif v_next in known_vertices then
        if cycle_of_vertex[v]=0 then
          UniteSet(next_cycles[v],next_cycles[v_next]);
        elif cycle_of_vertex[v]=cycle_of_vertex[v_next] then
          return false;
        else
          UniteSet(cycle_order[cycle_of_vertex[v]],next_cycles[v_next]);
        fi;

      fi;
    od;
    Remove(cur_path);
    Add(known_vertices,v);
    return true;
  end;

  nstates:=UnderlyingAutomFamily(G)!.numstates;
  aut_list:=AutomatonList(G);
  d:=UnderlyingAutomFamily(G)!.deg;
  cycles:=[];
  cycle_of_vertex:=List([1..nstates],x->0);  #if vertex i is in cycle j, then cycle_of_vertex[i]=j
  next_cycles:=List([1..nstates],x->[]); #if vertex i is not in a cycle, next_cycles[i] stores the list of cycles, that can be reached immediately (with no cycles in between) from this vertex
  known_vertices:=[];
  cur_path:=[];
  cycle_order:=[];

  while Length(known_vertices)<nstates do
    ver:=Difference([1..nstates],known_vertices)[1];
    if not HasPolyGrowth(ver) then
      SetIsGeneratedByBoundedAutomaton(G,false);
      return false;
    fi;
  od;

# Now we find the longest chain in the poset of cycles
  cycles_of_level:=[[]];
  for i in [1..Length(cycles)] do
    if cycle_order[i]=[] then Add(cycles_of_level[1],i); fi;
  od;

  lev:=1;

  while cycles_of_level[Length(cycles_of_level)]<>[] do
    Add(cycles_of_level,[]);
    for i in [1..Length(cycles)] do
      if Intersection(cycles_of_level[lev],cycle_order[i])<>[] then
        Add(cycles_of_level[lev+1],i);
      fi;
    od;
    lev:=lev+1;
  od;

  if lev=2 then
    SetIsGeneratedByBoundedAutomaton(G,true);
    SetIsAmenable(G,true);
  elif lev=1 then
    SetIsGeneratedByBoundedAutomaton(G,true);
    SetIsFinite(G,true);
  else
    SetIsGeneratedByBoundedAutomaton(G,false);
  fi;
  SetPolynomialDegreeOfGrowthOfAutomaton(G,lev-2);
  Info(InfoAutomata,5,"Cycles = ", cycles);
  Info(InfoAutomata,5,"cycle_order = ", cycle_order);
  Info(InfoAutomata,5,"next_cycles = ", next_cycles);
  return true;
end);


################################################################################
##
#M IsGeneratedByBoundedAutomaton
##
##
InstallMethod(IsGeneratedByBoundedAutomaton,"IsGeneratedByBoundedAutomaton(IsAutomatonGroup)",true,
              [IsAutomatonGroup],
function(G)
  local res;
  res:=IsGeneratedByAutomatonOfPolynomialGrowth(G);
  return IsGeneratedByBoundedAutomaton(G);
end);


################################################################################
##
#M PolynomialDegreeOfGrowthOfAutomaton
##
##
InstallMethod(PolynomialDegreeOfGrowthOfAutomaton,"PolynomialDegreeOfGrowthOfAutomaton(IsAutomatonGroup)",true,
              [IsAutomatonGroup],
function(G)
  local res;
  res:=IsGeneratedByAutomatonOfPolynomialGrowth(G);
  if not res then
    Info(InfoAutomata,"Error: the automaton generating <G> has exponenetial growth");
    return fail;
  fi;
  return PolynomialDegreeOfGrowthOfAutomaton(G);
end);


################################################################################
##
#M IsAmenable
##
##
InstallMethod(IsAmenable,"IsAmenable(IsAutomGroup)",true,
              [IsAutomGroup],
function(G)
  if IsGeneratedByBoundedAutomaton(GroupOfAutomFamily(G)) then return true; fi;
  if IsAutomatonGroup(G) and IsAbelian(StabilizerOfLevel(G,2)) then return true; fi;
  TryNextMethod();
end);


#E
