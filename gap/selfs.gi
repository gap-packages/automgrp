#############################################################################
##
#W  selfs.gi             automata package                      Yevgen Muntyan
#W                                                             Dmytro Savchuk
##  automata v 0.91 started June 07 2004
##
#Y  Copyright (C) 2003-2007 Yevgen Muntyan, Dmytro Savchuk
##



InstallOtherMethod(\^,"list^perm",true,[IsList,IsPerm],0,
function(l,p)
  return Permuted(l,p);
end);

################################################################################
##
#F ReduceWord . . . . . . . . . . . . . . . . . . . . . . .cuts 1s from the word
##
InstallGlobalFunction(ReduceWord,
function(v)
  local i,b;
  b:=[];
  for i in [1..Length(v)] do
    if v[i]<>1 then
      Add(b,v[i]);
    fi;
  od;
  return b;
end);


################################################################################
##
#F ProjectWord. . . . . . . . . . . . . . . .computes the projection of the word
##                                     onto a subtree #s in a self-similar group

InstallGlobalFunction(ProjectWord, function(w,s,G)
  local i,perm,d,proj;
  d:=Length(G[1])-1;
  if s>d then
    Error("Incorrect index of a subtree");
  fi;
  proj:=[];
  perm:=();
  for i in [1..Length(w)] do
    Add(proj,G[w[i]][s^perm]);
    perm:=perm*G[w[i]][d+1];
  od;
  return proj;
end);

################################################################################
##
#F WordActionOnFirstLevel . . . . . . . . . . . .computes the permutation of the
##          first level vertices generated by an element of a self-similar group

InstallGlobalFunction(WordActionOnFirstLevel,function(w,G)
  local i,perm,d;
  d:=Length(G[1])-1;
  perm:=();
  for i in [1..Length(w)] do perm:=perm*G[w[i]][d+1]; od;
  return perm;
end);


################################################################################
##
#F WordActionOnVertex . . . . . . . . . . . . . computes the image of the vertex
##                        under the action of an element of a self-similar group

InstallGlobalFunction(WordActionOnVertex,function(w,ver,G)
  local i, cur_w, new_ver, perm;
  new_ver:=[];
  cur_w:=ShallowCopy(w);
  for i in [1..Length(ver)] do
    perm:=WordActionOnFirstLevel(cur_w,G);
    new_ver[i]:=ver[i]^perm;
    cur_w:=ProjectWord(cur_w,ver[i],G);
  od;
  return new_ver;
end);


##  <#GAPDoc Label="OrbitOfVertex">
##  <ManSection >
##  <Oper Arg="ver, g[, n]" Name="OrbitOfVertex" />
##  <Description>
##  Returns the list of vertices in the orbit of vertex <A>ver</A> under the
##  action of a semigroup generated by an automorphism <A>g</A>.
##  If <A>n</A> is specified, it returns only first <A>n</A> elements of the orbit.
##  Vertices are defined either as lists with entries from <C>[1..d]</C>, or as
##  strings containing characters <C>1</C>,...,<C>d</C>, where <C>d</C>
##  is the degree of the tree.
##  <Example>
##  gap> g:=AutomGroup("t=(1,t)(1,2)");;
##  gap> OrbitOfVertex([1,1,1],t);
##  [ [ 1, 1, 1 ], [ 2, 1, 1 ], [ 1, 2, 1 ], [ 2, 2, 1 ], [ 1, 1, 2 ], [ 2, 1, 2 ],
##  [ 1, 2, 2 ], [ 2, 2, 2 ] ]
##  gap> OrbitOfVertex("111111111111",t,6);
##  [ [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
##  [ 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
##  [ 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ]
##  </Example>
##  </Description>
##  </ManSection>
##  <#/GAPDoc>
##

######################################################################################
##
#O  OrbitOfVertex (<ver>, <g>[, <n>])
##
##  Returns the list of vertices in the orbit of vertex <ver> under the
##  action of a semigroup generated by an automorphism <g>.
##  If <n> is specified, it returns only first <n> elements of the orbit.
##  Vertices are defined either as lists with entries from `[1..d]', or as
##  strings containing characters `1,...,d', where `d'
##  is the degree of the tree.
##  \beginexample
##  gap> g:=AutomGroup("t=(1,t)(1,2)");;
##  gap> OrbitOfVertex([1,1,1],t);
##  [ [ 1, 1, 1 ], [ 2, 1, 1 ], [ 1, 2, 1 ], [ 2, 2, 1 ], [ 1, 1, 2 ], [ 2, 1, 2 ],
##  [ 1, 2, 2 ], [ 2, 2, 2 ] ]
##  gap> OrbitOfVertex("111111111111",t,6);
##  [ [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
##  [ 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
##  [ 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ]
##  \endexample
##
InstallMethod(OrbitOfVertex, "OrbitOfVertex(IsList,IsAutomaton,IsCyclotomic)", true, [IsList,IsAutomaton,IsCyclotomic],
function(ver,g,n)
  local i, ver_tmp, orb;
  i:=0; orb:=[];
  ver_tmp:=ver;
  while i<n and (ver<>ver_tmp or i=0) do
    Add(orb, ver_tmp);
    ver_tmp:=ver_tmp^g;
    i:=i+1;
  od;
  return orb;
end);


InstallMethod(OrbitOfVertex, "OrbitOfVertex(IsList,IsAutomaton)", [IsList,IsAutomaton],
function(ver,g)
  return OrbitOfVertex(ver,g,infinity);
end);


InstallMethod(OrbitOfVertex, "OrbitOfVertex(IsString,IsAutomaton,IsCyclotomic)", true, [IsString,IsAutomaton,IsCyclotomic],
function(ver,g,n)
  local i, ver_tmp, orb, ch;

  ver_tmp:=[];
  for i in [1..Length(ver)] do
    ch:=Int(String([ver[i]]));
    if ch<1 or ch>g!.deg then
      Error("received string ", ver, " does not represent a valid vertex");
    fi;
    Add(ver_tmp,ch);
  od;
  ver:=ver_tmp;

  i:=0; orb:=[];
  ver_tmp:=ver;
  while i<n and (ver<>ver_tmp or i=0) do
    Add(orb, ver_tmp);
    ver_tmp:=ver_tmp^g;
    i:=i+1;
  od;
  return orb;
end);


InstallMethod(OrbitOfVertex, "OrbitOfVertex(IsString,IsAutomaton)", [IsString,IsAutomaton],
function(ver,g)
  return OrbitOfVertex(ver,g,infinity);
end);



##  <#GAPDoc Label="PrintOrbitOfVertex">
##  <ManSection >
##  <Oper Arg="ver, g[, n]" Name="PrintOrbitOfVertex" />
##  <Description>
##  Prints the orbit of vertex <A>ver</A> under the
##  action of a semigroup generated by an automorphism <A>g</A>. Each vertex is printed
##  as a string containing characters <C>1</C>,...,<C>d</C>, where <C>d</C>
##  is the degree of the tree. In case of binary tree the symbols ' ' and '<C>x</C>' are used
##  to represent <C>1</C> and <C>2</C>.
##  If <A>n</A> is specified only first <A>n</A> elements of the orbit are printed.
##  Vertices are defined either as lists with entries from <C>[1..d]</C>, or as
##  strings
##  <Example><![CDATA[
##  gap> g:=AutomGroup("a=(b,a)(1,2),b=(b,a)");
##  < a, b >
##  gap> PrintOrbitOfVertex("2222222222222222222222222222222",a*b^-2,6);
##  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
##
##  x x x x x x x x x x x x x x x x
##   xx  xx  xx  xx  xx  xx  xx  xx
##  xxx xxx xxx xxx xxx xxx xxx xxx
##     xxxx    xxxx    xxxx    xxxx
##  gap> h:=AutomGroup("a=(b,1,1)(1,2,3),b=(a,b,a)(1,2)");;
##  gap> PrintOrbitOfVertex([1,2,1],b^2);
##  121
##  132
##  123
##  131
##  122
##  133]]>
##  </Example>
##  </Description>
##  </ManSection>
##  <#/GAPDoc>
##


######################################################################################
##
#O  PrintOrbitOfVertex (<ver>, <g>[, <n>])
##
##  Prints the orbit of vertex <A>ver</A> under the
##  action of a semigroup generated by an automorphism <A>g</A>. Each vertex is printed
##  as a string containing characters <C>1</C>,...,<C>d</C>, where 'd'
##  is the degree of the tree. In case of binary tree the symbols \lq \rq and \lq'x'\rq are used
##  to represent `1' and `2'.
##  If <n> is specified only first <n> elements of the orbit are printed.
##  Vertices are defined either as lists with entries from `[1..d]', or as
##  strings
##  \beginexample
##  gap> g:=AutomGroup("a=(b,a)(1,2),b=(b,a)");
##  < a, b >
##  gap> PrintOrbitOfVertex("2222222222222222222222222222222",a*b^-2,6);
##  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
##
##  x x x x x x x x x x x x x x x x
##   xx  xx  xx  xx  xx  xx  xx  xx
##  xxx xxx xxx xxx xxx xxx xxx xxx
##     xxxx    xxxx    xxxx    xxxx
##  gap> h:=AutomGroup("a=(b,1,1)(1,2,3),b=(a,b,a)(1,2)");;
##  gap> PrintOrbitOfVertex([1,2,1],b^2);
##  121
##  132
##  123
##  131
##  122
##  133
##  \endexample
##
InstallMethod(PrintOrbitOfVertex, "PrintOrbitOfVertex(IsList,IsAutomaton,IsCyclotomic)", [IsString,IsAutomaton,IsCyclotomic],
function(ver,w,n)
  local orb,i,j;
  orb:=OrbitOfVertex(ver,w,n);
  if w!.deg=2 then
    for i in [1..Length(orb)] do
      for j in [1..Length(orb[1])] do
        #  Print(orb[i][j]);
        if orb[i][j]=1 then Print(" "); else Print("x"); fi;
      od;
      Print("\n");
    od;
  else
     for i in [1..Length(orb)] do
      for j in [1..Length(orb[1])] do
        Print(orb[i][j]);
      od;
      Print("\n");
    od;
  fi;
end);

InstallMethod(PrintOrbitOfVertex, "OrbitOfVertex(IsString,IsAutomaton)", [IsList,IsAutomaton],
function(ver,g)
  PrintOrbitOfVertex(ver,g,infinity);
end);


################################################################################
##
#F IsOneWordSelfSim. . . . . . . . . . . . . . . . checks if the word is trivial
##                             in any self-similar group (exponential algorithm)

InstallGlobalFunction(IsOneWordSelfSim,function(w,G)
  local i,IsOneWordIter,ReachedWords,d;

  IsOneWordIter:=function(v)
  local i,j,perm;
    if v in ReachedWords then return true;
    else
      perm:=();
      for i in [1..Length(v)] do perm:=perm*G[v[i]][d+1]; od;
      if perm<>() then return false; fi;
      Add(ReachedWords,v);
      for j in [1..d] do
        if not IsOneWordIter(ProjectWord(v,j,G)) then return false; fi;
      od;
      return true;
    fi;
  end;

  d:=Length(G[1])-1;
  if Length(w)=0 then return true; fi;
  ReachedWords:=[];
  return IsOneWordIter(w);
end);


################################################################################
##
#F IsOneWordContr. . . . . . . . . . . . . . . . . checks if the word is trivial
##                                                          in contracting group

InstallGlobalFunction(IsOneWordContr,function(word,G)
  local IsOneWordContrLocal;

  IsOneWordContrLocal:=function(word)
    local i,b,l,v,c,k,res,t,w;
    w:=ShallowCopy(word);
    if Length(w)=0 then return true; fi;
    if Length(w)=1 then
      if w=[1] then return true;
               else return false;
      fi;
    fi;
    if Length(w) mod 2=1 then Add(w,1); fi;
    l:=[];
    for i in [1..Length(w)/2] do
      Add(l,StructuralCopy(G[w[2*i-1]][w[2*i]]));
    od;
  #  Print("l=",l);
  # list c contains permutations c[i+1]=pi[1]*pi[2]*...*pi[i]
    c:=[(),l[1][Length(l[1])]];
    t:=Length(l);
    for i in [2..t] do
  #    Print("c[",i,"]=",c[i],",l[",i,"]=",l[i][Length(l[i])],";");
      Add(c,c[i]*l[i][Length(l[i])]);
      l[i][Length(l[i])]:=c[i];
    od;
    if c[Length(c)]<>() then
      return false;
    fi;
    l[1][Length(l[1])]:=();
    b:=[];
    for i in [1..Length(l)] do
      b[i]:=l[i]^((l[i][Length(l[i])])^(-1));
    od;
    i:=1;
    res:=true;
    while res and (i<=Length(b[1])-1) do
      v:=[];
      for k in [1..Length(b)] do
        Add(v,b[k][i]);
      od;
      v:=ReduceWord(v);
      res:=IsOneWordContrLocal(v);
      i:=i+1;
    od;
    return res;
  end;

  return IsOneWordContrLocal(word);
end);


################################################################################
##
#F IS_ONE_LIST. . . . . . . . . . . . . . . . . . . .checks if the word is trivial
##                     in any self-similar group (chooses appropriate algorithm)

InstallGlobalFunction(IS_ONE_LIST,function(w,G)
  if IsList(G[1][1]) then return IsOneWordContr(w,G);
                     else return IsOneWordSelfSim(w,G);
  fi;
end);


################################################################################
##
#M  MINIMIZED_AUTOMATON_LIST                 AddInversesTrack(AutomatonList(H));
##

InstallMethod(MINIMIZED_AUTOMATON_LIST, "MINIMIZED_AUTOMATON_LIST(IsAutomGroup)", [IsAutomGroup],
function(H)
  return AddInversesTrack(AutomatonList(H));
end);


################################################################################
##
#F CONVERT_ASSOCW_TO_LIST. . . . . . .Converts elements of AutomGroup into lists
##
InstallGlobalFunction(CONVERT_ASSOCW_TO_LIST,function(w)
  local w_list, w_ext, i, j, numstates, cur_gen;
  numstates:=FamilyObj(w)!.numstates;
  w_list:=[];
  w_ext:=ExtRepOfObj(w!.word);
  for i in [1..Length(w_ext)/2] do
    if w_ext[2*i]>0 then
      cur_gen:=w_ext[2*i-1];
    else
      cur_gen:=w_ext[2*i-1]+numstates;
    fi;
    for j in [1..AbsInt(w_ext[2*i])] do Add(w_list,cur_gen); od;
  od;
  return w_list;
end);


###############################################################################
##
#M  IsOneContr(a)      for contracting groups
##
InstallGlobalFunction(IsOneContr,
function(a)
  local a_list, a_list_orig, track_l, Gi, i;

  a_list_orig:=CONVERT_ASSOCW_TO_LIST(a);


  Gi:=MINIMIZED_AUTOMATON_LIST(GroupOfAutomFamily(FamilyObj(a)));
  track_l:=Gi[3];

  #a_list:=[];
  #for i in [1..Length(a_list_orig)] do Add(a_list,track_l[a_list_orig[i]]); od;

  a_list:=List(a_list_orig, i->track_l[i]);

  return IsOneWordContr(a_list,_ContractingTable(GroupOfAutomFamily(FamilyObj(a))));
end);


###############################################################################
##
#M  IS_ONE_LIST(w,G)      (IsList, IsAutomGroup)
##
#InstallGlobalFunction(IS_ONE_LIST,
#function(w,G)
#  if HasIsContracting(G) and IsContracting(G) and UseContraction(G) then
#    return IsOneWordContr(w,_ContractingTable(G));
#  else
#    return IsOneWordSelfSim(w,MINIMIZED_AUTOMATON_LIST(G)[1]);
#  fi;
#end);



###############################################################################
##
#M  CHOOSE_AUTOMATON_LIST(G)      [IsAutomGroup]
##
InstallGlobalFunction(CHOOSE_AUTOMATON_LIST,
function(G)
  if HasIsContracting(G) and IsContracting(G) and UseContraction(G) then
    return _ContractingTable(G);
  else
    return MINIMIZED_AUTOMATON_LIST(G)[1];
  fi;
end);



################################################################################
##
#F PowerOfWord. . . . . . . . . . . . . . . . . . Construct n-th power of a given word
##                                                It is NOT sophisticated at all

InstallGlobalFunction(PowerOfWord,function(v,n)
  local w,k;
  v:=ReduceWord(v);
  w:=StructuralCopy(v); k:=1;
  for k in [1..n-1] do Append(w,v); od;
  return w;
end);



################################################################################
##
#M ORDER_OF_ELEMENT. . . . . . . Tries to find the order of a periodic element
##                                                       Checks up to order size

InstallMethod(ORDER_OF_ELEMENT, "ORDER_OF_ELEMENT(IsList, IsList, IsCyclotomic)", true,
              [IsList, IsList, IsCyclotomic],
function(v,G,size)
  local w,k;
  v:=ReduceWord(v);
  w:=StructuralCopy(v); k:=1;
  if Length(G[1])=3 then
    while (not IS_ONE_LIST(w,G)) and k<size do
      Append(w,w);
#     Print(w,";");
      k:=2*k;
    od;
  else
    while (not IS_ONE_LIST(w,G)) and k<size do
      Append(w,v);
#     Print(w,";");
      k:=k+1;
    od;
  fi;
  if IS_ONE_LIST(w,G) then return k; else return fail; fi;
end);


################################################################################
##
#M ORDER_OF_ELEMENT. . . . . . . . . . . . . . . . . .Finds the order of a periodic element
##
InstallMethod(ORDER_OF_ELEMENT, "OrderOfElementMain(IsList, IsList, IsPosInt)",
              [IsList, IsList],
function(v,G)
  return ORDER_OF_ELEMENT(v,G,infinity);
end);


################################################################################
##
#F GeneratorActionOnVertex. . . . . . . . . . . . . . . . Computes the action of
##                                             the generator on the fixed vertex
InstallGlobalFunction(GeneratorActionOnVertex,function(G,g,w)
  local i,v,gen,d;
  d:=Length(G[1])-1;
  gen:=g; v:=[];
  for i in [1..Length(w)] do
    Add(v,(w[i]+1)^G[gen][d+1]-1);
    gen:=G[gen][w[i]+1];
  od;
  return v;
end);



################################################################################
##
#F _NumberOfVertex. . . . . . . . . . . . . . .Computes the number (1..d^Length(w))
##                                           of a given vertex w of a d-ary tree. Alphabet [0..d-1]

InstallGlobalFunction(_NumberOfVertex,function(w,d)
  local i,s;
  s:=0;
  for i in [1..Length(w)] do
    s:=s+w[i]*d^(Length(w)-i);
  od;
  return s;
end);

##  <#GAPDoc Label="NumberOfVertex">
##  <Func Arg="ver, deg" Name="NumberOfVertex" />
##  <Description>
##  Let <A>ver</A> belong to <M>n</M>-th level of the <A>deg</A>-ary tree. One can
##  naturally enumerate all the vertices of this level by numbers <M>1,\ldots,\rm{deg}^n</M>.
##  This function returns the number, which corresponds to the vertex <A>ver</A>.
##  <Example>
##  gap> NumberOfVertex([1,2,1,2],2);
##  6
##  gap> NumberOfVertex("333",3);
##  27
##  </Example>
##  </Description>
##  <#/GAPDoc>
##

######################################################################################
##
#F  NumberOfVertex (<ver>, <deg>)
##
##  Let <ver> belong to $n$-th level of the <deg>-ary tree. One can
##  naturally enumerate all the vertices of this level by numbers $1,\ldots,<deg>^{<n>}$.
##  This function returns the number, which corresponds to the vertex <ver>.
##  \beginexample
##  gap> NumberOfVertex([1,2,1,2],2);
##  6
##  gap> NumberOfVertex("333",3);
##  27
##  \endexample
##
InstallGlobalFunction(NumberOfVertex,function(w,d)
  local i,s,w_loc;
  s:=0;
  if IsString(w) then
    w_loc:=List(w,x->Int(String([x]))-1);
  else
    w_loc:=List(w,x->x-1);
  fi;
  for i in w_loc do
    if i<0 or i>=d then
      Error("received string ", w, " does not represent a valid vertex");
    fi;
  od;
  for i in [1..Length(w)] do
    s:=s+w_loc[i]*d^(Length(w)-i);
  od;
  return s+1;
end);

################################################################################
##
#F _VertexNumber. . . . . . . . . . . . . Constructs the vertex on the n-th level
##                                               of the d-ary tree with number k. Alphabet [0..d-1]

InstallGlobalFunction(_VertexNumber,function(k,n,d)
  local i,l,l1,t;
  t:=k; l:=[];
  while t>0 do
    Add(l,t mod d);
    t:=(t-(t mod d))/d;
  od;
  for i in [Length(l)+1..n] do Add(l,0); od;
  l1:=[];
  for i in [1..n] do l1[i]:=l[n-i+1]; od;
  return l1;
end);



##  <#GAPDoc Label="VertexNumber">
##  <Func Arg="num, lev, deg" Name="VertexNumber" />
##  <Description>
##  One can naturally enumerate all the vertices of the <A>lev</A>-th level of
##  the <A>deg</A>-ary tree by numbers <M>1,\ldots,\rm{deg}^n</M>.
##  This function returns the vertex of this level, which has number <A>num</A>.
##  <Example>
##  gap> VertexNumber(1,3,2);
##  [ 1, 1, 1 ]
##  gap> VertexNumber(4,4,3);
##  [ 1, 1, 2, 1 ]
##  </Example>
##  </Description>
##  <#/GAPDoc>
##

######################################################################################
##
#F  VertexNumber (<num>, <lev>, <deg>)
##
##  One can naturally enumerate all the vertices of the <A>lev</A>-th level of
##  the <deg>-ary tree by numbers $1,\ldots,<deg>^{<n>}$.
##  This function returns the vertex of this level, which has number <num>.
##  \beginexample
##  gap> VertexNumber(1,3,2);
##  [ 1, 1, 1 ]
##  gap> VertexNumber(4,4,3);
##  [ 1, 1, 2, 1 ]
##  \endexample
##
InstallGlobalFunction(VertexNumber,function(k,n,d)
  local i,l,l1,t;
  t:=k-1; l:=[];
  while t>0 do
    Add(l,t mod d);
    t:=(t-(t mod d))/d;
  od;
  for i in [Length(l)+1..n] do Add(l,0); od;
  l1:=[];
  for i in [1..n] do l1[i]:=l[n-i+1]; od;
  return List(l1,x->x+1);
end);


################################################################################
##
#F GeneratorActionOnLevel . . . . . . . . . . . . . . . . Computes the action of
##                                               the generator on the n-th level

InstallGlobalFunction(GeneratorActionOnLevel,function(G,g,n)
  local l,d,i,s,v,w,k;
  s:=(); d:=Length(G[1])-1;
  l:=[];
  for i in [1..d^n] do Add(l,0); od;
  i:=0;
  while i<d^n do
    k:=0;
    while l[k+1]>0 do
      k:=k+1;
    od;
    w:=_VertexNumber(k,n,d);
    v:=StructuralCopy(w);
    i:=i+1;
    repeat
      l[_NumberOfVertex(v,d)+1]:=1;
      v:=GeneratorActionOnVertex(G,g,v);
      if v<>w then
        s:=s*(k+1,_NumberOfVertex(v,d)+1);
        i:=i+1;
      fi;
    until v=w;
  od;
  return s;
end);





##  <#GAPDoc Label="PermActionOnLevel">
##  <ManSection >
##  <Func Arg="perm, big_lev, sm_lev, deg" Name="PermActionOnLevel" />
##  <Description>
##  Given a permutation <A>perm</A> on the <A>big_lev</A>-th level of the tree of degree
##  <A>deg</A> returns the permutation induced by <A>perm</A> on a smaller level
##  <A>sm_lev</A>.
##  <Example>
##  gap> PermActionOnLevel((1,4,2,3),2,1,2);
##  (1,2)
##  gap> PermActionOnLevel(1,13,5,9,3,15,7,11)(2,14,6,10,4,16,8,12),4,2,2);
##  (1,4,2,3)
##  </Example>
##  </Description>
##  </ManSection>
##  <#/GAPDoc>
##

######################################################################################
##
#F  PermActionOnLevel (<perm>, <big_lev>, <sm_lev>, <deg>)
##
##  Given a permutation <perm> on the <big_lev>-th level of the tree of degree
##  <deg> returns the permutation induced by <perm> on a smaller level
##  <sm_lev>.
##  \beginexample
##  gap> PermActionOnLevel((1,4,2,3),2,1,2);
##  (1,2)
##  gap> PermActionOnLevel(1,13,5,9,3,15,7,11)(2,14,6,10,4,16,8,12),4,2,2);
##  (1,4,2,3)
##  \endexample
##
InstallGlobalFunction(PermActionOnLevel,function(perm,big_lev,sm_lev,deg)
  local l,i;
  l:=[];
  for i in [0..deg^sm_lev-1] do
    Add(l,Int(((1+i*deg^(big_lev-sm_lev))^perm-1)/(deg^(big_lev-sm_lev)))+1);
  od;
  return PermList(l);
end);



################################################################################
##
#F WordActionOnLevel . . . . . . . . . . . . . . . . . . .Computes the action of
##                                              the given word on the n-th level

InstallGlobalFunction(WordActionOnLevel,function(G,w,n)
  local gen,perm;
  perm:=();
  for gen in w do
    perm:=perm*GeneratorActionOnLevel(G,gen,n);
  od;
  return perm;
end);


################################################################################
##
#F _IsWordTransitiveOnLevel. . . . . . . . . .Returns true if element w of G acts
##                                 transitively on level lev and false otherwise

InstallGlobalFunction(_IsWordTransitiveOnLevel,function(G,w,lev)
  return Length(OrbitPerms([WordActionOnLevel(G,w,lev)],1))=(Length(G[1])-1)^lev;
end);


################################################################################
##
#F _GeneratorActionOnLevelAsMatrix. . . . . . . . . . . . . Computes the action of
##                       the generator on the n-th level as permutational matrix

InstallGlobalFunction(_GeneratorActionOnLevelAsMatrix,function(G,g,n)
  local perm,i,j,m,d;
  perm:=GeneratorActionOnLevel(G,g,n);
  d:=Length(G[1])-1;
  m:=List([1..d^n],x->List([1..d^n],x->0));
  for i in [1..d^n] do
    m[i][i^perm]:=1;
  od;
  return m;
end);


InstallGlobalFunction(PermOnLevelAsMatrix,function(g,lev)
  local perm,i,j,m,d;
  perm:=PermOnLevel(g,lev);
  d:=g!.deg;
  m:=List([1..d^lev],x->List([1..d^lev],x->0));
  for i in [1..d^lev] do
    m[i][i^perm]:=1;
  od;
  return m;
end);



################################################################################
##
#F InvestigatePairs . . . . . . . . . . . . . . . . . . . Searches out relations
##                                               in the recurent group like ab=c

InstallGlobalFunction(InvestigatePairs,function(G)
  local i,j,k,i1,j1,k1,Pairs,Trip,n,IsPairEq,d,res,tmp;

  IsPairEq:=function(i,j,k)   # ij=k?
    local t,res;
    if (not IsList(Pairs[i][j])) or (IsList(Pairs[i][j])
                                     and (Pairs[i][j][1]<>k)) then
      if (not IsList(Pairs[i][j])) and (Pairs[i][j]<>-1) then
        if Pairs[i][j]=k then return true;
                         else return false;
        fi;
      fi;
      if IsList(Pairs[i][j]) then
        if Length(Pairs[i][j])=1 then
          Trip[i][j][Pairs[i][j][1]]:=0;
        else
          Trip[i1][j1][k1]:=0;
          return true;
        fi;
      fi;
      if Trip[i][j][k]=0 then return false;
      else
        if G[i][d+1]*G[j][d+1]<>G[k][d+1] then
          Trip[i][j][k]:=0;
          return false;
        fi;
        Pairs[i][j]:=[k];
        t:=1; res:=true;
        while res and (t<=d) do
#          Print("i=",i,",j=",j,",k=",k,",t=",t,";   ");
          res:=IsPairEq(G[i][t],G[j][t^G[i][d+1]],G[k][t]);
          t:=t+1;
        od;
        if res then
          if Trip[i][j][k]<>0 then
            Pairs[i][j]:=[k,1];
            return true;
          else
            Pairs[i][j]:=-1;
            return false;
          fi;
        else
          Trip[i][j][k]:=0;
          Pairs[i][j]:=-1;
          return false;
        fi;
      fi;
    else
      return true;
    fi;
  end;

  Pairs:=[[]]; Trip:=[];
  n:=Length(G);
  d:=Length(G[1])-1;
  for j in [1..n] do Add(Pairs[1],j); od;
  for i in [2..n] do
    Add(Pairs,[i]);
    Trip[i]:=[];
    for j in [2..n] do
      Pairs[i][j]:=-1;
      Trip[i][j]:=[];
      for k in [1..n] do Trip[i][j][k]:=-1; od;
    od;
  od;
#  Print(Pairs);
#  Print(Trip);
  for i1 in [2..n] do for j1 in [2..n] do
    if Pairs[i1][j1]=-1 then
      k1:=1; res:=false;
      while (not res) and (k1<=n) do
        res:=IsPairEq(i1,j1,k1);
#        Print(Pairs,"\n");
        for i in [2..n] do for j in [2..n] do
          if IsList(Pairs[i][j]) then
            if res then Pairs[i][j]:=Pairs[i][j][1];
                   else Pairs[i][j]:=-1;
            fi;
          fi;
        od; od;
        k1:=k1+1;
      od;
      if Pairs[i1][j1]=-1 then Pairs[i1][j1]:=0; fi;
    fi;
  od; od;
  return Pairs;
end);



##  <#GAPDoc Label="ContractingLevel">
##  <ManSection >
##  <Attr Arg="G" Name="ContractingLevel" />
##  <Description>
##  Given a contracting group <A>G</A> with nucleus <M>\mathcal N</M>, stored in
##  <C>AutomNucleus(G)</C> <Ref Func="OrbitOfVertex"/> computes the
##  minimal level <M>n</M>, such that for every vertex <M>v</M> of the <M>n</M>-th
##  level and all <M>g,h\in\mathcal N</M> the section <M>gh|_v\in\mathcal N</M>.<P/>
##
##  In case it is not known whether <A>G</A> is contracting it first tries to compute
##  the nucleus. If <G> is happened to be noncontracting, it will loop forever. One can
##  also use <C>IsNoncontracting</C> <Ref Func="IsNoncontracting"/> or <C>FindNucleus</C>
##  <Ref Func="FindNucleus"/> directly.
##  <Example>
##  gap> ContractingLevel(GrigorchukGroup);
##  1
##  gap> ContractingLevel(Basilica);
##  2
##  </Example>
##  </Description>
##  </ManSection>
##  <#/GAPDoc>
##


######################################################################################
##
#A  ContractingLevel (<G>)
##
##  Given a contracting group <G> with nucleus $\mathcal N$, stored in
##  'NucleusIncludingGeneratingSet(<G>)' (see "NucleusIncludingGeneratingSet") computes the
##  minimal level $n$, such that for every vertex $v$ of the $n$-th
##  level and all $g,h\in\mathcal N$ the section $gh|_v\in\mathcal N$.<P/>
##
##  In case if it is not known whether <G> is contracting it first tries to compute
##  the nucleus. If <G> is happened to be noncontracting, it will loop forever. One can
##  also use "IsNoncontracting" or "FindNucleus" directly.
##  \beginexample
##  gap> ContractingLevel(GrigorchukGroup);
##  1
##  gap> ContractingLevel(Basilica);
##  2
##  \endexample
##
InstallMethod(ContractingLevel, "ContractingLevel(IsAutomGroup)", [IsAutomGroup],
function(H)
  local ContractingLevelLocal;

  ContractingLevelLocal:=function(G)
    local i,j,res,ContPairs,d,maxlev,n,Pairs,DoesPairContract;
    DoesPairContract:=function(i,j,lev)
      local t,res,localmaxlev;
      if lev>maxlev then maxlev:=lev; fi;
      if IsList(ContPairs[i][j]) then
        if lev+ContPairs[i][j][1]>maxlev then maxlev:=lev+ContPairs[i][j][1]; fi;
        return true;
      fi;
      if Pairs[i][j]<>0 then
        ContPairs[i][j]:=[0];
        return true;
      fi;
      if ContPairs[i][j]=2 then return false; fi;
      t:=1; res:=true;
      ContPairs[i][j]:=2;
      localmaxlev:=0;
      while res and (t<=d) do
        res:=DoesPairContract(G[i][t],G[j][t^G[i][d+1]],lev+1);
        if res then
          if ContPairs[G[i][t]][G[j][t^G[i][d+1]]][1]+1>localmaxlev then
            localmaxlev:=ContPairs[G[i][t]][G[j][t^G[i][d+1]]][1]+1;
          fi;
        fi;
        t:=t+1;
      od;
      if res then
               ContPairs[i][j]:=[localmaxlev];
               return true;
             else return false;
      fi;
    end;

    res:=true; maxlev:=0; ContPairs:=[];
    Pairs:=InvestigatePairs(G);
    n:=Length(G);
    for i in [1..n] do
      Add(ContPairs,[[0]]);
      for j in [1..n-1] do
        if i=1 then Add(ContPairs[i],[0]);
               else Add(ContPairs[i],-1);
        fi;
      od;
    od;
    #Print(ContPairs,"\n");
    i:=1;
    d:=Length(G[1])-1;
    while res and (i<=n) do
      j:=1;
      while res and (j<=n) do
        if ContPairs[i][j]=0 then return -1; fi;
        if ContPairs[i][j]=-1 then res:=DoesPairContract(i,j,0); fi;
        j:=j+1;
      od;
      i:=i+1;
    od;
    #Print(ContPairs);
    if res then return maxlev;
           else return -1;
    fi;
  end;
################ ContractingLevel itself #################################

  if not HasIsContracting(H) then
    Info(InfoWarning, 1, "If <H> is not contracting, the algorithm will never stop");
  fi;
  return ContractingLevelLocal(NucleusIncludingGeneratingSetAutom(H));
end);




################################################################################
##
#M _ContractingTable . . . . . . . . . . . . . . . . . . Computes the contracting
##                                                           table of the kernel
InstallMethod(_ContractingTable, "_ContractingTable(IsAutomGroup)", [IsAutomGroup],
function(H)
  local _ContractingTableLocal;
  _ContractingTableLocal:=function(G)
    local lev,n,d,i,j, ContractingPair, Pairs, ContTable;
    ContractingPair:=function(i,j)
      local l,k,t, PairAct, TmpList, g1, g2;
      if Pairs[i][j]<>0 then PairAct:=[Pairs[i][j]];
                        else PairAct:=[[i,j]];
      fi;
      for l in [1..lev] do
        TmpList:=[];
        for t in [1..Length(PairAct)] do
          if not IsList(PairAct[t]) then
            for k in [1..d] do Add(TmpList,G[PairAct[t]][k]); od;
          else
            for k in [1..d] do
              g1:=G[PairAct[t][1]][k];
              g2:=G[PairAct[t][2]][k^G[PairAct[t][1]][d+1]];
              if Pairs[g1][g2]<>0 then Add(TmpList,Pairs[g1][g2]);
                                  else Add(TmpList,[g1,g2]);
              fi;
            od;
          fi;
        od;
        PairAct:=StructuralCopy(TmpList);
      od;
      Add(PairAct,GeneratorActionOnLevel(G,i,lev)*GeneratorActionOnLevel(G,j,lev));
      return PairAct;
    end;

    lev:=ContractingLevel(H);
    Pairs:=InvestigatePairs(G);
    n:=Length(G);
    d:=Length(G[1])-1;
    ContTable:=[];
    for i in [1..n] do
      Add(ContTable,[]);
      for j in [1..n] do Add(ContTable[i],ContractingPair(i,j)); od;
    od;
    return ContTable;
  end;
################ _ContractingTable itself #################################

  if not HasIsContracting(H) then
    Info(InfoWarning, 1, "If <H> is not contracting, the algorithm will never stop");
  fi;
  return _ContractingTableLocal(NucleusIncludingGeneratingSetAutom(H));
end);


################################################################################
##
#A  ContractingTable (<G>)
##
##  Given a contracting group <G> with nucleus 'N' of size $k$, stored in
##  'NucleusIncludingGeneratingSet(<G>)' (see "NucleusIncludingGeneratingSet") computes the
##  $k\times k$ table, whose '[i][j]'-th entry contains decomposition of 'N[i]*N[j]' on
##  the 'ContractingLevel(<G>)' level. By construction the sections of 'N[i]*N[j]' on this level
##  belong to 'N'. This table is used in the algorithm solving the word problem in polynomial
##  time.
##
##  In case if it is not known whether <G> is contracting it first tries to compute
##  the nucleus. If <G> is happened to be noncontracting, it will loop forever. One can
##  also use "IsNoncontracting" or "FindNucleus" directly.
##  \beginexample
##  gap> ContractingTable(GrigorchukGroup);
##  [ [ [ e, e, () ], [ e, e, (1,2) ], [ a, c, () ], [ a, d, () ], [ e, b, () ] ],
##    [ [ e, e, (1,2) ], [ e, e, () ], [ c, a, (1,2) ], [ d, a, (1,2) ], [ b, e, (1,2) ] ],
##    [ [ a, c, () ], [ a, c, (1,2) ], [ e, e, () ], [ e, b, () ], [ a, d, () ] ],
##    [ [ a, d, () ], [ a, d, (1,2) ], [ e, b, () ], [ e, e, () ], [ a, c, () ] ],
##    [ [ e, b, () ], [ e, b, (1,2) ], [ a, d, () ], [ a, c, () ], [ e, e, () ] ] ]
##  \endexample
##
InstallMethod(ContractingTable, "ContractingTable(IsAutomGroup)", [IsAutomGroup],
function(H)
  local T,i,j,k;
  T:=StructuralCopy(_ContractingTable(H));
  for i in [1..Length(T)] do
    for j in [1..Length(T[1])] do
      for k in [1..Length(T[1][1])-1] do
        T[i][j][k]:=NucleusIncludingGeneratingSet(H)[T[i][j][k]];
      od;
    od;
  od;
  return T;
end);

################################################################################
##
#F MinimizeAutom . . . . . . . . . . . . . . . . . . .Glues equivalent states of
##                                                          noninitial automaton

InstallGlobalFunction(MinimizeAutom,function(G)

  local AreEqualStates,i,j,Pairs,n, tmpG,d,k,l,st;

  AreEqualStates:=function(st1,st2)
    local eq,i;
    if st1=st2 or ([st1,st2] in Pairs) or ([st2,st1] in Pairs) then return true; fi;
    if G[st1][d+1]<>G[st2][d+1] then return false; fi;
    Add(Pairs, [st1,st2]);
    eq:=true;
    for i in [1..d] do
      if not AreEqualStates(G[st1][i],G[st2][i]) then eq:=false; break; fi;
    od;
    return eq;
  end;

  n:=Length(G);
  d:=Length(G[1])-1;
  for i in [1..n-1] do
    for j in [i+1..n] do
      Pairs:=[];
      if AreEqualStates(i,j) then
        tmpG:=[];  #can be maid better by gluing all pairs from Pairs.
        for k in [1..n] do
          if k<>j then
            st:=StructuralCopy(G[k]);
            for l in [1..d] do
              if st[l]=j then st[l]:=i;
              elif st[l]>j then st[l]:=st[l]-1;
              fi;
            od;
            Add(tmpG,st);
          fi;
        od;
        return MinimizeAutom(tmpG);
      fi;
    od;
  od;
  return G;
end);

################################################################################
##
#F MinimizeAutomTrack  . . . . . . . . . . . . . . . .Glues equivalent states of
##   noninitial automaton and returns correspondence between old and new numbers
##  track_list_short - new generators in terms of old ones
##  track_list_long  - old generators in terms of new ones

InstallGlobalFunction(MinimizeAutomTrack,function(G,track_list_short,track_list_long)

  local AreEqualStates,i,j,Pairs,n, tmpG,d,k,l,st, track_s, track_l;

  AreEqualStates:=function(st1,st2)
    local eq,i;
    if st1=st2 or ([st1,st2] in Pairs) or ([st2,st1] in Pairs) then return true; fi;
    if G[st1][d+1]<>G[st2][d+1] then return false; fi;
    Add(Pairs, [st1,st2]);
    eq:=true;
    for i in [1..d] do
      if not AreEqualStates(G[st1][i],G[st2][i]) then eq:=false; break; fi;
    od;
    return eq;
  end;


  if Length(track_list_short)<>Length(G) then
    Error("length of track_list_short is wrong\n");
  fi;

  n:=Length(G);
  d:=Length(G[1])-1;
  track_s:=StructuralCopy(track_list_short);
  track_l:=StructuralCopy(track_list_long);
  for i in [1..n-1] do
    for j in [i+1..n] do
      Pairs:=[];
      if AreEqualStates(i,j) then
        tmpG:=[];  #can be maid better by gluing all pairs from Pairs.
        for k in [1..n] do
          if k<>j then
            st:=StructuralCopy(G[k]);
            for l in [1..d] do
              if st[l]=j then st[l]:=i;
              elif st[l]>j then st[l]:=st[l]-1;
              fi;
            od;
            Add(tmpG,st);
          fi;
        od;
        track_s:=[];
        for k in [1..Length(track_list_short)] do
          if k<j then track_s[k]:=StructuralCopy(track_list_short[k]);
            elif k>j then track_s[k-1]:=StructuralCopy(track_list_short[k]);
          fi;
        od;
        for k in [1..Length(track_list_long)] do
          if track_l[k]>j then track_l[k]:=track_l[k]-1;
            elif track_l[k]=j then track_l[k]:=i;
          fi;
        od;
        return MinimizeAutomTrack(tmpG,track_s,track_l);
      fi;
    od;
  od;
  return [G,track_s,track_l];
end);


################################################################################
##
#F AddInverses. . . . . . . . . . Adds to the generating set of the self-similar
##                               group inverse elements and the identity element

InstallGlobalFunction(AddInverses,function(H)
  local d,n,G,idEl,st,i,perm,inv;

  d:=Length(H[1])-1;
  n:=Length(H);
  if n<1 or d<1 then return fail; fi;
  idEl:=[];
  for i in [1..d] do Add(idEl,1); od;
  Add(idEl,());
  G:=[idEl];
  for i in [1..n] do Add(G,StructuralCopy(H[i])); od;

  for st in [2..n+1] do
    for i in [1..d] do G[st][i]:=G[st][i]+1; od;
  od;

  for st in [2..n+1] do
    inv:=[];
    perm:=G[st][d+1]^(-1);
    for i in [1..d] do Add(inv, G[st][i^perm]+n); od;
    Add(inv,perm);
    Add(G,inv);
  od;

  return MinimizeAutom(G);
end);



################################################################################
##
#F AddInversesTrack. . . . . . . .Adds to the generating set of the self-similar
##                               group inverse elements and the identity element

InstallGlobalFunction(AddInversesTrack,function(H)
  local d,n,G,idEl,st,i,perm,inv, track_s, track_l;

##  track_s - new generators in terms of old ones
##  track_l - old generators in terms of new ones

  d:=Length(H[1])-1;
  n:=Length(H);
  if n<1 or d<1 then return fail; fi;
  idEl:=[];
  for i in [1..d] do Add(idEl,1); od;
  Add(idEl,());
  G:=[idEl];
  for i in [1..n] do Add(G,StructuralCopy(H[i])); od;

  for st in [2..n+1] do
    for i in [1..d] do G[st][i]:=G[st][i]+1; od;
  od;

  for st in [2..n+1] do
    inv:=[];
    perm:=G[st][d+1]^(-1);
    for i in [1..d] do Add(inv, G[st][i^perm]+n); od;
    Add(inv,perm);
    Add(G,inv);
  od;
#  Print("G=",G,"\n");
  track_s:=[0];
  Append(track_s,[1..Length(G)-1]);
  return MinimizeAutomTrack(G,track_s,[2..Length(G)]);
end);



##  <#GAPDoc Label="UseContracion">
##  <ManSection >
##  <Attr Arg="G" Name="UseContracion" />
##  <Description>
##  For a contracting automaton group <A>G</A> determines whether to use the algorithm of polynomial
##  complexity solving the word problem in the group. By default it is set to <C>true</C>
##  soon as the nucleus of the group was computed. Sometimes when the nucleus is very big, the
##  standard algorithm of exponential complexity is faster for short words, but this heavily
##  depends on the group. Therefore the decision on which algorithm to use is left to the user.
##  To use the exponential algorithm one can change the value of <C>UseContraction(G)</C> by
##  <C>SetUseContraction(G,false)</C>.
##
##  Below we provide an example which shows that both methods can be of use.
##  <Example>
##  gap> G:=AutomGroup("a=(b,b)(1,2),b=(c,a),c=(a,a)");;
##  gap> IsContracting(G);
##  true
##  gap> Length(AutomNucleus(G));
##  41
##  gap> Order(a); Order(b); Order(c);
##  2
##  2
##  2
##  gap> SetUseContraction(G,true);
##  gap> H:=Group(a*b,b*c);;
##  gap> St2:=StabilizerOfLevel(H,2);time;
##  < a*b*c^-1*b^-1*c^-1*b^-2*a^-1, c^-1*b^-1*c^-1*b^-1, b^-1*a^-1*b^-1*a^-1*b^-1*a^-1*b^-1*a^-1,
##  b*c*a*b*c^-1*b^-1*a*b, a*b^2*c*b^-1*a^-1*c^-1*b^-2*a^-1*b^-1*a^-1,
##  b*c*b^-1*a^-1*c^-1*b^-2*a^-1 >
##  15723
##  gap> IsAbelian(St2);time;
##  true
##  7832
##  gap> SetUseContraction(G,false);
##  gap> H:=Group(a*b,b*c);
##  gap> St2:=StabilizerOfLevel(H,2);;time;
##  8692
##  gap> IsAbelian(St2);time;
##  true
##  216551
##  </Example>
##  Here we show that the group <C>G</C> is virtually abelian. First we check that the group
##  is contracting. Then we see that the size of the nucleus is 41. Since all of generators have
##  order 2, the subgroup <M>H=\langle ab,bc\rangle</M> has index 2 in <M>G</M>. Now we compute
##  the stabilizer of the second level in <M>H</M> and verify, that it is abelian by 2 methods:
##  with and without using the contraction. We see, that the time required to compute the stabilizer
##  is approximately the same in both methods, while verification of commutativity works much faster
##  with contraction.
##  </Description>
##  </ManSection>
##  <#/GAPDoc>
##


################################################################################
##
#A UseContraction (<G>)
##
##  For a contracting automaton group <G> determines whether to use the algorithm of polynomial
##  complexity solving the word problem in the group. By default it is set to 'true'
##  soon as the nucleus of the group was computed. Sometimes when the nucleus is very big, the
##  standard algorithm of exponential complexity is faster for short words, but this heavily
##  depends on the group. Therefore the decision on which algorithm to use is left to the user.
##  To use the exponential algorithm one can change the value of 'UseContraction(G)' by
##  'SetUseContraction(G,false)'.
##
##  Below we provide an example which shows that both methods can be of use.
##  \beginexample
##  gap> G:=AutomGroup("a=(b,b)(1,2),b=(c,a),c=(a,a)");;
##  gap> IsContracting(G);
##  true
##  gap> Length(AutomNucleus(G));
##  41
##  gap> Order(a); Order(b); Order(c);
##  2
##  2
##  2
##  gap> SetUseContraction(G,true);
##  gap> H:=Group(a*b,b*c);;
##  gap> St2:=StabilizerOfLevel(H,2);time;
##  < a*b*c^-1*b^-1*c^-1*b^-2*a^-1, c^-1*b^-1*c^-1*b^-1, b^-1*a^-1*b^-1*a^-1*b^-1*a^-1*b^-1*a^-1,
##  b*c*a*b*c^-1*b^-1*a*b, a*b^2*c*b^-1*a^-1*c^-1*b^-2*a^-1*b^-1*a^-1,
##  b*c*b^-1*a^-1*c^-1*b^-2*a^-1 >
##  15723
##  gap> IsAbelian(St2);time;
##  true
##  7832
##  gap> SetUseContraction(G,false);
##  gap> H:=Group(a*b,b*c);
##  gap> St2:=StabilizerOfLevel(H,2);;time;
##  8692
##  gap> IsAbelian(St2);time;
##  true
##  216551
##  </Example>
##  Here we show that the group <G> is virtually abelian. First we check that the group
##  is contracting. Then we see that the size of the nucleus is 41. Since all of generators have
##  order 2, the subgroup $H=\langle ab,bc\rangle$ has index 2 in <G>. Now we compute
##  the stabilizer of the second level in $H$ and verify, that it is abelian by 2 methods:
##  with and without using the contraction. We see, that the time required to compute the stabilizer
##  is approximately the same in both methods, while verification of commutativity works much faster
##  with contraction.
##
InstallMethod(UseContraction, "UseContraction(IsTreeAutomorphismGroup)", true,
              [IsTreeAutomorphismGroup],
function(G)
  if HasAutomNucleus(G) then
    return true;
  else return false;
  fi;
end);



################################################################################
##
#M INFO_FLAG . . . . . . . . . .internal use only
##
InstallMethod(INFO_FLAG, "INFO_FLAG(IsTreeAutomorphismGroup)", true,
              [IsTreeAutomorphismGroup], function(G) return 0; end);



################################################################################
##
#O  FindNucleus (<G>)
#O  FindNucleus (<G>, <max_nucl>)
##
##  Given a self-similar group <G> it tries to find its nucleus. If the group is not contracting
##  it will loop forever (modulo memory constraints, of course). When it finds the nucleus
##  it returns the triple
##  '["NucleusIncludingGeneratingSet"(<G>), "AutomNucleus"(<G>), "NucleusIncludingGeneratingSetAutom"(<G>)]'
##
##  If <max_nucl> is given stops after finding <max_nucl> elements that need to be in
##  the nucleus and returns 'fail' if the nucleus was not found.
##
##  Use '"IsNoncontracting"' to try to show that <G> is noncontracting.
##
##  \beginexample
##  gap> FindNucleus(Basilica);
##  [ [ e, u, v, u^-1, v^-1, u^-1*v, v^-1*u ], [ e, u, v, u^-1, v^-1, u^-1*v, v^-1*u ],
##    [ [ 1, 1, () ], [ 3, 1, (1,2) ], [ 2, 1, () ], [ 1, 5, (1,2) ], [ 4, 1, () ], [ 1, 7, (1,2) ],
##      [ 6, 1, (1,2) ] ] ]
##  \endexample
##
InstallMethod(FindNucleus, "for [IsAutomatonGroup, IsCyclotomic]", true,
                                    [IsAutomatonGroup, IsCyclotomic],
function(H,max_nucl)
  local G,g,Pairs,i,j,PairsToAdd,AssocWPairsToAdd,res,ContPairs,n,d,found,num,DoesPairContract,AddPairs,lev,maxlev,tmp,Nucl,IsElemInNucleus,
    nucl_final, cur_nucl, cur_nucl_tmp, Hi, track_s, track_l, G_track, automgens, cur_nucl_length, info;

  DoesPairContract:=function(i,j,lev)
    local t,res;
    if lev>maxlev then maxlev:=lev; fi;

    # ContPairs[i][j] may take the following values:
    # -1 - [i,j] was not met before
    # 1  - [i,j] contracts
    # 2  - [i,j] was met above in the tree

    if (ContPairs[i][j]=1) then return true; fi;
    if Pairs[i][j]<>0 then
      ContPairs[i][j]:=1;
      return true;
    fi;
    # if we've seen this pair before it needs to be in the nucleus
    if ContPairs[i][j]=2 then return [i,j]; fi;
    t:=1; res:=true;
    ContPairs[i][j]:=2;
    while res=true and (t<=d) do
      res:=DoesPairContract(G[i][t],G[j][t^G[i][d+1]],lev+1);
      t:=t+1;
    od;
    if res=true then
             ContPairs[i][j]:=1;
             return true;
    else return res;
    fi;
  end;

  AddPairs:=function(i,j)
    local tmp,l,CurNum;
    if Pairs[i][j]>0 then return Pairs[i][j]; fi;
    Pairs[i][j]:=num;
    CurNum:=num;
    Add(PairsToAdd,[]);
    num:=num+1;
    tmp:=[];
    for l in [1..d] do
      Add(tmp,AddPairs(G[i][l],G[j][l^G[i][d+1]]));
    od;
    Add(tmp,G[i][d+1]*G[j][d+1]);
    Append(PairsToAdd[CurNum-n],tmp);
    AssocWPairsToAdd[CurNum-n]:=cur_nucl[i]*cur_nucl[j];
    return CurNum;
  end;

  IsElemInNucleus:=function(g)
    local i,res;
    if g in tmp then
      for i in [Position(tmp,g)..Length(tmp)] do
        if not (tmp[i] in Nucl) then Add(Nucl,tmp[i]); fi;
      od;
      return g=tmp[1];
    fi;
    Add(tmp,g);
    res:=false; i:=1;
    while (not res) and i<=d do
      res:=IsElemInNucleus(G[g][i]);
      i:=i+1;
    od;
    tmp:=tmp{[1..Length(tmp)-1]};
    return res;
  end;

#  ******************  FindNucleus itself *******************************

  if HasIsContracting(H) and not IsContracting(H) then
    return fail;
  fi;


  info:=InfoLevel(InfoAutomata);
  if INFO_FLAG(H)=0 then SetInfoLevel(InfoAutomata,5); fi;

  automgens:=UnderlyingAutomFamily(H)!.automgens;
  d:=UnderlyingAutomFamily(H)!.deg;
  cur_nucl:=[One(UnderlyingAutomFamily(H))];

  Hi:=StructuralCopy(MINIMIZED_AUTOMATON_LIST(H));
#  Print("Gi=",Gi,"\n");
  G:=Hi[1];

  track_s:=Hi[2];
  track_l:=Hi[3];

  for i in [2..Length(track_s)] do Add(cur_nucl,automgens[track_s[i]]); od;

  found:=false;

  while (not found) and Length(G)<max_nucl do
    res:=true; maxlev:=0; ContPairs:=[];
    Pairs:=InvestigatePairs(G);
    n:=Length(G);
#    Print("n=",n,"\n");
    Info(InfoAutomata, 3, "n=",n);
    for i in [1..n] do
      Add(ContPairs,[1]);
      for j in [1..n-1] do
        if i=1 then Add(ContPairs[i],1);
               else Add(ContPairs[i],-1);
        fi;
      od;
    od;
    i:=1;

    while res=true and (i<=n) do
      j:=1;
      while res=true and (j<=n) do
        #Print("i=",i,",j=",j,"\n");
        if ContPairs[i][j]=-1 then res:=DoesPairContract(i,j,0); fi;
        if res<>true then
          PairsToAdd:=[];
          AssocWPairsToAdd:=[];
#  num represents current number of generators
          num:=n+1;
          AssocWPairsToAdd:=[];
          AddPairs(res[1],res[2]);
          Info(InfoAutomata, 3, "Elements added:",List(AssocWPairsToAdd,x->x!.word));
          Append(G,PairsToAdd);
#          Print("G=",G,"\n");
          Append(cur_nucl,AssocWPairsToAdd);
          G_track:=AddInversesTrack(G);
#          Print("G_track=",G_track,"\n");
          G:=G_track[1];
          cur_nucl_tmp:=[];
          cur_nucl_tmp:=[One(UnderlyingAutomFamily(H))];
          cur_nucl_length:=Length(cur_nucl);
          for i in [2..Length(G_track[2])] do
            if G_track[2][i]<=cur_nucl_length then
              Add(cur_nucl_tmp,cur_nucl[G_track[2][i]]);
            else
              Add(cur_nucl_tmp,cur_nucl[G_track[2][i]-cur_nucl_length]^-1);
            fi;
          od;
          cur_nucl:=StructuralCopy(cur_nucl_tmp);
        fi;
        j:=j+1;
      od;
      i:=i+1;
    od;
    if res=true then
      found:=true;
    fi;
  od;

  if not found then return fail; fi;
  Nucl:=[];
# first add elements of cycles
  for i in [1..Length(G)] do
    tmp:=[];
    if not (i in Nucl) then IsElemInNucleus(i); fi;
  od;

# now add sections of elements
  repeat
    found:=false;
    for g in Nucl do
      for i in [1..d] do
        if not (G[g][i] in Nucl) then
          found:=true;
          Add(Nucl,G[g][i]);
        fi;
      od;
    od;
  until not found;
#  Print("Nucleus:",Nucl,"\n");

  nucl_final:=[];
  for i in Nucl do Add(nucl_final,cur_nucl[i]); od;

  SetIsContracting(H, true);
  SetAutomNucleus(H, nucl_final);
  SetNucleusIncludingGeneratingSet(H, cur_nucl);
  SetNucleusIncludingGeneratingSetAutom(H, G);
  SetContractingLevel(H, maxlev);
  SetUseContraction(H, true);
  SetInfoLevel(InfoAutomata,info);

  return [nucl_final,cur_nucl,G];
end);


################################################################################
##
#M FindNucleus. . . . . . . . . . . . . . . . . . . . .Tries to find the nucleus
##                                                     of the self-similar group
InstallMethod(FindNucleus, "for [IsAutomatonGroup]", true,
                                    [IsAutomatonGroup],
function(H)
  return FindNucleus(H,infinity);
end);


################################################################################
##
#A  IsContracting (<G>)
##
##  Given a self-similar group <G> it tries to compute whether it is contracting or not.
##  Only the partial method is implemented (since there is no general algorithm so far).
##  First it tries to find the nucleus up to size 50 using '"FindNucleus"(<G>,50)', then
##  it tries to find the evidence that the group is noncontracting using
##  '"IsNoncontracting"(G,10,10)'. If the answer was not found one can try to use
##  "FindNucleus" and "IsNoncontracting" with bigger tolerances.
##
##  \beginexample
##  gap> IsContracting(Basilica);
##  true
##  gap> IsContracting(AutomGroup("a=(c,a)(1,2),b=(c,b),c=(b,a)"));
##  #I  (b*c^-1)^1 has b*a^-1 as a section at vertex [ 2 ]
##  #I  (b*a^-1)^2 has congutate of a^-1*b as a section at vertex [ 1 ]
##  false
##  \endexample
##
InstallMethod(IsContracting, "IsContracting(IsAutomGroup)", true,
              [IsAutomGroup],
function(G)
  local info, res;
  if IsSelfSimilar(G)=false then
    Info(InfoAutomata,3,"The group <G> is not self-similar, so it is not contracting");
    return false;
  elif not IsAutomatonGroup(G) then
    Info(InfoAutomata,3,"Represent <G> as a group generated by finite automaton");
    return fail;
  fi;
  info:=INFO_FLAG(G);
  SetINFO_FLAG(G, 1);
  res:=FindNucleus(G,50);
  SetINFO_FLAG(G, info);
  if res<>fail then return true; fi;
  res:=IsNoncontracting(G,10,10);
  if res=true then return false; fi;
  Info(InfoAutomata,1,"You can try FindNucleus(<G>,<max_nucl>) or");
  Info(InfoAutomata,1,"            IsNoncontracting(<G>,<lengh>,<depth>) with bigger bounds");
  TryNextMethod();
end);


################################################################################
##
#A  AutomNucleus (<G>)
##
##  Tries to compute the "nucleus" (the minimal set that need not contain original generators)
##  of a self-similar group <G>. It uses "FindNucleus" operation
##  and behaves accordingly: if the group is not contracting
##  it will loop forever (modulo memory constraints, of course).
##  See also "NucleusIncludingGeneratingSet".
##
##  \beginexample
##  gap> AutomNucleus(Basilica);
##  [ e, u, v, u^-1, v^-1, u^-1*v, v^-1*u ]
##  \endexample
##
InstallMethod(AutomNucleus, "IsContracting(IsAutomGroup)", true,
              [IsAutomGroup],
function(G)
  local info,res;
  info:=INFO_FLAG(G);
  SetINFO_FLAG(G, 1);
  FindNucleus(G);
  res:=AutomNucleus(G);
  SetINFO_FLAG(G, info);
  return res;
end);


################################################################################
##
#A  NucleusIncludingGeneratingSet (<G>)
##
##  Tries to compute the generating set of the group which includes original
##  generators and the "nucleus" (the minimal set that need not contain original generators)
##  of a self-similar group <G>. It uses "FindNucleus" operation
##  and behaves accordingly: if the group is not contracting
##  it will loop forever (modulo memory constraints, of course).
##  See also "AutomNucleus".
##
##  \beginexample
##  gap> NucleusIncludingGeneratingSet(Basilica);
##  [ e, u, v, u^-1, v^-1, u^-1*v, v^-1*u ]
##  \endexample
##
InstallMethod(NucleusIncludingGeneratingSet, "NucleusIncludingGeneratingSet(IsAutomGroup)", true,
              [IsAutomGroup],
function(G)
  local info,res;
  info:=INFO_FLAG(G);
  SetINFO_FLAG(G, 1);
  FindNucleus(G);
  res:=NucleusIncludingGeneratingSet(G);
  SetINFO_FLAG(G, info);
  return res;
end);


################################################################################
##
#M NucleusIncludingGeneratingSetAutom . . . . . . . . . . Computes automaton of nucleus
##
InstallMethod(NucleusIncludingGeneratingSetAutom, "NucleusIncludingGeneratingSetAutom(IsAutomGroup)", true,
              [IsAutomGroup],
function(G)
  local info,res;
  info:=INFO_FLAG(G);
  SetINFO_FLAG(G, 1);
  FindNucleus(G);
  res:=NucleusIncludingGeneratingSetAutom(G);
  SetINFO_FLAG(G, info);
  return res;
end);



################################################################################
##
#F InversePerm. . . . . . . . . . . .Gives permutation on the set of generators
##                                      which pushes each element to its inverse

InstallGlobalFunction(InversePerm,function(G)
  local i,j,viewed,inv,found;
  viewed:=[]; inv:=();
  for i in [1..Length(G)] do
    if not (i in viewed) then
      j:=1; found:=false;
      while j<=Length(G) and not found do
        #Print("[",i,",",j,"]\n");
        if IS_ONE_LIST([i,j],G) then
          found:=true;
          if i<>j then
            inv:=inv*(i,j);
            Append(viewed,[i,j]);
          else
            Add(viewed,i);
          fi;
        fi;
        j:=j+1;
      od;
    fi;
  od;
  return inv;
end);


################################################################################
##
#F  AutomPortrait (<a>)
#F  AutomPortraitBoundary (<a>)
#F  AutomPortraitDepth (<a>)
##
##  'AutomPortrait (<a>)' constructs the portrait of an element <a> of a contracting group $G$.
##  The portrait of <a> is defined recursively as follows. For $g$ in the nucleus
##  of $G$ the portrait is just $[g]$. For any other element $g=(g_1,g_2,...,g_d)\sigma$
##  the portrait of $g$ is $[\sigma, 'AutomPortrait'(g_1),...,'AutomPortrait'(g_d)]$,
##  where $d$ is the degree of the tree. This structure describes a tree whose inner
##  vertices are labelled by permutations from $S_d$ and the leaves are labelled by
##  the elements of the nucleus. The contraction in $G$ guarantees that the
##  portrait of any element is finite.
##
##  The portraits may be considered as a ``normal forms''
##  of the elements of $G$, since different elements have different portraits.
##
##  One also can be interested only in the boundary of a portrait, which consists
##  of all leaves of the portrait. This boundary can be described by an ordered set of
##  pairs $[level_i, g_i]$, $i=1..r$ representing the leaves of the tree ordered from left
##  to right (where $level_i$ and $g_i$ are the level and the label if the $i$-th leaf
##  correspondingly). 'AutomPortraitBoundary (<a>)' computes this boundary. It returns a list
##  consisting of 2 components. The first one is just the degree of the tree, and the
##  second one is a list of pairs described above.
##
##  'AutomPortraitDepth (<a>)' returns the depth of the portrait, i.e. the minimal level, such
##  that all sections of <a> at this level belong to the nucleus of $G$.
##
##  \beginexample
##  gap> B:=AutomGroup("a=(b,1)(1,2),b=(a,1)");
##  < a, b >
##  gap> AutomPortrait(a^3*b^-2*a);
##  [ (), [ (), [ (), [ b ], [ b ] ], [ e ] ], [ (), [ (), [ b ], [ a^-1*b ] ], [ b^-1 ] ] ]
##  gap> AutomPortrait(a^3*b^-2*a^3);
##  [ (), [ (), [ (1,2), [ (), [ (), [ b ], [ b ] ], [ e ] ], [ b ] ], [ e ] ],
##    [ (), [ (1,2), [ (), [ (), [ b ], [ b ] ], [ e ] ], [ a^-1*b ] ], [ b^-1 ] ] ]
##  gap> AutomPortraitBoundary(a^3*b^-2*a^3);
##  [ 2, [ [ 5, b ], [ 5, b ], [ 4, e ], [ 3, b ], [ 2, e ], [ 5, b ], [ 5, b ], [ 4, e ], [ 3, a^-1*b ],
##        [ 2, b^-1 ] ] ]
##  gap> AutomPortraitDepth(a^3*b^-2*a^3);
##  5
##  \endexample
##
InstallGlobalFunction(_AutomPortraitMain,function(w)
  local PortraitIter, bndry,inv,d,Perm_List,max_lev,G,w_list,w_list_orig,Gi,track_l,nucl;

  PortraitIter:=function(v,lev,plist)
    local i,j,tmpv,sigma;
    for i in [1..Length(G)] do
      tmpv:=StructuralCopy(v);
      Add(tmpv,i);
      if IS_ONE_LIST(tmpv,G) then
        Add(bndry, [lev,nucl[i^inv]]);
        Add(plist, nucl[i^inv]);
        return;
      fi;
    od;

    for i in [1..d] do
      tmpv:=[]; sigma:=();
      for j in v do
        Add(tmpv,G[j][i^sigma]);
        sigma:=sigma*G[j][d+1];
      od;
      if i=1 then Add(plist,sigma);fi;
      Add(plist,[]);
      PortraitIter(tmpv,lev+1,plist[i+1]);
    od;
  end;

  d:=w!.deg;
  G:=NucleusIncludingGeneratingSetAutom(GroupOfAutomFamily(FamilyObj(w)));
  nucl:=NucleusIncludingGeneratingSet(GroupOfAutomFamily(FamilyObj(w)));

  Gi:=MINIMIZED_AUTOMATON_LIST(GroupOfAutomFamily(FamilyObj(w)));
  track_l:=Gi[3];
  w_list_orig:=CONVERT_ASSOCW_TO_LIST(w);
  w_list:=List(w_list_orig, i->track_l[i]);


  bndry:=[];
  Perm_List:=[];
  inv:=InversePerm(G);
  max_lev:=0;
  PortraitIter(w_list,0,Perm_List);
  return [d,bndry,Perm_List];
end);

InstallGlobalFunction(AutomPortrait,function(w)
  return _AutomPortraitMain(w)[3];
end);

InstallGlobalFunction(AutomPortraitBoundary,function(w)
  return _AutomPortraitMain(w){[1..2]};
end);

InstallGlobalFunction(AutomPortraitDepth,function(w)
  local bndry;
  return Maximum(List(_AutomPortraitMain(w)[2],x->x[1]));
end);


################################################################################
##
#F WritePortraitToFile. . . . . . . . . . .Writes portrait in a file in the form
##                                                       understandable by Maple

# InstallGlobalFunction(WritePortraitToFile,function(p,file,add)
#   local WritePerm,l;
#
#   WritePerm:=function(perm)
#     local j;
#     AppendTo(file,"[ ");
#     if Length(perm)>0 then
#       AppendTo(file,"`",perm[1],"`");
#       for j in [2..Length(perm)] do
#         AppendTo(file,", ");
#         WritePerm(perm[j]);
#       od;
#     fi;
#     AppendTo(file," ]");
#   end;
#
#
#   l:=[p[1],List(p[2],x->[x[1],x[2]!.word])];
#   if add then AppendTo(file,"[ ",l[1],", ");
#     else PrintTo(file,"[ ",l[2],", ");
#   fi;
#   WritePerm(p[3]);
#   AppendTo(file, " ]");
# end);


################################################################################
##
#F WritePortraitsToFile. . . . . . . . . . . . .Writes portraitso of elements of
##                          a list in a file in the form understandable by Maple

# InstallGlobalFunction(WritePortraitsToFile,function(lst,G,file,add)
#   local WritePerm,i,p;
#
#   if add then AppendTo(file,"[ ");
#     else PrintTo(file,"[ ");
#   fi;
#
#   for i in [1..Length(lst)] do
#     if i=1 then
#         AppendTo(file,"[ ",lst[i],", ");
#     else
#         AppendTo(file,", [ ",lst[i],", ");
#     fi;
#     p:=AutomPortrait(lst[i],G);
#     WritePortraitToFile(p,file,true);
#     AppendTo(file,"]");
#
#   od;
# end);


################################################################################
##
#F AutomGroupGrowth. . . . . . . . . . . . . . . . . . . . . . . .Finds number of elements
##                                                         of the length up to n

InstallGlobalFunction(AutomGroupGrowth,function(n,G)
  local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,inverse,H;

  inverse:=function(w)
    local i, iw;
    iw:=[];
    for i in [1..Length(w)] do
      iw[i]:=w[Length(w)-i+1]^inv;
    od;
    return iw;
  end;

  gr:=1; len:=1;
  H:=AddInverses(G);
  if G<>H then
    Info(InfoAutomata, 3, "Inverses were added. Automaton was minimized. Now generator set is:\n",H);
    G:=H;
  fi;
  inv:=InversePerm(G);
  GrList:=[1,Length(G)];
  ElList:=[];
  for i in [1..Length(G)] do
    Add(ElList,[i]);
  od;

  while len<n do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for j in [2..Length(G)] do
        v:=StructuralCopy(ElList[i]);
        Add(v,j);
        New:=true;
        k:=1;
        while New and k<=oldgr do
          tmpv:=StructuralCopy(v);
          Append(tmpv,inverse(ElList[k]));
          if IS_ONE_LIST(tmpv,G) then New:=false; fi;
          k:=k+1;
        od;
        if New then Add(ElList,v); fi;
      od;
    od;
    Add(GrList,Length(ElList));
    Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList));
    len:=len+1;
  od;

  return GrList;
end);


################################################################################
##
#F AutomGroupGrowthFast. . . . . . . . . .Computes the growth function while the number of
##               elements is not greater than n and length is not greater than m

InstallGlobalFunction(AutomGroupGrowthFast,function(n,m,G)
  local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,inverse,H;

  inverse:=function(w)
    local i, iw;
    iw:=[];
    for i in [1..Length(w)] do
      iw[i]:=w[Length(w)-i+1]^inv;
    od;
    return iw;
  end;

  gr:=1; len:=1;
  H:=AddInverses(G);
  if G<>H then
    Info(InfoAutomata, 3, "Inverses were added. Now generator set is:\n",H);
    G:=H;
  fi;
  inv:=InversePerm(G);
  GrList:=[1,Length(G)];
  ElList:=[];
  for i in [1..Length(G)] do
    Add(ElList,[i]);
  od;

  while Length(ElList)<n and len<m do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for j in [2..Length(G)] do
        v:=StructuralCopy(ElList[i]);
        Add(v,j);
        New:=true;
        k:=1;
        while New and k<=oldgr do
          tmpv:=StructuralCopy(v);
          Append(tmpv,inverse(ElList[k]));
          if IS_ONE_LIST(tmpv,G) then New:=false; fi;
          k:=k+1;
        od;
        if New then Add(ElList,v); fi;
      od;
    od;
    Add(GrList,Length(ElList));
    Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList));
    len:=len+1;
  od;

  return GrList;
end);



################################################################################
##
#F AutomGroupElements . . . . . . . . . . . . . . . . . . .Enumerates all elements of
##                                     a self-similar group up to a given length

InstallGlobalFunction(AutomGroupElements,function(n,G)
  local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,inverse,H;

  inverse:=function(w)
    local i, iw;
    iw:=[];
    for i in [1..Length(w)] do
      iw[i]:=w[Length(w)-i+1]^inv;
    od;
    return iw;
  end;

  gr:=1; len:=1;
  H:=AddInverses(G);
  if G<>H then
    Info(InfoAutomata, 3, "Inverses were added. Automaton was minimized. Now generator set is:\n",H);
    G:=H;
  fi;
  inv:=InversePerm(G);
  GrList:=[1,Length(G)];
  ElList:=[];
  for i in [1..Length(G)] do
    Add(ElList,[i]);
  od;

  while len<n do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for j in [2..Length(G)] do
        v:=StructuralCopy(ElList[i]);
        Add(v,j);
        New:=true;
        if len=1 then k:=1; else k:=GrList[len-1]; fi;
        while New and k<=oldgr do
          tmpv:=StructuralCopy(v);
          Append(tmpv,inverse(ElList[k]));
          if IS_ONE_LIST(tmpv,G) then New:=false; fi;
          k:=k+1;
        od;
        if New then Add(ElList,v); fi;
      od;
    od;
    Add(GrList,Length(ElList));
    Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList));
    len:=len+1;
  od;

  return ElList;
end);


################################################################################
##
#M _FiniteGroupId . . . . . . . . . . Computes a finite group of permutations
##    generated by a self-similar group (in case of infinite group doesn't stop)

InstallMethod(_FiniteGroupId, "_FiniteGroupId(IsAutomatonGroup, IsPosInt)", true,
              [IsAutomatonGroup, IsCyclotomic],
function(H,size)
  local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,IsNewRel,inverse,G,FinG,tmpl,push,ProductEls,act,rels, LongCycle;

  inverse:=function(w)
    local i, iw;
    iw:=[];
    for i in [1..Length(w)] do
      iw[i]:=w[Length(w)-i+1]^inv;
    od;
    return iw;
  end;

  ProductEls:=function(i,j)
    local t,v,tmpv;
    v:=StructuralCopy(ElList[i]);
    Append(v,ElList[j]);
    for t in [1..Length(ElList)] do
      tmpv:=StructuralCopy(v);
      Append(tmpv,inverse(ElList[t]));
      if IS_ONE_LIST(tmpv,G) then return t; fi;
    od;
  end;

  LongCycle:=function(n)
    local l,i;
    l:=[];
    for i in [2..n] do Add(l,i); od;
    Add(l,1);
    return PermList(l);
  end;

  IsNewRel:=function(v)
    local  tmp,i,j,cyc,cycr,v_cyc,r_cyc,r,r_cyc_inv;
    cyc:=LongCycle(Length(v));
    for i in [0..Length(v)-1] do
      v_cyc:=Permuted(v,cyc^i);
      if v_cyc[1]=v_cyc[Length(v)]^inv then return false; fi;
      for r in rels do
        cycr:=LongCycle(Length(r));
        for j in [0..Length(r)-1] do
          r_cyc:=Permuted(r,cycr^j);
          r_cyc_inv:=inverse(Permuted(r,cycr^j));
          if PositionSublist(v_cyc,r_cyc) <> fail or PositionSublist(v_cyc,r_cyc_inv) <> fail then
            return false;
          fi;
        od;
      od;
    od;
    return true;
  end;

#######################   _FiniteGroupId  itself #########################################
  gr:=1; len:=1;

  G:=CHOOSE_AUTOMATON_LIST(H);

  inv:=InversePerm(G);
  if not HasIsFinite(H) then
    Info(InfoWarning,2,"warning, if <H> is infinite the algorithm will never stop");
  fi;
  GrList:=[1,Length(G)];
  ElList:=[]; rels:=[];
  for i in [1..Length(G)] do
    Add(ElList,[i]);
  od;
  while GrList[len+1]>GrList[len] and GrList[len+1]<size do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for j in [2..Length(G)] do
        v:=StructuralCopy(ElList[i]);
        if j<>v[Length(v)]^inv then
          Add(v,j);
          New:=true;
          if len=1 then k:=1; else k:=GrList[len-1]+1; fi;
          while New and k<=oldgr do
            tmpv:=StructuralCopy(v);
            Append(tmpv,inverse(ElList[k]));
            if IS_ONE_LIST(tmpv,G) then
              New:=false;
## show relations
              if IsNewRel(tmpv) then
                Add(rels,tmpv);
#                Info(InfoAutomata, 3, v,"*",ElList[k],"^(-1)=1");
#               Print(tmpv,"\n");
              fi;
            fi;
            k:=k+1;
          od;
          if New then Add(ElList,v); fi;
        fi;
      od;
    od;
    Add(GrList,Length(ElList));
    Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList));
    len:=len+1;
  od;

  if GrList[len+1]>GrList[len] then return fail; fi;

  SetSize(H,GrList[len]);

# in case of finite group construct Cayley table


  FinG:=[];
  for i in [2..UnderlyingAutomFamily(H)!.numstates+1] do
    act:=();
    tmpl:=[];
    while Length(tmpl)<Length(ElList) do
      j:=1;
      while j in tmpl do j:=j+1; od;
      Add(tmpl,j);
      push:=ProductEls(j,i);
      while push<>j do
        Add(tmpl,push);
        act:=act*(j,push);
        push:=ProductEls(push,i);
      od;
    od;
    Add(FinG,act);
  od;

  return GroupWithGenerators(FinG);
end);


################################################################################
##
#F _FiniteGroupId . . . . . . . . . . . . Computes a finite group of permutations
##    generated by a self-similar group (in case of infinite group doesn't stop)


InstallMethod(_FiniteGroupId, "_FiniteGroupId(IsAutomGroup)",
              [IsAutomGroup],
function(G)
  return _FiniteGroupId(G,infinity);
end);


InstallMethod(_FiniteGroupId, "_FiniteGroupId(IsAutomGroup,IsCyclotomic)",
              [IsAutomGroup,IsCyclotomic],
function(G,n)
  local ElList,GrList,i,j,orig_gens,gen,gens,new_gen,g,len,viewed,oldgr,New,k,ProductEls,FinG,tmpl,push,act,track_l,
        num_diff_gens,num_orig_gens,old_gens;

  ProductEls:=function(i,j)
    local t;
    for t in [1..Length(ElList)] do
      if IsOne(ElList[i]*ElList[j]*ElList[t]^-1) then return t; fi;
    od;
    return fail;
  end;

  orig_gens:=ShallowCopy(GeneratorsOfGroup(G));
  num_orig_gens:=Length(orig_gens);
  Append(orig_gens,List(orig_gens,x->x^-1));

  gens:=[];

# select pairwise different generators and track the original ones.
# examlpe: assume b^2=1
# orig_gens =    [a,e,a,b,b,c,  a^-1,e^-1,a^-1,b^-1,b^-1,c^-1]
# track_l   =    [1,0,1,2,2,3,  4,   0,   4,   2,   2,   5   ]
# gens      =    [a,b,c,a^-1,c^-1]
# num_orig_gens= 6
# num_diff_gens= 3
  track_l:=[];
  for i in [1..Length(orig_gens)] do
    if IsOne(orig_gens[i]) then
      track_l[i]:=0;
    else
      new_gen:=true;
      j:=1;
      while j<i and new_gen do
        if orig_gens[i]=orig_gens[j] then
          new_gen:=false;
          track_l[i]:=track_l[j];
        fi;
        j:=j+1;
      od;
      if new_gen then
        Add(gens,orig_gens[i]);
        track_l[i]:=Length(gens);
      fi;
      if i=num_orig_gens then num_diff_gens:=Length(gens); fi;
    fi;
  od;

  ElList:=[One(G)]; Append(ElList,ShallowCopy(gens));
  GrList:=[1,Length(gens)+1];
  len:=1;

  while len<n and GrList[len]<>GrList[len+1] do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for gen in gens do
        g:=ElList[i]*gen;
#       Print("g=",g,"\n\n");
        New:=true;
        if len=1 then k:=1; else k:=GrList[len-1]; fi;
        while New and k<=oldgr do
#          Print(g*ElList[k]^-1,"\n");
          if IsOne(g*ElList[k]^-1) then New:=false; fi;
          k:=k+1;
        od;
        if New then Add(ElList,g); fi;
      od;
    od;
    Add(GrList,Length(ElList));
    Info(InfoAutomata,3,"Length not greater than ",len+1,": ",Length(ElList));
    len:=len+1;
  od;

  if GrList[len]<>GrList[len+1] then return fail;  fi;

  SetSize(G,GrList[len]);

# in case of finite group construct Cayley table
  FinG:=[];
  for i in [2..num_diff_gens+1] do
    act:=();
    tmpl:=[];
    while Length(tmpl)<Length(ElList) do
      j:=1;
      while j in tmpl do j:=j+1; od;
      Add(tmpl,j);
      push:=ProductEls(j,i);
      while push<>j do
        Add(tmpl,push);
        act:=act*(j,push);
        push:=ProductEls(push,i);
      od;
    od;
    Add(FinG,act);
  od;

# switch to the original generating set
  old_gens:=[];
  for i in [1..num_orig_gens] do
    if track_l[i]=0 then
      old_gens[i]:=();
    else
      old_gens[i]:=FinG[track_l[i]];
    fi;
  od;

  return GroupWithGenerators(old_gens);
end);


################################################################################
##
#F MarkovOperator. . . . . . . . . . . . . .Computes a matrix of Markov operator
##                                related to group G on the n-th level of a tree

InstallGlobalFunction(MarkovOperator,function(G,n)
  local H,inv,i,el,j,m,d;
  d:=Length(G[1])-1;
  H:=AddInverses(G);
  inv:= InversePerm(H);
  m:=[];
  for i in [1..d^n] do Add(m,[]); od;
  for i in [1..d^n] do
    for j in [1..d^n] do m[i][j]:=0; od;
  od;
  for el in [2..Length(H)] do
    m:=m+_GeneratorActionOnLevelAsMatrix(H,el,n);
  od;
  return m;
end);


################################################################################
##
#F IsOneWordSubs. . . . . . . . . . . . Determines if the word in terms of given
##                                                         generators is trivial

InstallGlobalFunction(IsOneWordSubs,function(w,subs,G)
  local i,v;
  v:=[];
  for i in w do Append(v,subs[i]); od;
  return IS_ONE_LIST(v,G);
end);


################################################################################
##
#M FindRelsSubs. . . . . . . . . . . .Finds group relations between given elements
##                                     stops after investigating elements of length max_len
##                                      or when it finds "num_of_rels" relations

InstallMethod(FindRelsSubs, "FindRelsSubs(subs_words,names,G,max_len,num_of_rels)", true,
              [IsList, IsList, IsAutomGroup, IsCyclotomic, IsCyclotomic],
function(subs_words,names,G,max_len,num_of_rels)
  local gens, Gi, H, rel, rels, rels0, k, track_s, track_l, AssocW, FindRelsLocal, gens_autom, i, j, subs, subs1, w_list, FindRelsSubsLocal, w_ext, w, automgens, numstates, F, cur_gen;

  AssocW:=function(w)
     return Product(List(w, i -> gens[i]));
  end;

  FindRelsSubsLocal:=function(subs,G)
    local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,IsNewRelS,inverse,inverseS,H,FinG,tmpl,push,ProductEls,act,rels, LongCycle,invslist,invs,origlength,w,invadded,AssocWrels;

    inverse:=function(w)
      local i, iw;
      iw:=[];
      for i in [1..Length(w)] do
        iw[i]:=w[Length(w)-i+1]^inv;
      od;
      return iw;
    end;

    inverseS:=function(w)
      local i, iw;
      iw:=[];
      for i in [1..Length(w)] do
        iw[i]:=w[Length(w)-i+1]^invs;
      od;
      return iw;
    end;

    ProductEls:=function(i,j)
      local t,v,tmpv;
      v:=StructuralCopy(ElList[i]);
      Append(v,ElList[j]);
      for t in [1..Length(ElList)] do
        tmpv:=StructuralCopy(v);
        Append(tmpv,inverse(ElList[t]));
        if IS_ONE_LIST(tmpv,G) then return t; fi;
      od;
    end;

    LongCycle:=function(n)
      local l,i;
      l:=[];
      for i in [2..n] do Add(l,i); od;
      Add(l,1);
      return PermList(l);
    end;

    IsNewRelS:=function(v)
      local  tmp,i,j,cyc,cycr,v_cyc,r_cyc,r,r_cyc_inv;
      cyc:=LongCycle(Length(v));
      for i in [0..Length(v)-1] do
        v_cyc:=Permuted(v,cyc^i);
        if v_cyc[1]=v_cyc[Length(v)]^invs then return false; fi;
        for r in rels do
          cycr:=LongCycle(Length(r));
          for j in [0..Length(r)-1] do
            r_cyc:=Permuted(r,cycr^j);
            r_cyc_inv:=inverseS(Permuted(r,cycr^j));
            if PositionSublist(v_cyc,r_cyc) <> fail or PositionSublist(v_cyc,r_cyc_inv) <> fail then
              return false;
            fi;
          od;
        od;
      od;
      return true;
    end;
#************************ FindRelsSubsLocal itself ****************************************************

    rels:=[];
    inv:=InversePerm(G);
  #check if there are any identity elements in subs list
    for i in [1..Length(subs)] do
      if IS_ONE_LIST(subs[i],G) then
        Error(AssocW([i]),"=id, remove this element from a list and try again");
      fi;
    od;

    AssocWrels:=[];

  #check if there are any equal elements in subs list
    invslist:=[];
    for i in [1..Length(subs)] do
      for j in [i..Length(subs)] do
        if i<>j and IS_ONE_LIST(Concatenation(subs[i],inverse(subs[j])),G) then
          Error(AssocW([i]),"=",AssocW([j]),", remove one of these elements from a list and try again");
        fi;

  #      Print(IS_ONE_LIST(Append(StructuralCopy(subs[i]),subs[j]),G),"\n");
  #      Print(Concatenation(subs[i],subs[j]),"\n");

        if IS_ONE_LIST(Concatenation(subs[i],subs[j]),G) then
          invslist[i]:=j; invslist[j]:=i;
          Add(rels,[i,j]);
          Add(AssocWrels,AssocW([i,j]));
          Info(InfoAutomata, 3, AssocW([i,j]));
        fi;
      od;
    od;

  # add inverses to subs list
    origlength:=Length(subs);
    invadded:=false;
    for i in [1..origlength] do
      if not IsBound(invslist[i]) then
        invadded:=true;
        Add(subs,inverse(subs[i]));
        Add(gens,gens[i]^-1);
        invslist[i]:=Length(subs);
        invslist[Length(subs)]:=i;
      fi;
    od;

    invs:=PermList(invslist);

    GrList:=[1,Length(subs)+1];
    ElList:=[];

    gr:=1; len:=1;

    for i in [1..Length(subs)] do
      Add(ElList,[i]);
    od;
    while GrList[len+1]>GrList[len] and len<max_len and Length(rels)<num_of_rels do
      for i in [GrList[len]..GrList[len+1]-1] do
        oldgr:=Length(ElList);
        for j in [1..Length(subs)] do
          v:=StructuralCopy(ElList[i]);
          if j<>v[Length(v)]^invs then
            Add(v,j);
            New:=true;
  #          k:=1;
            if len=1 then k:=1; else k:=GrList[len-1]; fi;
            while New and k<=oldgr do
              tmpv:=StructuralCopy(v);
              Append(tmpv,inverseS(ElList[k]));
              if IsOneWordSubs(tmpv,subs,G) then
                New:=false;
  ## show relations
                if IsNewRelS(tmpv) then
                  Add(rels,tmpv);
                  if Length(AssocW(tmpv))>0 then
                    Add(AssocWrels,AssocW(tmpv));
                    Info(InfoAutomata, 3, AssocW(tmpv));
                  fi;
                fi;
              fi;
              k:=k+1;
            od;
            if New then Add(ElList,v); fi;
          fi;
        od;
      od;
      Add(GrList,Length(ElList)+1);
  #    Print("ElList[",len,"]=",ElList,"\n");
      Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList)+1);
      len:=len+1;
    od;
    return AssocWrels;
  end;


#************************ FindRelsSubsMain itself ****************************************************

  if Length(subs_words)<>Length(names) then
    Error("The number of names must coincide with the number of generators");
  fi;
  F:=FreeGroup(names);

# gens is a mutable list of generators
  gens:=[];
  for i in GeneratorsOfGroup(F) do Add(gens,i); od;

  automgens:=UnderlyingAutomFamily(G)!.automgens;
  numstates:=UnderlyingAutomFamily(G)!.numstates;

  subs1:=[];

#convert associative words into lists
  for w in subs_words do
    Add(subs1,CONVERT_ASSOCW_TO_LIST(w));
  od;


  Gi:=StructuralCopy(MINIMIZED_AUTOMATON_LIST(G));
#  Print("Gi=",Gi,"\n");
  H:=Gi[1];

  track_s:=Gi[2];
  track_l:=Gi[3];

  subs:=[];

  for w in subs1 do
    w_list:=[];
    for i in [1..Length(w)] do Add(w_list,track_l[w[i]]); od;
    Add(subs,ShallowCopy(w_list));
  od;
  rels0:=[];

#  for k in [1..Length(AutomatonList(G))] do
#  Print("Beam\n");
#    if track_l[k]=1 then Add(rels0,AssocW([k]));
#      elif track_s[track_l[k]]<>k then Add(rels0,AssocW([k,track_s[track_l[k]]+Length(AutomatonList(G))]));
#    fi;
#  od;


  rels:=FindRelsSubsLocal(subs,CHOOSE_AUTOMATON_LIST(G));
  if rels=fail then return fail; fi;
  Append(rels0,rels);
#  Print(rels0);
  return rels0;
end);

################################################################################
##
#M FindRelsSubs. . . . . . . . . . . . . .Finds group relations between given elements
##                                     stops after investigating elements of length max_len
##

InstallMethod(FindRelsSubs, "FindRelsSubs(subs_words,names,G,max_len)", true,
              [IsList, IsList, IsAutomGroup, IsCyclotomic],
function(subs_words,names,G,max_len)
  return FindRelsSubs(subs_words,names,G,max_len,infinity);
end);


################################################################################
##
#M FindRelsSubs. . . . . . . . . . . . . .Finds group relations between given elements
##
##
InstallMethod(FindRelsSubs, "FindRelsSubs(subs_words,names,G)",
              [IsList, IsList, IsAutomGroup],
function(subs_words,names,G)
  return FindRelsSubs(subs_words,names,G,infinity,infinity);
end);


################################################################################
##
#M FindRelsSubsSG. . . . . . . . . . .Finds relations between given elements
##                                         in the subsemigroup generated by them
##                                     stops after investigating elements of length max_len
##                                     and when it finds "num_of_rels" relations

InstallOtherMethod(FindRelsSubsSG, "FindRelsSubsSG(subs_words,names,G,max_len,num_of_rels)", true,
              [IsList, IsList, IsAutomGroup, IsCyclotomic, IsCyclotomic],
function(subs_words,names,G,max_len,num_of_rels)
  local gens, Gi, H, rel, rels, rels0, k, track_s, track_l, AssocW, gens_autom, i, j, subs, subs1, w_list, FindRelsSubsSGLocal, w_ext, w, automgens, numstates, F, cur_gen;

  AssocW:=function(w)
     return Product(List(w, i -> gens[i]));
  end;

  FindRelsSubsSGLocal:=function(subs,G)
    local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,IsNewRelS,inverse,inverseS,H,FinG,tmpl,push,ProductEls,act,rels, LongCycle,invslist,invs,origlength,w,invadded,Expand,rel,New_rel,AssocWrels;

    #inverse as a word over generators of automaton
    inverse:=function(w)
      local i, iw;
      iw:=[];
      for i in [1..Length(w)] do
        iw[i]:=w[Length(w)-i+1]^inv;
      od;
      return iw;
    end;

    ProductEls:=function(i,j)
      local t,v,tmpv;
      v:=StructuralCopy(ElList[i]);
      Append(v,ElList[j]);
      for t in [1..Length(ElList)] do
        tmpv:=StructuralCopy(v);
        Append(tmpv,inverse(ElList[t]));
        if IS_ONE_LIST(tmpv,G) then return t; fi;
      od;
    end;

    #rewrites a word over subs in terms of generators of automaton
    Expand:=function(v)
    local i,tmpv;
      tmpv:=[];
      for i in [1..Length(v)] do
        Append(tmpv,subs[v[i]]);
      od;
      return tmpv;
    end;

  #************************ FindRelsSubsSGLocal itself ****************************************************

    rels:=[];
    AssocWrels:=[];

    inv:=InversePerm(G);
  #check if there are any identity elements in subs list
    for i in [1..Length(subs)] do
      if IS_ONE_LIST(subs[i],G) then
        Error(AssocW([i]),"=id, remove this element from the list and try again");
      fi;
    od;

  #check if there are any equal elements in subs list
  #  invslist:=[];
    for i in [1..Length(subs)] do
      for j in [i..Length(subs)] do
        if i<>j and IS_ONE_LIST(Concatenation(subs[i],inverse(subs[j])),G) then
          Error(AssocW([i]),"=",AssocW([j]),", remove one of these elements from the list and try again");
        fi;

  #      Print(IS_ONE_LIST(Append(StructuralCopy(subs[i]),subs[j]),G),"\n");
  #      Print(Concatenation(subs[i],subs[j]),"\n");

  #      if IS_ONE_LIST(Concatenation(subs[i],subs[j]),G) then
  #        invslist[i]:=j; invslist[j]:=i;
  #        Add(rels,[i,j]);
  #        Print("[",i,",",j,"]=1\n");
  #      fi;
      od;
    od;

    GrList:=[1,Length(subs)+1];
    ElList:=[];

    gr:=1; len:=1;

    for i in [1..Length(subs)] do
      Add(ElList,[i]);
    od;
    while GrList[len+1]>GrList[len] and len<max_len and Length(rels)<num_of_rels do
      for i in [GrList[len]..GrList[len+1]-1] do
        oldgr:=Length(ElList);
        for j in [1..Length(subs)] do
          v:=StructuralCopy(ElList[i]);
          Add(v,j);
# New stands for New element
          New:=true;
          if IS_ONE_LIST(Expand(v),G) then
            New:=false;
            Add(rels,[v,1]);
            if Length(AssocW(v))>0 then
              Add(AssocWrels,[AssocW(v),One(F)]);
              Info(InfoAutomata, 3, AssocW(v),"=e");
            fi;
          else
            k:=1;
            while New and k<=oldgr do
              tmpv:=Expand(v);
#              Print("v=",v,"; tmpv=",tmpv,"\n");
              Append(tmpv,inverse(Expand(ElList[k])));
              if IS_ONE_LIST(tmpv,G) then
                New:=false;
## show relations
                New_rel:=true;
                for rel in rels do
                  if PositionSublist(v,rel[1]) <> fail then New_rel:=false; fi;
                od;
                if New_rel then
                  Add(rels,[v,ElList[k]]);
#                  if Length(AssocW(v))>0 then
                  Add(AssocWrels,[AssocW(v),AssocW(ElList[k])]);
                  Info(InfoAutomata, 3, AssocW(v),"=",AssocW(ElList[k]));
#                  fi;
                fi;
              fi;

              k:=k+1;
            od;
          fi;
          if New then Add(ElList,v); fi;
        od;
      od;
      Add(GrList,Length(ElList)+1);
      Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList)+1);
      len:=len+1;
    od;
    return AssocWrels;
  end;

#  *********************** FindRelsSubsSG itself ****************************************************

  if Length(subs_words)<>Length(names) then
    Error("The number of names must coincide with the number of generators");
  fi;
  F:=FreeGroup(names);

# gens is a mutable list of generators
  gens:=[];
  for i in GeneratorsOfGroup(F) do Add(gens,i); od;

  automgens:=UnderlyingAutomFamily(G)!.automgens;
  numstates:=UnderlyingAutomFamily(G)!.numstates;

  subs1:=[];

#convert associative words into lists
  for w in subs_words do
    Add(subs1,CONVERT_ASSOCW_TO_LIST(w));
  od;


  Gi:=StructuralCopy(MINIMIZED_AUTOMATON_LIST(G));
#  Print("Gi=",Gi,"\n");
  H:=Gi[1];

  track_s:=Gi[2];
  track_l:=Gi[3];

  subs:=[];

  for w in subs1 do
    w_list:=[];
    for i in [1..Length(w)] do Add(w_list,track_l[w[i]]); od;
    Add(subs,ShallowCopy(w_list));
  od;
  rels0:=[];

#  for k in [1..Length(AutomatonList(G))] do
#  Print("Beam\n");
#    if track_l[k]=1 then Add(rels0,AssocW([k]));
#      elif track_s[track_l[k]]<>k then Add(rels0,AssocW([k,track_s[track_l[k]]+Length(AutomatonList(G))]));
#    fi;
#  od;


  rels:=FindRelsSubsSGLocal(subs,CHOOSE_AUTOMATON_LIST(G));
  if rels=fail then return fail; fi;
  Append(rels0,rels);
#  Print(rels0);
  return rels0;
end);


################################################################################
##
#M FindRelsSubsSG. . . . . . . . . . .Finds relations between given elements
##                                         in the subsemigroup generated by them
##                                     stops after investigating elements of length max_len

InstallMethod(FindRelsSubsSG, "FindRelsSubsSG(subs_words,names,G,max_len)", true,
              [IsList, IsList, IsAutomGroup, IsCyclotomic],
function(subs_words,names,G,max_len)
  return FindRelsSubsSG(subs_words,names,G,max_len,infinity);
end);


################################################################################
##
#M FindRelsSubsSG. . . . . . . . . . . . .Finds relations between given elements
##                                         in the subsemigroup generated by them

InstallMethod(FindRelsSubsSG, "FindRelsSubsSG(subs_words,names,G)",
              [IsList, IsList, IsAutomGroup],
function(subs_words,names,G)
  return FindRelsSubsSG(subs_words,names,G,infinity,infinity);
end);




################################################################################
##
#M FindRels . . . . . . . . . finds relators in terms of the original generators
##
##
InstallMethod(FindRels, "FindRels(G,max_len,num_of_rels)", true,
              [IsAutomGroup, IsCyclotomic, IsCyclotomic],
function(G,max_len,num_of_rels)
  local gens, Gi, H, rel, rels, rels0, k, track_s, track_l, AssocW, FindRelsLocal;

  AssocW:=function(w)
     #Print(w);
     return Product(List(w, i -> gens[i]));
  end;


  FindRelsLocal:=function(subs,G)
    local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,IsNewRelS,inverse,inverseS,H,FinG,tmpl,push,ProductEls,act,rels, LongCycle,invslist,invs,origlength,w,invadded,tmpv_orig,AssocWrels;

    inverse:=function(w)
      local i, iw;
      iw:=[];
      for i in [1..Length(w)] do
        iw[i]:=w[Length(w)-i+1]^inv;
      od;
      return iw;
    end;

    inverseS:=function(w)
      local i, iw;
      iw:=[];
      for i in [1..Length(w)] do
        iw[i]:=w[Length(w)-i+1]^invs;
      od;
      return iw;
    end;

    ProductEls:=function(i,j)
      local t,v,tmpv;
      v:=StructuralCopy(ElList[i]);
      Append(v,ElList[j]);
      for t in [1..Length(ElList)] do
        tmpv:=StructuralCopy(v);
        Append(tmpv,inverse(ElList[t]));
        if IS_ONE_LIST(tmpv,G) then return t; fi;
      od;
    end;

    LongCycle:=function(n)
      local l,i;
      l:=[2..n];
      Add(l,1);
      return PermList(l);
    end;

    IsNewRelS:=function(v)
      local  tmp,i,j,cyc,cycr,v_cyc,r_cyc,r,r_cyc_inv;
      cyc:=LongCycle(Length(v));
      for i in [0..Length(v)-1] do
        v_cyc:=Permuted(v,cyc^i);
        if v_cyc[1]=v_cyc[Length(v)]^invs then return false; fi;
        for r in rels do
          cycr:=LongCycle(Length(r));
          for j in [0..Length(r)-1] do
            r_cyc:=Permuted(r,cycr^j);
            r_cyc_inv:=inverseS(Permuted(r,cycr^j));
            if PositionSublist(v_cyc,r_cyc) <> fail or PositionSublist(v_cyc,r_cyc_inv) <> fail then
              return false;
            fi;
          od;
        od;
      od;
      return true;
    end;
#************************ FinRelsLocal itself ****************************************************

    rels:=[];
    AssocWrels:=[];
    inv:=InversePerm(G);


    invslist:=[];
    for i in [1..Length(subs)] do
      for j in [i..Length(subs)] do
#        Print(AssocW([Gi[2][i+1],Gi[2][j+1]])!.word,"\n");
        if IS_ONE_LIST(Concatenation(subs[i],subs[j]),G) then
          invslist[i]:=j; invslist[j]:=i;
          if Length(AssocW([Gi[2][i+1],Gi[2][j+1]])!.word)>0 then
            Add(rels,[i,j]);
            Add(AssocWrels,AssocW([Gi[2][i+1],Gi[2][j+1]]));
            Info(InfoAutomata, 3, AssocW([Gi[2][i+1],Gi[2][j+1]])!.word);
          fi;
        fi;
      od;
    od;

    invs:=PermList(invslist);

    GrList:=[1,Length(subs)+1];
    ElList:=[];

    gr:=1; len:=1;

    for i in [1..Length(subs)] do
      Add(ElList,[i]);
    od;
    while GrList[len+1]>GrList[len] and len<max_len and Length(rels)<num_of_rels do
      for i in [GrList[len]..GrList[len+1]-1] do
        oldgr:=Length(ElList);
        for j in [1..Length(subs)] do
          v:=StructuralCopy(ElList[i]);
          if j<>v[Length(v)]^invs then
            Add(v,j);
            New:=true;
 #          k:=1;
            if len=1 then k:=1; else k:=GrList[len-1]; fi;
            while New and k<=oldgr do
              tmpv:=StructuralCopy(v);
              Append(tmpv,inverseS(ElList[k]));
              if IsOneWordSubs(tmpv,subs,G) then
                New:=false;
## show relations
                if IsNewRelS(tmpv) then
# tmpv in the original generators
                  tmpv_orig:=[];
                  for k in [1..Length(tmpv)] do
                    tmpv_orig[k]:=Gi[2][tmpv[k]+1];
                  od;
                  Add(rels,tmpv);
                  if Length(AssocW(tmpv_orig)!.word)>0 then
                    Add(AssocWrels,AssocW(tmpv_orig));
                    Info(InfoAutomata, 3, AssocW(tmpv_orig)!.word);
                  fi;
#                 Print(tmpv,"\n");
                fi;
              fi;
              k:=k+1;
            od;
            if New then Add(ElList,v); fi;
          fi;
        od;
      od;
      Add(GrList,Length(ElList)+1);
 #    Print("ElList[",len,"]=",ElList,"\n");
      Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList)+1);
      len:=len+1;
    od;
    return AssocWrels;
  end;

#************************ FinRels itself ****************************************************

  gens:=UnderlyingAutomFamily(G)!.automgens;

  Gi:=StructuralCopy(MINIMIZED_AUTOMATON_LIST(G));
#  Print("Gi=",Gi,"\n");
  H:=Gi[1];

  track_s:=Gi[2];
  track_l:=Gi[3];
  rels0:=[];

#  for k in [1..Length(AutomatonList(G))] do
#  Print("Beam\n");
#    if track_l[k]=1 then Add(rels0,AssocW([k]));
#      elif track_s[track_l[k]]<>k then Add(rels0,AssocW([k,track_s[track_l[k]]+Length(AutomatonList(G))]));
#    fi;
#  od;


  rels:=FindRelsLocal(List([2..Length(H)],i->[i]),CHOOSE_AUTOMATON_LIST(G));
  Append(rels0,rels);
#  Print(rels0);
  return rels0;
end);


################################################################################
##
#M FindRels . . . . . . . . . Finds relatoins in terms of the original generators
##
##
InstallMethod(FindRels, "FindRels(G,max_len)", true,
              [IsAutomGroup, IsCyclotomic],
function(G,max_len)
  return FindRels(G,max_len,infinity);
end);



################################################################################
##
#M FindRels . . . . . . . . . Finds relatoins in terms of the original generators
##
##
InstallMethod(FindRels, "FindRels(G)",
              [IsAutomGroup],
function(G)
  return FindRels(G,infinity,infinity);
end);


################################################################################
##
#M FindRels . . . . . . . . . Fing relatoins in terms of the original generators
##
##
InstallMethod(FindRels, "FindRels(G)",
              [IsAutomGroup],
function(G)
  return FindRels(G,infinity,infinity);
end);



################################################################################
##
#M ORDER_USING_SECTIONS
##   such that h^k has h as a section
##

InstallMethod(ORDER_USING_SECTIONS, "ORDER_USING_SECTIONS(IsAutom,IsCyclotomic)", true,
              [IsAutom, IsCyclotomic],
function(a, max_depth)
  local ORDER_USING_SECTIONS_LOCAL, cur_list, F, degs, vertex, AreConjugateUsingSmallRels, gens_ord2, CyclicallyReduce, res;

  CyclicallyReduce:=function(w)
    local i,j,wtmp,reduced;

    for i in [1..Length(w)] do
      if -w[i] in gens_ord2 then w[i]:=-w[i]; fi;
    od;

    repeat
      reduced:=true;
      j:=1;
      while reduced  and j<Length(w) do
        if w[j]=-w[j+1] or (w[j]=w[j+1] and w[j] in gens_ord2) then
          reduced:=false;
          wtmp:=ShallowCopy(w{[1..j-1]});
          Append(wtmp,w{[j+2..Length(w)]});
          w:=wtmp;
        fi;
        j:=j+1;
      od;
    until reduced;

    repeat
      if Length(w)<2 then return w; fi;
      reduced:=true;
      if w[1]=-w[Length(w)] or (w[1]=w[Length(w)] and w[1] in gens_ord2) then
        w:=w{[2..Length(w)-1]};
        reduced:=false;
      fi;
    until reduced;

    return w;
  end;

  AreConjugateUsingSmallRels:=function(g,h)
    local i, g_list, h_list,long_cycle,l;
    g_list:=CyclicallyReduce(LetterRepAssocWord(g));
    h_list:=CyclicallyReduce(LetterRepAssocWord(h));
    if Length(g_list)<>Length(h_list) then return false; fi;
    l:=[2..Length(g_list)];
    Add(l,1);
    long_cycle:=PermList(l);
    for i in [0..Length(g_list)-1] do
      if h_list=Permuted(g_list,long_cycle^i) then return true; fi;
    od;
    return false;
  end;

  ORDER_USING_SECTIONS_LOCAL:=function(g)
    local i,el,orb,Orbs,res,st,reduced_word,loc_order;
    if IsOne(g) then return 1; fi;
    for i in [1..Length(cur_list)] do
      el:=cur_list[i];
      if (AreConjugateUsingSmallRels(g!.word, el!.word) or AreConjugateUsingSmallRels((g!.word)^(-1), el!.word)) then
        if Product(degs{[i..Length(degs)]})>1 then
          Info(InfoAutomata,3,"(",a!.word,")^",Product(degs{[1..i-1]})," has ", el!.word, " as a section at vertex ",vertex{[1..i-1]});
          Info(InfoAutomata,3,"(",el!.word,")^",Product(degs{[i..Length(degs)]})," has congutate of ",g!.word, " as a section at vertex ",vertex{[i..Length(degs)]});
          SetIsFinite(GroupOfAutomFamily(FamilyObj(a)),false);
          return infinity;
        else
#          Info(InfoAutomata,3,"The group <G> might not be contracting, ",g," has itself as a section.");
          return 1;
        fi;
      fi;
    od;
    if Length(cur_list)>=max_depth then return fail; fi;
    Add(cur_list,g);
    Orbs:=OrbitsPerms([g!.perm],[1..g!.deg]);
    loc_order:=1;

    for orb in Orbs do
      Add(degs,Length(orb));
      Add(vertex,orb[1]);
#      res:=ORDER_USING_SECTIONS_LOCAL(Autom(CyclicallyReducedWord(State(g^Length(orb),orb[1])!.word),FamilyObj(g)));
#      Print(g^Length(orb),"\n");
      st:=State(g^Length(orb),orb[1]);
      reduced_word:=AssocWordByLetterRep(FamilyObj(st!.word),CyclicallyReduce(LetterRepAssocWord(st!.word)));
#      Print(st!.word," at ",vertex,"\n");
      res:=ORDER_USING_SECTIONS_LOCAL(Autom(reduced_word,FamilyObj(g)));
      if res=infinity or res=fail then return res; fi;
      loc_order:=Lcm(loc_order,res*Length(orb));
      Unbind(degs[Length(degs)]);
      Unbind(vertex[Length(vertex)]);
    od;
    Unbind(cur_list[Length(cur_list)]);
    return loc_order;
  end;

  F:=FamilyObj(a)!.freegroup;
  gens_ord2:=GeneratorsOfOrderTwo(FamilyObj(a));
  cur_list:=[];
# degs traces at what positions we raise to what power
  degs:=[]; vertex:=[];
  res:=ORDER_USING_SECTIONS_LOCAL(a);
  if res=infinity then
    SetIsFinite(GroupOfAutomFamily(FamilyObj(a)),false);
    SetOrder(a,infinity);
  fi;
  return res;
end);



################################################################################
##
#F SUSPICIOUS_FOR_NONCONTRACTION   returns 'true' if there is a vertex v,
##                                        such that a(v)=v, a|_v=a or a|_v=a^-1
InstallGlobalFunction(SUSPICIOUS_FOR_NONCONTRACTION, function(a)
  local SUSPICIOUS_FOR_NONCONTRACTION_LOCAL, cur_list, F, vertex;

  SUSPICIOUS_FOR_NONCONTRACTION_LOCAL:=function(g)
  local i,res;
    if IsOne(g) or g!.perm<>() then return false; fi;

    if (g!.word in cur_list) or (g!.word^(-1) in cur_list) then
      if g=a or g=a^-1 then
        Info(InfoAutomata,3,a!.word," has ",g!.word," as a section at vertex ",vertex);
        return true;
      else return false;  fi;
    fi;

    Add(cur_list,g!.word);

    for i in [1..FamilyObj(a)!.deg] do
      Add(vertex,i);
      res:=SUSPICIOUS_FOR_NONCONTRACTION_LOCAL(State(g,i));
      if res then return true; fi;
      Unbind(vertex[Length(vertex)]);
    od;
    return false;
  end;

  F:=FamilyObj(a)!.freegroup;
  cur_list:=[];
# degs traces at what positions we raise to what power
  vertex:=[];
  return SUSPICIOUS_FOR_NONCONTRACTION_LOCAL(a);
end);



################################################################################
##
#F  FindGroupElement (<G>, <func>, <val>, <max_len>)
#F  FindGroupElements (<G>, <func>, <val>, <max_len>)
##
##  The first function enumerates elements of the group <G> until it finds
##  an element 'g' of length at most <max_len>, for which <func>'(g)'=<val>. Returns 'g'.
##
##  The second function enumerates elements of the group of length at most <max_len>
##  and returns the list of elements 'g', for which <func>'(g)'=<val>.
##
##  The following examlpe illustrates how one can find an element of order 16 in
##  Grigorchuk group and the list of all such elements of length at most 5.
##  \beginexample
##  gap> HasOrder16:=function(g)
##  > if IsOne(g^16) and not IsOne(g^8) then return true; else return false; fi;
##  > end;
##  function( g ) ... end
##  gap> FindGroupElement(GrigorchukGroup,HasOrder16,true,5);
##  a*b
##  gap> FindGroupElements(GrigorchukGroup,HasOrder16,true,5);
##  [ a*b, b*a, c*a*d, d*a*c, a*b*a*d, a*c*a*d, a*d*a*b, a*d*a*c, b*a*d*a, c*a*d*a, d*a*b*a, d*a*c*a,
##    a*c*a*d*a, a*d*a*c*a, b*a*b*a*c, b*a*c*a*c, c*a*b*a*b, c*a*c*a*b ]
##  \endexample
##
InstallGlobalFunction(FindGroupElement,function(G,func,val,n)
  local ElList,GrList,i,j,orig_gens,gen,gens,new_gen,g,len,viewed,oldgr,New,k;

  if func(One(G))=val then return One(G); fi;

  orig_gens:=ShallowCopy(GeneratorsOfSemigroup(G));
  gens:=[];

# select pairwise different generators
  for i in [1..Length(orig_gens)] do
    if not IsOne(orig_gens[i]) then
      new_gen:=true;
      for j in [1..i-1] do if orig_gens[i]=orig_gens[j] then new_gen:=false; fi; od;
      if new_gen then Add(gens,orig_gens[i]); fi;
    fi;
  od;

  for g in gens do
    if func(g)=val then return g; fi;
  od;

  ElList:=[One(G)]; Append(ElList,ShallowCopy(gens));
  GrList:=[1,Length(gens)+1];
  len:=1;

  while len<n and GrList[len]<>GrList[len+1] do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for gen in gens do
        g:=ElList[i]*gen;
#       Print("g=",g,"\n\n");
        New:=true;
        if len=1 then k:=1; else k:=GrList[len-1]; fi;
        while New and k<=oldgr do
#          Print(g*ElList[k]^-1,"\n");
          if IsOne(g*ElList[k]^-1) then New:=false; fi;
          k:=k+1;
        od;
        if New then
          if func(g)=val then return g; fi;
          Add(ElList,g);
        fi;
      od;
    od;
    Add(GrList,Length(ElList));
    Info(InfoAutomata,3,"Length not greater than ",len+1,": ",Length(ElList));
    len:=len+1;
  od;
  if GrList[len]=GrList[len+1] then
    SetSize(G,GrList[len]);
  fi;
  return fail;
end);


InstallGlobalFunction(FindGroupElements,function(G,func,val,n)
  local ElList,GrList,i,j,orig_gens,gen,gens,new_gen,g,len,viewed,oldgr,New,k,cur_els;

  orig_gens:=ShallowCopy(GeneratorsOfSemigroup(G));
  gens:=[];
  cur_els:=[];

# select pairwise different generators
  for i in [1..Length(orig_gens)] do
    if not IsOne(orig_gens[i]) then
      new_gen:=true;
      for j in [1..i-1] do if orig_gens[i]=orig_gens[j] then new_gen:=false; fi; od;
      if new_gen then Add(gens,orig_gens[i]); fi;
    fi;
  od;

  if func(One(G))=val then Add(cur_els,One(G)); fi;
  for g in gens do
    if func(g)=val then Add(cur_els,g); fi;
  od;

  ElList:=[One(G)]; Append(ElList,ShallowCopy(gens));
  GrList:=[1,Length(gens)+1];
  len:=1;

  while len<n and GrList[len]<>GrList[len+1] do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for gen in gens do
        g:=ElList[i]*gen;
        New:=true;
        if len=1 then k:=1; else k:=GrList[len-1]; fi;
        while New and k<=oldgr do
          if IsOne(g*ElList[k]^-1) then New:=false; fi;
          k:=k+1;
        od;
        if New then
          if func(g)=val then
            Add(cur_els,g);
            Info(InfoAutomata,3,g!.word);
          fi;
          Add(ElList,g);
        fi;
      od;
    od;
    Add(GrList,Length(ElList));
    Info(InfoAutomata,3,"Length not greater than ",len+1,": ",Length(ElList));
    len:=len+1;
  od;
  if GrList[len]=GrList[len+1] then
    SetSize(G,GrList[len]);
  fi;
  return cur_els;
end);



################################################################################
##
#F  FindElementOfInfiniteOrder (<G>, <max_len>, <depth>)
#F  FindElementsOfInfiniteOrder (<G>, <max_len>, <depth>)
##
##  The first function enumerates elements of the group <G> up to length <max_len>
##  until it finds an element 'g' of infinite order, such that
##  '"ORDER_USING_SECTIONS"(g,<depth>)' is 'infinity'.
##  In other words all sections of every element up to depth <depth> are
##  investigated. In case if the element belongs to the group generated by bounded
##  automaton (see "IsGeneratedByBoundedAutomaton") one can set <depth> to be 'infinity'.
##
##  The second function returns the list of all such elements up to length <max_len>.
##
##  \beginexample
##  gap> G:=AutomGroup("a=(1,1)(1,2),b=(a,c),c=(b,1)");
##  < a, b, c >
##  gap> FindElementOfInfiniteOrder(G,5,10);
##  a*b*c
##  \endexample
##
InstallGlobalFunction(FindElementOfInfiniteOrder,function(G,n,depth)
  local CheckOrder, res;

  if HasIsFinite(G) and IsFinite(G) then return fail; fi;

  CheckOrder:=function(g) return ORDER_USING_SECTIONS(g,depth); end;
  res:=FindGroupElement(G,CheckOrder,infinity,n);
  if res<>fail then SetIsFinite(G,false); fi;
  return res;
end);

InstallGlobalFunction(FindElementsOfInfiniteOrder,function(G,n,depth)
  local CheckOrder, res;

  if HasIsFinite(G) and IsFinite(G) then return []; fi;

  CheckOrder:=function(g) return ORDER_USING_SECTIONS(g,depth); end;
  res:=FindGroupElements(G,CheckOrder,infinity,n);
  if res<>[] then SetIsFinite(G,false); fi;
  return res;
end);



################################################################################
##
#F  IsNoncontracting (<G>, <max_len>, <depth>)
##
##  Tries to show that the group <G> is not contracting.
##  Enumerates the elements of the group <G> up to length <max_len>
##  until it finds an element, which has a section 'g' of infinite order, such that
##  '"ORDER_USING_SECTIONS"(g,<depth>)' is 'infinity' and such that 'g'
##  stabilizes some vertex and has itself as a section at this vertex.
##  See also '"IsContracting"'.
##
##  \beginexample
##  gap> G:=AutomGroup("a=(b,a)(1,2),b=(c,b)(),c=(c,a)");
##  < a, b, c >
##  gap> IsNoncontracting(G,10,10);
##  true
##  \endexample

InstallGlobalFunction(IsNoncontracting,function(G,n,depth)
  local IsNoncontrElement, res;
  IsNoncontrElement:=function(g)
    if SUSPICIOUS_FOR_NONCONTRACTION(g) then
      return ORDER_USING_SECTIONS(g,depth)=infinity;
    fi;
    return false;
  end;

  if HasIsContracting(G) and IsContracting(G) then return false; fi;

  res:=FindGroupElement(G,IsNoncontrElement,true,n);
  if res<>fail then
    SetIsFinite(G,false);
    SetIsContracting(G,false);
    return true;
  fi;
  return fail;
end);





################################################################################
##
#F OrdersOfGroupElementsMain . . . . . Enumerates all elements of a self-similar
##             group up to length n and tries to find their orders up to order O
##                  returns true if all the orders are finite and fail otherwise
##         in case stop=true returns fail as soon as it finds suspicious element

InstallGlobalFunction(OrdersOfGroupElementsMain,function(n,O,stop,G)
  local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,inverse,H, periodic, order_v;

  inverse:=function(w)
    local i, iw;
    iw:=[];
    for i in [1..Length(w)] do
      iw[i]:=w[Length(w)-i+1]^inv;
    od;
    return iw;
  end;

  gr:=1; len:=1; periodic:=true;

  H:=AddInverses(G);
  if G<>H then
    Info(InfoAutomata, 3, "Inverses were added. Automaton was minimized. Now generator set is:\n",H);
    G:=H;
  fi;
  inv:=InversePerm(G);
  GrList:=[1,Length(G)];
  ElList:=[];
  for i in [1..Length(G)] do
    Add(ElList,[i]);
  od;

  for v in ElList do
    order_v:=ORDER_OF_ELEMENT(v,G,O);
    Info(InfoAutomata, 3, "Order of ", v, ": ", order_v);
    if order_v = fail then
      if stop then return fail;
        else periodic:=fail;
      fi;
    fi;
  od;

  while len<n do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for j in [2..Length(G)] do
        v:=StructuralCopy(ElList[i]);
        Add(v,j);
        New:=true;
        if len=1 then k:=1; else k:=GrList[len-1]; fi;
        while New and k<=oldgr do
          tmpv:=StructuralCopy(v);
          Append(tmpv,inverse(ElList[k]));
          if IS_ONE_LIST(tmpv,G) then New:=false; fi;
          k:=k+1;
        od;
        if New then
          Add(ElList,v);
          order_v:=ORDER_OF_ELEMENT(v,G,O);
          Info(InfoAutomata, 3, "Order of ", v, ": ", order_v);

          if order_v = fail then
            if stop then return fail;
              else periodic:=fail;
            fi;
          fi;

        fi;
      od;
    od;
    Add(GrList,Length(ElList));
#    Print("Length not greater than ",len+1,": ",Length(ElList),"\n");
    len:=len+1;
  od;

  return periodic;
end);





################################################################################
##
#F OrdersOfGroupElements . . . . . . . Enumerates all elements of a self-similar
##             group up to length n and tries to find their orders up to order O
##                  returns true if all the orders are finite and fail otherwise

InstallGlobalFunction(OrdersOfGroupElements,function(n,O,G)
  return OrdersOfGroupElementsMain(n,O,false,G);
end);


################################################################################
##
#F PeriodicityGuess. . . . . . . . . . Enumerates all elements of a self-similar
##             group up to length n and tries to find their orders up to order O
##                  returns true if all the orders are finite and fail otherwise
##                           returns fail as soon as it finds suspicious element

InstallGlobalFunction(PeriodicityGuess,function(n,O,G)
  return OrdersOfGroupElementsMain(n,O,true,G);
end);


################################################################################
##
#F FindTransitiveElements . . . . . . .Finds all elements of a group G which are
##                      transitive on a level lev and have length no more than n
##                in case stop=true stops when it finds first transitive element

InstallGlobalFunction(FindTransitiveElements,function(n,lev,stop,G)
  local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,inverse,H, TransElList;

  inverse:=function(w)
    local i, iw;
    iw:=[];
    for i in [1..Length(w)] do
      iw[i]:=w[Length(w)-i+1]^inv;
    od;
    return iw;
  end;

  gr:=1; len:=1;

  H:=AddInverses(G);
  if G<>H then
    Info(InfoAutomata, 3, "Inverses were added. Automaton was minimized. Now generator set is:\n",H);
    G:=H;
  fi;
  inv:=InversePerm(G);
  GrList:=[1,Length(G)];
  ElList:=[];
  TransElList:=[];

  for i in [1..Length(G)] do
    Add(ElList,[i]);
  od;

  for v in ElList do
    if _IsWordTransitiveOnLevel(G,v,lev) then
      if stop then return v;
        else Add(TransElList,v);
      fi;
    fi;
  od;

  while len<n do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for j in [2..Length(G)] do
        v:=StructuralCopy(ElList[i]);
        Add(v,j);
        New:=true;
        if len=1 then k:=1; else k:=GrList[len-1]; fi;
        while New and k<=oldgr do
          tmpv:=StructuralCopy(v);
          Append(tmpv,inverse(ElList[k]));
          if IS_ONE_LIST(tmpv,G) then New:=false; fi;
          k:=k+1;
        od;
        if New then
          Add(ElList,v);

          if _IsWordTransitiveOnLevel(G,v,lev) then
            if stop then return v;
              else Add(TransElList,v);
            fi;
          fi;

        fi;
      od;
    od;
    Add(GrList,Length(ElList));
#    Print("Length not greater than ",len+1,": ",Length(ElList),"\n");
    len:=len+1;
  od;

  return TransElList;
end);


################################################################################
##
#P  IsGeneratedByAutomatonOfPolynomialGrowth (<G>)
##
##  For a group <G> generated by all states of finite automaton (see "IsAutomatonGroup")
##  determines whether this automaton has polynomial growth in terms of Sidki~\cite{sidki:acyclic}.
##
##  See also '"IsGeneratedByBoundedAutomaton"' and '"PolynomialDegreeOfGrowthOfAutomaton"'.
##  \beginexample
##  gap> B:=AutomGroup("a=(b,1)(1,2),b=(a,1)");
##  < a, b >
##  gap> IsGeneratedByAutomatonOfPolynomialGrowth(B);
##  true
##  gap> D:=AutomGroup("a=(a,b)(1,2),b=(b,a)");
##  < a, b >
##  gap> IsGeneratedByAutomatonOfPolynomialGrowth(D);
##  false
##
InstallMethod(IsGeneratedByAutomatonOfPolynomialGrowth,"IsGeneratedByAutomatonOfPolynomialGrowth(IsAutomatonGroup)",true,
              [IsAutomatonGroup],
function(G)
  local i,d,ver,nstates,cycles,cycle_of_vertex, IsNewCycle,known_vertices,aut_list,HasPolyGrowth,cycle_order,next_cycles,cur_cycles,cur_path,cycles_of_level,lev;

  IsNewCycle:=function(C)
    local i, l, cur_cycle, long_cycle;
    l:=[2..Length(C)];
    Add(l,1);
    long_cycle:=PermList(l);

    for cur_cycle in cycles do
      if Intersection(cur_cycle,C)<>[] then
#        if Length(C)<>Length(cur_cycle) then return fail; fi;
#        for i in [0..Length(C)-1] do
#          if cur_cycle=Permuted(C,long_cycle^i) then return false; fi;
#        od;
        Info(InfoAutomata,5,"cycle1=",cur_cycle,"cycle2=",C);
        return fail;
      fi;
    od;
    return true;
  end;

#  Example:
#  cycles = [[1,2,4],[3,5,6],[7]]
#  cur_cycles = [1,3] (the first and the third cycles)
#  cycle_order = [[2,3],[3],[]] (means 1->2->3,  1->3)

  HasPolyGrowth:=function(v)
    local i,v_next,is_new,C,ver;
#    Print("v=",v,"\n");
    Add(cur_path,v);
    for i in [1..d] do
      v_next:=aut_list[v][i];
      if not (v_next in known_vertices or v_next=2*nstates+1) then
        if v_next in cur_path then
          C:=cur_path{[Position(cur_path,v_next)..Length(cur_path)]};
          is_new:=IsNewCycle(C);
          if is_new=fail then
            return false;
          else
            Add(cycles,C);
            Add(cycle_order,[]);
            for ver in C do
#              Print("next_cycles = ",next_cycles);
              UniteSet(cycle_order[Length(cycles)],next_cycles[ver]);
              cycle_of_vertex[ver]:=Length(cycles);
              next_cycles[ver]:=[Length(cycles)];
            od;
          fi;
        else
          if not HasPolyGrowth(v_next) then
            return false;
          fi;
          if cycle_of_vertex[v]=0 then
            UniteSet(next_cycles[v],next_cycles[v_next]);
          elif cycle_of_vertex[v]<>cycle_of_vertex[v_next] then
            UniteSet(cycle_order[cycle_of_vertex[v]],next_cycles[v_next]);
            Info(InfoAutomata,5,"v=",v,"; v_next=",v_next);
            Info(InfoAutomata,5,"cycle_order (local) = ",cycle_order);
          fi;
        fi;
      elif v_next in known_vertices then
        if cycle_of_vertex[v]=0 then
          UniteSet(next_cycles[v],next_cycles[v_next]);
        elif cycle_of_vertex[v]=cycle_of_vertex[v_next] then
          return false;
        else
          UniteSet(cycle_order[cycle_of_vertex[v]],next_cycles[v_next]);
        fi;

      fi;
    od;
    Remove(cur_path);
    Add(known_vertices,v);
    return true;
  end;

  nstates:=UnderlyingAutomFamily(G)!.numstates;
  aut_list:=AutomatonList(G);
  d:=UnderlyingAutomFamily(G)!.deg;
  cycles:=[];
  cycle_of_vertex:=List([1..nstates],x->0);  #if vertex i is in cycle j, then cycle_of_vertex[i]=j
  next_cycles:=List([1..nstates],x->[]); #if vertex i is not in a cycle, next_cycles[i] stores the list of cycles, that can be reached immediately (with no cycles in between) from this vertex
  known_vertices:=[];
  cur_path:=[];
  cycle_order:=[];

  while Length(known_vertices)<nstates do
    ver:=Difference([1..nstates],known_vertices)[1];
    if not HasPolyGrowth(ver) then
      SetIsGeneratedByBoundedAutomaton(G,false);
      return false;
    fi;
  od;

# Now we find the longest chain in the poset of cycles
  cycles_of_level:=[[]];
  for i in [1..Length(cycles)] do
    if cycle_order[i]=[] then Add(cycles_of_level[1],i); fi;
  od;

  lev:=1;

  while cycles_of_level[Length(cycles_of_level)]<>[] do
    Add(cycles_of_level,[]);
    for i in [1..Length(cycles)] do
      if Intersection(cycles_of_level[lev],cycle_order[i])<>[] then
        Add(cycles_of_level[lev+1],i);
      fi;
    od;
    lev:=lev+1;
  od;

  if lev=2 then
    SetIsGeneratedByBoundedAutomaton(G,true);
    SetIsAmenable(G,true);
  elif lev=1 then
    SetIsGeneratedByBoundedAutomaton(G,true);
    SetIsFinite(G,true);
  else
    SetIsGeneratedByBoundedAutomaton(G,false);
  fi;
  SetPolynomialDegreeOfGrowthOfAutomaton(G,lev-2);
  Info(InfoAutomata,5,"Cycles = ", cycles);
  Info(InfoAutomata,5,"cycle_order = ", cycle_order);
  Info(InfoAutomata,5,"next_cycles = ", next_cycles);
  return true;
end);


################################################################################
##
#P  IsGeneratedByBoundedAutomaton (<G>)
##
##  For a group <G> generated by all states of finite automaton (see "IsAutomatonGroup")
##  determines whether this automaton is bounded in terms of Sidki~\cite{sidki:acyclic}.
##
##  See also '"IsGeneratedByAutomatonOfPolynomialGrowth"' and '"PolynomialDegreeOfGrowthOfAutomaton"'.
##  \beginexample
##  gap> B:=AutomGroup("a=(b,1)(1,2),b=(a,1)");
##  < a, b >
##  gap> IsGeneratedByBoundedAutomaton(B);
##  true
##  gap> C:=AutomGroup("a=(a,b)(1,2),b=(b,c),c=(c,1)(1,2)");
##  < a, b >
##  gap> IsGeneratedByBoundedAutomaton(C);
##  false
##
InstallMethod(IsGeneratedByBoundedAutomaton,"IsGeneratedByBoundedAutomaton(IsAutomatonGroup)",true,
              [IsAutomatonGroup],
function(G)
  local res;
  res:=IsGeneratedByAutomatonOfPolynomialGrowth(G);
  return IsGeneratedByBoundedAutomaton(G);
end);


################################################################################
##
#P  PolynomialDegreeOfGrowthOfAutomaton (<G>)
##
##  For a group <G> generated by all states of finite automaton (see "IsAutomatonGroup")
##  of polynomial growth in terms of Sidki~\cite{sidki:acyclic} determines the degree of
##  polynomial growth of this automaton. This degree is 0 if and only if automaton is bounded.
##  If the growth of automaton is exponential returns 'fail'.
##
##  See also '"IsGeneratedByAutomatonOfPolynomialGrowth"' and '"IsGeneratedByBoundedAutomaton"'.
##  \beginexample
##  gap> B:=AutomGroup("a=(b,1)(1,2),b=(a,1)");
##  < a, b >
##  gap> PolynomialDegreeOfGrowthOfAutomaton(B);
##  0
##  gap> C:=AutomGroup("a=(a,b)(1,2),b=(b,c),c=(c,1)(1,2)");
##  < a, b >
##  gap> PolynomialDegreeOfGrowthOfAutomaton(C);
##  2
##
InstallMethod(PolynomialDegreeOfGrowthOfAutomaton,"PolynomialDegreeOfGrowthOfAutomaton(IsAutomatonGroup)",true,
              [IsAutomatonGroup],
function(G)
  local res;
  res:=IsGeneratedByAutomatonOfPolynomialGrowth(G);
  if not res then
    Info(InfoAutomata,"Error: the automaton generating <G> has exponenetial growth");
    return fail;
  fi;
  return PolynomialDegreeOfGrowthOfAutomaton(G);
end);


################################################################################
##
#A  IsAmenable (<G>)
##
##  In certain cases (for groups generated by bounded automata~\cite{bknv:amenab},
##  some virtually abelian groups or finite groups) returns 'true' if <G> is amenable.
##
InstallMethod(IsAmenable,"IsAmenable(IsAutomGroup)",true,
              [IsAutomGroup],
function(G)
  if HasIsFinite(G) and IsFinite(G) then return true; fi;
  if IsGeneratedByBoundedAutomaton(GroupOfAutomFamily(G)) then return true; fi;
  if IsAutomatonGroup(G) and IsAbelian(StabilizerOfLevel(G,2)) then return true; fi;
  TryNextMethod();
end);


#E
