#############################################################################
##
#W  automatagroup.gd           automata package                Yevgen Muntyan
#W                                                             Dmytro Savchuk
##  automata v 0.91 started June 07 2004
##

Revision.automatagroup_gd :=
  "@(#)$Id$";


###############################################################################
##
#C  IsAutomataGroup
##
##  IsAutomataGroup is a category parent for all automata group categories.
##
##  IsCollection is needed to install UseSubsetRelation.
##
DeclareCategory("IsAutomataGroup", IsAutomatonObject and IsCollection);


###############################################################################
##
#A  AutomatonListInitialStatesGenerators (<G>)
##
##  Numbers of initial states in the AutomatonList(G).
##
DeclareAttribute( "AutomatonListInitialStatesGenerators",
                  IsAutomataGroup, "mutable" );


###############################################################################
##
#P  IsSelfSimilar (<G>)
#A  GeneratingAutomaton (<G>)
##
##  SelfSimilar means that G < G\wreath S_d - state closed.
##  GeneratingAutomatonList is a list representing automaton such that G is
##  generated by all its states.
##
DeclareProperty("IsSelfSimilar", IsAutomataGroup);
DeclareAttribute("GeneratingAutomatonList", IsAutomataGroup, "mutable");
DeclareFilter("CanEasilyTestSelfSimilarity");
InstallTrueMethod(CanEasilyTestSelfSimilarity, IsSelfSimilar);


###############################################################################
##
#P  IsFractal (<G>)
#P  IsContracting (<G>)
#P  IsFreeNonabelian (<G>)
#P  IsFreeAbelian (<G>)
##
##  Fractal means that St_G(x) > G for any x\in X and G is spherically
##  transitive.
##  Trivial group is not IsFreeAbelian nor FreeNonabelian.
##
DeclareProperty("IsFractal", IsAutomataGroup);
DeclareProperty("IsContracting", IsAutomataGroup);
DeclareProperty("IsFreeNonabelian", IsAutomataGroup);
DeclareProperty("IsFreeAbelian", IsAutomataGroup);
DeclareFilter("CanEasilyTestFractalness");
DeclareFilter("CanEasilyTestContractingProperty");
DeclareFilter("CanEasilyTestBeingFreeNonabelian");
DeclareFilter("CanEasilyTestBeingFreeAbelian");
DeclareFilter("CanEasilyComputeSize");


###############################################################################
##
#A  StabilizerOfFirstLevel (<G>)
#O  StabilizerOfLevel (<G>, <k>)
#O  StabilizerOfVertex (<G>, <vertex>)
##
DeclareAttribute("StabilizerOfFirstLevel", IsAutomataGroup);
KeyDependentOperation("StabilizerOfLevel", IsAutomataGroup, IsPosInt, ReturnTrue);
DeclareOperation("StabilizerOfVertex", [IsAutomataGroup, IsList]);


###############################################################################
##
#O  PermGroupOnLevel (<G>, <k>)
##
KeyDependentOperation("PermGroupOnLevel", IsAutomataGroup, IsPosInt, ReturnTrue);


###############################################################################
##
#O  LowerCentralSeriesOnLevel (<G>, <k>)
#O  PCentralSeriesOnLevel (<G>, <k>)
#O  JenningsSeriesOnLevel (<G>, <k>)
#O  LowerCentralSeriesRanksOnLevel (<G>, <k>)
#O  PCentralSeriesRanksOnLevel (<G>, <k>)
#O  JenningsSeriesRanksOnLevel (<G>, <k>)
##
KeyDependentOperation("LowerCentralSeriesOnLevel",
                      IsAutomataGroup, IsPosInt, ReturnTrue);
KeyDependentOperation("PCentralSeriesOnLevel",
                      IsAutomataGroup, IsPosInt, ReturnTrue);
KeyDependentOperation("JenningsSeriesOnLevel",
                      IsAutomataGroup, IsPosInt, ReturnTrue);
KeyDependentOperation("LowerCentralSeriesRanksOnLevel",
                      IsAutomataGroup and IsActingOnBinaryTree,
                      IsPosInt, ReturnTrue);
KeyDependentOperation("PCentralSeriesRanksOnLevel",
                      IsAutomataGroup and IsActingOnBinaryTree,
                      IsPosInt, ReturnTrue);
KeyDependentOperation("JenningsSeriesRanksOnLevel",
                      IsAutomataGroup and IsActingOnBinaryTree,
                      IsPosInt, ReturnTrue);


#E
#############################################################################
##
#W  automatagroup.gi           automata package                Yevgen Muntyan
#W                                                             Dmytro Savchuk
##
##  automata v 0.91 started June 07 2004
##

Revision.automatagroup_gi :=
  "@(#)$Id$";


###############################################################################
##
#M  UseSubsetRelation(<super>, <sub>)
##
InstallMethod(UseSubsetRelation, "method for two IsAutomataGroup's",
              [IsAutomataGroup, IsAutomataGroup],
function(super, sub)
  if HasIsFreeAbelian(super) then
    if IsFreeAbelian(super) then
      if not IsTrivial(sub) then SetIsFreeAbelian(sub, true); fi;
    else
      SetIsFreeAbelian(sub, false);
    fi;
  fi;

  if HasIsFreeNonabelian(super) then
    if IsFreeNonabelian(super) then
      if not IsTrivial(sub) then SetIsFreeNonabelian(sub, true); fi;
    else
      SetIsFreeNonabelian(sub, false);
    fi;
  fi;

  if HasIsSphericallyTransitive(super) then
    if not IsSphericallyTransitive(super) then
      SetIsSphericallyTransitive(sub, false); fi; fi;

  TryNextMethod();
end);


###############################################################################
##
#M  IsActingOnBinaryTree(<G>)
##
# InstallImmediateMethod(IsActingOnBinaryTree, IsAutomataGroup, 0,
# function(G)
#   return DegreeOfTree(G) = 2;
# end);


###############################################################################
##
#M  IsSphericallyTransitive (<G>)
#M  CanEasilyTestSphericalTransitivity (<G>)
##
##  Fractalness implies spherical transitivity.
##
InstallTrueMethod(IsSphericallyTransitive, IsFractal);
InstallTrueMethod(CanEasilyTestSphericalTransitivity, HasIsSphericallyTransitive);

InstallImmediateMethod(IsSphericallyTransitive, HasSize, 0,
function(G)
  if IsFinite(G) then return false; fi;
  TryNextMethod();
end);


###############################################################################
##
#M  IsFractal (<G>)
#M  CanEasilyTestFractalness (<G>)
##
##  Fractalness implies spherical transitivity, hence not spherical transitive
##  group isn't fractal.
##
InstallTrueMethod(CanEasilyTestFractalness, HasIsFractal);

InstallImmediateMethod(IsFractal, HasIsSphericallyTransitive, 0,
function(G)
  if not IsSphericallyTransitive(G) then return false; fi;
  TryNextMethod();
end);

InstallImmediateMethod(IsFractal, HasIsFinite, 0,
function(G)
  if IsFinite(G) then return false; fi;
  TryNextMethod();
end);


###############################################################################
##
#M  CanEasilyTestSelfSimilarity (<G>)
##
InstallTrueMethod(CanEasilyTestSelfSimilarity, HasIsSelfSimilar);


###############################################################################
##
#M  IsFreeNonabelian (<G>)
#M  CanEasilyTestBeingFreeNonabelian (<G>)
##
InstallTrueMethod(CanEasilyTestBeingFreeNonabelian, HasIsFreeNonabelian);

InstallImmediateMethod(IsFreeNonabelian, HasIsAbelian, 0,
function(G)
  if IsAbelian(G) then return false; fi;
  TryNextMethod();
end);

InstallImmediateMethod(IsFreeNonabelian, HasIsFinite, 0,
function(G)
  if IsFinite(G) then return false; fi;
  TryNextMethod();
end);


###############################################################################
##
#M  IsFreeAbelian (<G>)
#M  CanEasilyTestBeingFreeAbelian (<G>)
##
InstallTrueMethod(CanEasilyTestBeingFreeAbelian, HasIsFreeAbelian);

InstallImmediateMethod(IsFreeAbelian, HasIsAbelian, 0,
function(G)
  if not IsAbelian(G) then return false; fi;
  TryNextMethod();
end);

InstallImmediateMethod(IsFreeAbelian, HasIsFinite, 0,
function(G)
  if IsFinite(G) then return false; fi;
  TryNextMethod();
end);


###############################################################################
##
#M  Size (<G>)
#M  CanEasilyComputeSize (<G>)
##
InstallTrueMethod(CanEasilyComputeSize, HasSize);

InstallImmediateMethod(Size, HasIsFractal, 0,
function(G)
  if IsFractal(G) then return infinity; fi;
  TryNextMethod();
end);

InstallImmediateMethod(Size, HasIsSphericallyTransitive, 0,
function(G)
  if IsSphericallyTransitive(G) then return infinity; fi;
  TryNextMethod();
end);

InstallImmediateMethod(Size, HasIsFreeAbelian, 0,
function(G)
  if IsFreeAbelian(G) then return infinity; fi;
  TryNextMethod();
end);

InstallImmediateMethod(Size, HasIsFreeNonabelian, 0,
function(G)
  if IsFreeNonabelian(G) then return infinity; fi;
  TryNextMethod();
end);


###############################################################################
##
#M  PermGroupOnLevelOp (<G>, <k>)
##
InstallMethod(PermGroupOnLevelOp, "method for two IsAutomataGroup and IsPosInt",
              [IsAutomataGroup, IsPosInt],
function(G, k)
  local gens, a, pgens, pgroup;
  gens := GeneratorsOfGroup(G);
  if gens = [] then return Group(()); fi;
  pgens := [];
  for a in gens do
    Add(pgens, PermOnLevel(a, k));
  od;
  pgroup := Group(pgens);

  if IsActingOnBinaryTree(G) then
    SetIsPGroup(pgroup, true);
    if IsTrivial(pgroup) then
      SetPrimePGroup(pgroup, fail);
    else
      SetPrimePGroup(pgroup, 2);
    fi;
  fi;

  return pgroup;
end);


###############################################################################
##
#M  LowerCentralSeriesOnLevelOp (<G>, <k>)
#M  PCentralSeriesOnLevelOp (<G>, <k>)
#M  JenningsSeriesOnLevelOp (<G>, <k>)
##
InstallMethod(LowerCentralSeriesOnLevelOp, "method for IsAutomataGroup",
              [IsAutomataGroup, IsPosInt],
function(G, k)
  local pgroup;
  pgroup := PermGroupOnLevel(G, k);
  return LowerCentralSeriesOfGroup(pgroup);
end);

InstallMethod(PCentralSeriesOnLevelOp, "method for IsAutomataGroup",
              [IsAutomataGroup, IsPosInt],
function(G, k)
  local pgroup;
  pgroup := PermGroupOnLevel(G, k);
  return PCentralSeries(pgroup);
end);

InstallMethod(JenningsSeriesOnLevelOp, "method for IsAutomataGroup",
              [IsAutomataGroup, IsPosInt],
function(G, k)
  local pgroup;
  pgroup := PermGroupOnLevel(G, k);
  return JenningsSeries(pgroup);
end);


###############################################################################
##
#M  LowerCentralSeriesRanksOnLevelOp (<G>, <k>)
#M  PCentralSeriesRanksOnLevelOp (<G>, <k>)
#M  JenningsSeriesRanksOnLevelOp (<G>, <k>)
##
InstallMethod(LowerCentralSeriesRanksOnLevelOp,
              "method for IsAutomataGroup",
              [IsAutomataGroup and IsActingOnBinaryTree, IsPosInt],
function(G, k)
  local series, ranks;
  series := LowerCentralSeriesOnLevel(G, k);
  return List([1..Length(series)-1],
              i -> Log2Int(Size(series[i])/Size(series[i+1])));
end);

InstallMethod(PCentralSeriesRanksOnLevelOp,
              "method for IsAutomataGroup",
              [IsAutomataGroup and IsActingOnBinaryTree, IsPosInt],
function(G, k)
  local series, ranks;
  series := PCentralSeriesOnLevel(G, k);
  return List([1..Length(series)-1],
              i -> Log2Int(Size(series[i])/Size(series[i+1])));
end);

InstallMethod(JenningsSeriesRanksOnLevelOp,
              "method for IsAutomataGroup",
              [IsAutomataGroup and IsActingOnBinaryTree, IsPosInt],
function(G, k)
  local series, ranks;
  series := JenningsSeriesOnLevel(G, k);
  return List([1..Length(series)-1],
              i -> Log2Int(Size(series[i])/Size(series[i+1])));
end);


###############################################################################
##
#M  FixesLevel(<G>, <k>)
##
InstallMethod(FixesLevel, "method for IsAutomataGroup and IsPosInt",
              [IsAutomataGroup, IsPosInt],
function(G, k)
  return IsTrivial(PermGroupOnLevel(G, k));
end);


###############################################################################
##
#M  FixesVertex(<G>, <v>)
##
InstallOtherMethod(FixesVertex, "method for IsAutomataGroup and IsPosInt",
                   [IsAutomataGroup, IsObject],
function(G, v)
  local gens, g;
  gens := GeneratorsOfGroup(G);
  for g in gens do
    if not FixesVertex(g, v) then return false; fi;
  od;
  return true;
end);


#E
#############################################################################
##
#W  automaton.gd               automata package                Yevgen Muntyan
#W                                                             Dmytro Savchuk
##  automata v 0.91 started June 07 2004
##

Revision.automaton_gd :=
  "@(#)$Id$";


###############################################################################
##
#C  IsAutomaton
#C  IsAutomatonFamily
#C  IsAutomatonCollection
##
##  This is a category parent for all initial automata categories.
##
DeclareCategory("IsAutomaton",  IsAutomatonObject and
                                IsMultiplicativeElementWithInverse and
                                IsAssociativeElement);
DeclareCategoryFamily("IsAutomaton");
DeclareCategoryCollections("IsAutomaton");
InstallTrueMethod(IsGeneratorsOfMagmaWithInverses, IsAutomatonCollection);
InstallTrueMethod(IsAutomatonObject, IsAutomatonCollection);
InstallTrueMethod(IsAutomatonObject, IsAutomatonFamily);


###############################################################################
##
#A  AutomatonListInitialState (<a>)
##
DeclareAttribute( "AutomatonListInitialState", IsAutomaton, "mutable" );


###############################################################################
##
#C  Perm(<a>)
#C  Perm(<a>, <k>)
#O  PermOnLevel(<a>, <k>)
##
##  In the first form Perm returns the permutation on the first level,
##  in the second form - permutation on k-th level.
##  PermOnLevel does the same. It's here for the reason that the name "Perm"
##  is already taken, so we cannot declare it as KeyDependentOperation.
##
DeclareOperation("Perm", [IsAutomaton, IsPosInt]);
KeyDependentOperation("PermOnLevel", IsAutomaton, IsPosInt, ReturnTrue);


###############################################################################
##
#C  State(<a>, <k>)
#C  State(<a>, <vertex>)
##
##  This is the 'state' or 'projection' of given automaton in given vertex.
##  <vertex> is a list representing vertex;
##  if integer <k> is given, then corresponding vertex on the first level of
##  tree is taken.
##
##  It returns an IsAutomaton object, not a word or something.
##
DeclareOperation("State", [IsAutomaton, IsList]);


###############################################################################
##
#A  CanEasilyComputeOrder(<a>)
##
DeclareFilter("CanEasilyComputeOrder");


#E
#############################################################################
##
#W  automaton.gi               automata package                Yevgen Muntyan
#W                                                             Dmytro Savchuk
##
##  automata v 0.91 started June 07 2004
##

Revision.automaton_gi :=
  "@(#)$Id$";


###############################################################################
##
#M  Perm (<a>, <k>)
##
InstallMethod(Perm, "method for IsAutomaton and IsPosInt",
              [IsAutomaton, IsPosInt],
function(a, k)
  return PermOnLevel(a, k);
end);


###############################################################################
##
#M  FixesLevel(<a>, <k>)
##
InstallMethod(FixesLevel, "method for IsAutomaton and IsPosInt",
              [IsAutomaton, IsPosInt],
function(a, k)
  if HasIsSphericallyTransitive(a) then
    if IsSphericallyTransitive(a) then
      return false; fi; fi;

  if IsOne(PermOnLevel(a, k)) then
    SetIsSphericallyTransitive(a, false);
    return true;
  else
    return false;
  fi;
end);


###############################################################################
##
#M  FixesVertex(<a>, <v>)
##
InstallOtherMethod(FixesVertex,  "method for IsAutomaton and IsObject",
                   [IsAutomaton, IsObject],
function(a, v)
  if HasIsSphericallyTransitive(a) then
    if IsSphericallyTransitive(a) then
      return false; fi; fi;

  if v^a = v then
    SetIsSphericallyTransitive(a, false);
    return true;
  else
    return false;
  fi;
end);


###############################################################################
##
#M  IsSphericallyTransitive (<a>)
##
InstallMethod(IsSphericallyTransitive, "method for IsAutomaton",
              [IsAutomaton],
function(a)
  local ab;
  if IsActingOnBinaryTree(a) then
    ab := AbelImageAutomatonInList(AutomatonList(a))[AutomatonListInitialState(a)];
    return ab = One(ab)/(One(ab)+IndeterminateOfUnivariateRationalFunction(ab));
  fi;
  if not IsTransitive(Group(PermOnLevel(a, 1)), [1..Degree(a)]) then
    return false;
  fi;
  TryNextMethod();
end);

InstallImmediateMethod(IsSphericallyTransitive, IsAutomaton and HasOrder, 0,
function(a)
  if Order(a) < infinity then return false; fi;
  TryNextMethod();
end);


###############################################################################
##
#M  CanEasilyComputeOrder (<a>)
##
InstallTrueMethod(CanEasilyComputeOrder, HasOrder and IsAutomaton);
InstallTrueMethod(CanEasilyComputeOrder, IsSphericallyTransitive and IsAutomaton);


###############################################################################
##
#M  Order (<a>)
##
InstallImmediateMethod(Order, IsAutomaton and HasIsSphericallyTransitive, 0,
function(a)
  if IsSphericallyTransitive(a) then return infinity; fi;
  TryNextMethod();
end);


#E
#############################################################################
##
#W  automatonobj.gd            automata package                Yevgen Muntyan
#W                                                             Dmytro Savchuk
##  automata v 0.91 started June 07 2004
##

Revision.automatonobj_gd :=
  "@(#)$Id$";


###############################################################################
##
#C  IsAutomatonObject
##
##  IsAutomatonObject is a category parent for all automata-like categories,
##    i.e. for automata, automata groups, automata families, etc.
##
DeclareCategory("IsAutomatonObject", IsObject);


###############################################################################
##
#A  AutomatonList (<obj>)
##
##  It's the list representing automaton in case of initial or noninitial
##  automata, or it's the list representing genrators of automata group.
##  In case of initial automata and automata groups extra information is
##  needed to identify the object - initial state in case of automaton and
##  initial states of generators - they are declared for coresponding
##  categories.
##
DeclareAttribute("AutomatonList", IsAutomatonObject, "mutable");


###############################################################################
##
#A  DegreeOfTree
#P  IsActingOnBinaryTree
##
DeclareAttribute("DegreeOfTree", IsAutomatonObject);
DeclareProperty("IsActingOnBinaryTree", IsAutomatonObject);
InstallSubsetMaintenance(DegreeOfTree, IsCollection, IsCollection);
InstallSubsetMaintenance(IsActingOnBinaryTree, IsCollection, IsCollection);


###############################################################################
##
#P  IsSphericallyTransitive
#O  CanEasilyTestSphericalTransitivity
##
DeclareProperty("IsSphericallyTransitive", IsAutomatonObject);
DeclareFilter("CanEasilyTestSphericalTransitivity");
InstallTrueMethod(CanEasilyTestSphericalTransitivity, IsSphericallyTransitive);


###############################################################################
##
#O  FixesVertex
#O  FixesLevel
#A  FirstMovedLevel
##
DeclareOperation("FixesVertex", [IsAutomatonObject, IsList]);
DeclareOperation("FixesLevel", [IsAutomatonObject, IsPosInt]);
DeclareAttribute("FirstMovedLevel", IsAutomatonObject);


#E
#############################################################################
##
#W  automatonobj.gi            automata package                Yevgen Muntyan
#W                                                             Dmytro Savchuk
##
##  automata v 0.91 started June 07 2004
##

Revision.automatonobj_gi :=
  "@(#)$Id$";


###############################################################################
##
#M  Degree(<obj>)
##
InstallOtherMethod(Degree, "method for IsAutomatonObject",
                   [IsAutomatonObject],
function(obj)
  return DegreeOfTree(obj);
end);


###############################################################################
##
#M  FixesLevel(<obj>, <k>)
##
##  The most stupid method - just for case.
##
InstallMethod(FixesLevel, "method for IsAutomatonObject and IsPosInt",
              [IsAutomatonObject, IsPosInt],
function(obj, k)
  local lev, v;

  if HasIsSphericallyTransitive(obj) then
    if IsSphericallyTransitive(obj) then
      return false; fi; fi;

  lev := Tuples([1..DegreeOfTree(obj)], k);
  for v in lev do
    if not FixesVertex(obj, v) then
      return false; fi;
  od;

  SetIsSphericallyTransitive(obj, false);
  return true;
end);


###############################################################################
##
#M  FixesVertex(<obj>, <v>)
##
InstallOtherMethod(FixesVertex, "method for IsAutomatonObject and IsObject",
                   [IsAutomatonObject, IsObject],
function(obj, v)
  if HasIsSphericallyTransitive(obj) then
    if IsSphericallyTransitive(obj) then
      return false; fi; fi;

  TryNextMethod();
end);



#E
#############################################################################
##
#W  autom.gd                 automata package                  Yevgen Muntyan
#W                                                             Dmytro Savchuk
##
##  automata v0.9, started 01/22/2004
##

Revision.autom_gd :=
  "@(#)$Id$";


###############################################################################
##
#C  IsAutom
#C  IsAutomCollection
#C  IsAutomFamily
##
DeclareCategory("IsAutom", IsAutomaton);
DeclareCategoryCollections("IsAutom");
DeclareCategoryFamily("IsAutom");
InstallTrueMethod(IsAutomatonObject, IsAutomCollection);
InstallTrueMethod(IsAutomatonObject, IsAutomFamily);


###############################################################################
##
#O  AutomFamily(<list>, <names>)
##
DeclareOperation("AutomFamily", [IsList, IsList]);


###############################################################################
##
#O  Autom(<word>, <a>)
#O  Autom(<word>, <fam>)
##
DeclareOperation("Autom", [IsAssocWord, IsAutomFamily]);


###############################################################################
##
#A  One(<fam>)
##
DeclareAttribute("One", IsAutomFamily);


###############################################################################
##
#O  StatesWords(<a>)
##
DeclareOperation("StatesWords", [IsAutom]);


###############################################################################
##
#A  AbelImagesGenerators(<fam>)
##
DeclareAttribute("AbelImagesGenerators", IsAutomFamily);



#E
#############################################################################
##
#W  autom.gi                 automata package                  Yevgen Muntyan
#W                                                             Dmytro Savchuk
##
##  automata v0.9, started 01/22/2004
##

Revision.autom_gi :=
  "@(#)$Id$";


###############################################################################
##
#R  IsAutomRep
##
##  This is how IsAutom object is stored in GAP:
##  IsAutom object is a thing of kind "w = (w_1, w_2, ..., w_d)\pi", where
##    deg = d - arity of tree;
##    perm = \pi - permutation on first level;
##    w, w_1, ..., w_d - elements of free group representing elements of
##      automata group;
##    word = w;
##    states = [w_1, ..., w_d].
##
DeclareRepresentation("IsAutomRep",
                      IsComponentObjectRep and IsAttributeStoringRep,
                      ["word", "states", "perm", "deg"]);


###############################################################################
##
#R  IsAutomFamilyRep
##
##  Any object from category AutomFamily which is created here, lies in a
##  category IsAutomFamilyRep.
##  Family of Autom object <a> contains all essential information about
##  (mathematical) automaton which generates group containing <a>:
##  it contains automaton, relators found, properties of automaton and group
##  generated by it, etc.
##  Also family contains group generated by states of underlying automaton.
##
DeclareRepresentation("IsAutomFamilyRep",
                      IsComponentObjectRep and IsAttributeStoringRep,
                      [ "freegroup", "freegens",
                        "numstates", "deg", "trivstate",
                        "names", "automatonlist"]);


###############################################################################
##
#M  AutomFamily(<list>, <names>)
##
InstallMethod(AutomFamily, "method for IsList and IsList",
              [IsList, IsList],
function (list, names)
  local deg, tmp, trivstate, numstates, numallstates, i, j, perm,
        freegroup, freegens, a, family;

  if not IsCorrectAutomatonList(list) then
    Print("error in AutomFamily(IsList, IsList, IsString):\n  given list is not a correct list representing automaton\n");
    return fail;
  fi;

# 1. make a local copy of arguments, since they will be modified and put into the result

  list := StructuralCopy(list);
  names := StructuralCopy(names);
  deg := Length(list[1]) - 1;

# 2. Reduce automaton, find trivial state, permute states

  tmp := ReducedAutomatonInList(list);
  list := tmp[1];
  names := List(tmp[2], x->names[x]);

  trivstate := 0;
  for i in [1..Length(list)] do
    if IsTrivialStateInList(i, list) then
      trivstate := i;
    fi;
  od;

  numallstates := Length(list);
  if trivstate = 0 then
    numstates := Length(list);
  else
    numstates := Length(list) - 1;
  fi;

  if numstates = 0 then
    Print("error in AutomFamily(IsList, IsList, IsString):\n  don't want to work with trivial automaton\n");
    return fail;
  fi;

  # First move trivial state to the end of list
  if trivstate <> 0 then
    if trivstate <> numstates + 1 then
      perm := PermListList([1..Length(list)],
        Concatenation(  [1..(trivstate-1)],
                        [(trivstate+1)..Length(list)],
                        [trivstate] )
      );
      list := PermuteStatesInList(list, perm^-1);
      names := Permuted(names, perm^-1);
    fi;
    trivstate := Length(list);
    names[trivstate] := AutomataParameters.identity_symbol;
  fi;

  # Now add inverses of states and move trivial state to the end
  for i in [1..numstates] do
    list[i+numallstates] := [];
    perm := list[i][deg+1];
    list[i+numallstates][deg+1] := perm^-1;
    for j in [1..deg] do
      list[i+numallstates][j] := list[i][j^(perm^-1)];
      if list[i+numallstates][j] <> trivstate then
        list[i+numallstates][j] := list[i+numallstates][j] + numallstates;
      fi;
    od;
  od;

  if trivstate <> 0 then
    perm := PermListList([1..Length(list)],
      Concatenation([1..numstates],
                    [numstates+2..2*numstates+1],
                    [trivstate])
    );
    list := PermuteStatesInList(list, perm^-1);\
    trivstate := Length(list);
  fi;

# 3. Create FreeGroup and FreeGens

  freegroup := FreeGroup(names{[1..numstates]});
  freegens := ShallowCopy(FreeGeneratorsOfFpGroup(freegroup));
  for i in [1..numstates] do
    freegens[i+numstates] := freegens[i]^-1;
  od;
  if trivstate <> 0 then
    freegens[trivstate] := One(freegroup);
  fi;

# 4. Create family

  family := NewFamily("AutomFamily",
                      IsAutom,
                      IsAutom,
                      IsAutomFamily and IsAutomFamilyRep);

  family!.deg := deg;
  family!.numstates := numstates;
  family!.trivstate := trivstate;
  family!.names := names{[1..numstates]};
  family!.freegroup := freegroup;
  family!.freegens := freegens;
  family!.automatonlist := list;

  family!.automgens := [];
  for i in [1..Length(list)] do
    family!.automgens[i] := Objectify(
      NewType(family, IsAutom and IsAutomRep),
      rec(word := freegens[i],
          states := List([1..deg], j -> freegens[list[i][j]]),
          perm := list[i][deg+1],
          deg := deg) );
    SetAutomatonList(family!.automgens[i], list);
    SetAutomatonListInitialState(family!.automgens[i], i);
    IsActingOnBinaryTree(family!.automgens[i]);
  od;

  return family;
end);


###############################################################################
##
#M  AutomFamily(<list>)
##
InstallOtherMethod(AutomFamily, "method for IsList",
                   [IsList],
function(list)
  if not IsCorrectAutomatonList(list) then
    Print("error in AutomFamily(IsList):\n  given list is not a correct list representing automaton\n");
    return fail;
  fi;
  return AutomFamily(list,
    List([1..Length(list)],
      i -> Concatenation(AutomataParameters.state_symbol, String(i))));
end);


###############################################################################
##
#M  DegreeOfTree(<fam>)
##
InstallMethod(DegreeOfTree, "method for IsAutomFamily",
              [IsAutomFamily],
function(fam)
  return fam!.deg;
end);


###############################################################################
##
#M  Autom(<word>, <fam>)
##
InstallMethod(Autom, "method for IsAssocWord and IsAutomFamily",
              [IsAssocWord, IsAutomFamily],
function(w, fam)
  local exp, wstates, curstate, newstate, curletter, newletter,
        nperm, i, j, perm, a;

  if Length(w) = 0 then
    return One(fam);
  elif Length(w) = 1 then
    if ExponentSyllable(w, 1) = 1 then
      return fam!.automgens[GeneratorSyllable(w, 1)];
    else
      return fam!.automgens[GeneratorSyllable(w, 1) + fam!.numstates];
    fi;
  else
    # TODO
    exp := LetterRepAssocWord(w);
    for i in [1..Length(exp)] do
      if exp[i] < 0 then exp[i] := -exp[i] + fam!.numstates; fi;
    od;
    wstates := [];
    nperm := ();
    for i in [1..Length(exp)] do
      nperm := nperm * fam!.automatonlist[exp[i]][fam!.deg+1];
    od;

    for i in [1..fam!.deg] do
      wstates[i] := [];
      perm:=();
      for j in [1..Length(exp)] do
        newstate := fam!.automatonlist[exp[j]][i^perm];
        if newstate <> fam!.trivstate then
          Add(wstates[i], newstate);
        fi;
        perm := perm * fam!.automatonlist[exp[j]][fam!.deg+1];
      od;
      for j in [1..Length(wstates[i])] do
        if wstates[i][j] > fam!.numstates then
          wstates[i][j] := -(wstates[i][j] - fam!.numstates); fi;
      od;
      wstates[i] := AssocWordByLetterRep(FamilyObj(w), wstates[i]);
    od;

    a := Objectify(NewType(fam, IsAutom and IsAutomRep),
            rec(word := w,
                states := wstates,
                perm := nperm,
                deg := fam!.deg) );
    SetIsActingOnBinaryTree(a, fam!.deg = 2);

    return a;
  fi;
end);


###############################################################################
##
#M  Autom(<word>, <a>)
##
InstallOtherMethod(Autom, "method for IsAssocWord and IsAutom",
                   [IsAssocWord, IsAutom],
function(w, a)
  return Autom(w, FamilyObj(a));
end);


###############################################################################
##
#M  Autom(<word>, <list>)
##
InstallOtherMethod(Autom, "method for IsAssocWord and IsList",
                   [IsAssocWord, IsList],
function(w, list)
  local fam;
  fam := AutomFamily(list);
  if fam = fail then
    return fail;
  fi;
  return Autom(w, fam);
end);


###############################################################################
##
#M  PrintObj(<a>)
##
InstallMethod(PrintObj, "method for IsAutom",
              [IsAutom],
function (a)
    local deg, printword, i;

    printword := function(w)
        if IsOne(w) then Print(AutomataParameters.identity_symbol);
        else Print(w); fi;
    end;

    deg := a!.deg;
    printword(a!.word);
    Print(" = (");
    for i in [1..deg] do
        printword(a!.states[i]);
        if i <> deg then Print(", "); fi;
    od;
    Print(")");
    if not IsOne(a!.perm) then Print(a!.perm); fi;
end);


###############################################################################
##
#M  Perm(<a>)
##
InstallOtherMethod(Perm, "method for IsAutom", [IsAutom],
function(a)
    return a!.perm;
end);


###############################################################################
##
#M  DegreeOfTree(<a>)
##
InstallMethod(DegreeOfTree, "method for IsAutom", [IsAutom],
function(a)
    return a!.deg;
end);


###############################################################################
##
#M  Word(<a>)
##
InstallOtherMethod(Word, "method for IsAutom", [IsAutom],
function(a)
    return a!.word;
end);


###############################################################################
##
#M  <a1> * <a2>
##
InstallMethod(\*, "\*(IsAutom, IsAutom)", [IsAutom, IsAutom],
function(a1, a2)
    local a;
    a := Objectify(
        NewType(FamilyObj(a1), IsAutom and IsAutomRep),
        rec(word := a1!.word * a2!.word,
            states := List([1..a1!.deg], i -> a1!.states[i] * a2!.states[i^(a1!.perm)]),
            perm := a1!.perm * a2!.perm,
            deg := a1!.deg) );
    SetIsActingOnBinaryTree(a, a1!.deg = 2);
    return a;
end);


###############################################################################
##
#M  IsOne(a)
##
InstallOtherMethod(IsOne, "IsOne(IsAutom", [IsAutom],
function(a)
  local i, w, nw, d, to_check, checked, deb_i, perm, autlist, pos, istrivstate;

  if IsOne(a!.word) then return true; fi;

  d := a!.deg;
  autlist := FamilyObj(a)!.automatonlist;
#  to_check := [ExpandExtRepOfWord(a!.word, FamilyObj(a)!.numstates)];
  checked := [];
#  deb_i := 0;
#  pos := 0;

  istrivstate := function(v)
    local i,j,perm;
    if v in checked then
      return true;
    else
      perm := ();
      for i in [1..Length(v)] do perm := perm * autlist[v[i]][d+1]; od;
      if perm <> () then return false; fi;
      Add(checked, v);
      for j in [1..d] do
        if not istrivstate(WordStateInList(v, j, autlist)) then
          return false;
        fi;
      od;
      return true;
    fi;
  end;

  return istrivstate(ExpandExtRepOfWord(a!.word, FamilyObj(a)!.numstates));

#   while Length(to_check) > pos do
#     pos := pos + 1;
#     w := to_check[pos];
#     Print(pos, " : ", Length(to_check), "\n");
# #       deb_i := deb_i + 1;
# #       Print(deb_i, "\n");
#
#     perm := ();
#     for i in [1..Length(w)] do
#       perm := perm * autlist[w[i]][d+1];
#     od;
#     if not IsOne(perm) then
#       return false;
#     fi;
#
#     for i in [1..d] do
#       nw := StateOfWordInAutomatonList(w, i, autlist);
#       if Length(nw) <> 0 then
#         if not nw in checked then
#           if not nw in to_check then
#             Add(to_check, nw);
#           fi;
#         fi;
#       fi;
#     od;
#     Add(checked, w);
#   od;
#
#   return true;
end);


###############################################################################
##
#M  a1 = a2
##
## TODO
InstallMethod(\=, "\=(IsAutom, IsAutom)", [IsAutom, IsAutom],
function(a1, a2)
  local d, checked_pairs, pos, aw1, aw2, np, i;

  d := a1!.deg;
  checked_pairs := [[a1!.word, a2!.word]];
  pos := 0;

  while Length(checked_pairs) <> pos do
    pos := pos + 1;
    aw1 := Autom(checked_pairs[pos][1], a1);
    aw2 := Autom(checked_pairs[pos][2], a2);

    if Perm(aw1) <> Perm(aw2) then
      return false;
    fi;

    for i in [1..d] do
      np := [aw1!.states[i], aw2!.states[i]];
      if not np in checked_pairs then
        checked_pairs := Concatenation(checked_pairs, [np]);
      fi;
    od;
  od;

  return true;
end);


###############################################################################
##
#M  a1 < a2
##
InstallMethod(\<, "\<(IsAutom, IsAutom)", [IsAutom, IsAutom],
function(a1, a2)
  local d, checked_pairs, pos, aw1, aw2, np, i;

  d := a1!.deg;
  checked_pairs := [[a1!.word, a2!.word]];
  pos := 0;

  while Length(checked_pairs) <> pos do
    pos := pos + 1;
    aw1 := Autom(checked_pairs[pos][1], a1);
    aw2 := Autom(checked_pairs[pos][2], a2);

    if Perm(aw1) < Perm(aw2) then
      return true;
    elif Perm(aw1) > Perm(aw2) then
      return false;
    fi;

    for i in [1..d] do
      np := [aw1!.states[i], aw2!.states[i]];
      if not np in checked_pairs then
        checked_pairs := Concatenation(checked_pairs, [np]);
      fi;
    od;
  od;

  return false;
end);


###############################################################################
##
#M  InverseOp(<a>)
##
InstallMethod(InverseOp, "InnverseOp(IsAutom)", [IsAutom],
function(a)
  local inv;
  inv := Objectify(NewType(FamilyObj(a), IsAutom and IsAutomRep),
            rec(word := a!.word ^ -1,
                states := List([1..a!.deg], i -> a!.states[i^(a!.perm^-1)]^-1),
                perm := a!.perm ^ -1,
                deg := a!.deg) );
  SetIsActingOnBinaryTree(inv, a!.deg = 2);
  return inv;
end);


###############################################################################
##
#M  OneOp(<a>)
##
InstallMethod(OneOp, "OneOp(IsAutom)", [IsAutom],
function(a)
    return One(FamilyObj(a));
end);


###############################################################################
##
#M  One(<fam>)
##
InstallOtherMethod(One, "One(IsAutomFamily)", [IsAutomFamily],
function(fam)
  local one;
  one := Objectify(NewType(fam, IsAutom and IsAutomRep),
          rec(word := One(fam!.freegroup),
              states := List([1..fam!.deg], i -> One(fam!.freegroup)),
              perm := (),
              deg := fam!.deg)  );
  SetIsActingOnBinaryTree(one, fam!.deg = 2);
  return one;
end);


###############################################################################
##
#M  StatesWords(<a>)
##
InstallMethod(StatesWords, "StatesWords(IsAutom)", [IsAutom],
function(a)
  return a!.states;
end);


###############################################################################
##
#M  State(a, k)
##
InstallOtherMethod(State, "State(IsAutom, IsPosInt)", [IsAutom, IsPosInt],
function(a, k)
  if k > a!.deg then
    Print("error in State(IsAutom, IsPosInt): wrong vertex number\n");
  fi;
  return Autom(a!.states[k], a);
end);


###############################################################################
##
#M  State(a, seq)
##
## TODO
InstallMethod(State, "State(IsAutom, IsList)", [IsAutom, IsList],
function(a, v)
  if Length(v) = 0 then
    return a;
  fi;

  if Length(v) = 1 then
    return State(a, v[1]);
  fi;

  return State(State(a, v[1]), v{[2..Length(v)]});
end);


###############################################################################
##
#M  k ^ a
##
InstallOtherMethod(\^, "\^(IsPosInt, IsAutom)", [IsPosInt, IsAutom],
function(k, a)
    return k ^ Perm(a);
end);


###############################################################################
##
#M  seq ^ a
##
InstallOtherMethod(\^, "\^(IsList, IsAutom)", [IsList, IsAutom],
function(seq, a)
    local i, deg, img, cur;

    if HasAutomatonList(a) then
      return ImageOfVertexInList( AutomatonList(a),
                                  AutomatonListInitialState(a),
                                  seq );
    fi;

    deg := DegreeOfTree(a);
    for i in seq do
      if not IsInt(i) or i < 1 or i > deg then
        Print("\^(IsList, IsFGAutom): ",
              i, "is out of range 1..", deg, "\n");
        return seq;
      fi;
    od;

    if Length(seq) = 0 then return []; fi;
    if Length(seq) = 1 then return [seq[1]^Perm(a)]; fi;

    cur := LetterRepAssocWord(Word(a));
    for i in [1..Length(cur)] do
      if cur[i] < 0 then cur[i] := -cur[i]+FamilyObj(a)!.numstates; fi;
    od;
    cur := [cur, Perm(a)];

    img := [];
    for i in [1..Length(seq)] do
        img[i] := seq[i]^cur[2];
        cur := WordStateAndPermInList(cur[1], seq[i],
                                      FamilyObj(a)!.automatonlist);
    od;

    return img;
end);


###############################################################################
##
#M  PermOnLevelOp(a, k)
##
## TODO
InstallMethod(PermOnLevelOp, "PermOnLevelOp(IsAutom, IsPosInt)",
              [IsAutom, IsPosInt],
function(a, k)
    local dom, perm;

    dom := AsList(Tuples([1..DegreeOfTree(a)], k));
    perm := List(dom, s -> s ^ a);
    perm := PermListList(dom, perm);

    return perm;
end);


###############################################################################
##
#M  IsActingOnBinaryTree(<fam>)
#M  IsActingOnBinaryTree(<a>)
##
InstallMethod(IsActingOnBinaryTree, "IsActingOnBinaryTree(IsAutomFamily)",
              [IsAutomFamily],
function(fam)
    return fam!.deg = 2;
end);
InstallMethod(IsActingOnBinaryTree, "IsActingOnBinaryTree(IsAutom)",
              [IsAutom],
function(a)
    return a!.deg = 2;
end);


# ###############################################################################
# ##
# #M  Expand(a)
# ##
# InstallMethod(Expand, [IsFGAutom],
# function(a)
#   local deg, listrep, list, names, i, j, pf;
#
#   listrep := ListRep(a);
#   deg := Degree(a);
#   names := listrep.names;
#   list := listrep.list;
#
#   pf := function(w)
#     if IsOne(w) then
#       Print(AutomataParameters.identity_symbol);
#     else
#       Print(w);
#     fi;
#   end;
#
#   for i in [1..Length(list)] do
#     pf(names[i]);
#     Print(" = (");
#     for j in [1..deg] do
#       pf(names[list[i][j]]);
#       if j <> deg then
#         Print(", ");
#       fi;
#     od;
#     if not IsOne(list[i][deg+1]) then
#       Print(")", list[i][deg+1], "\n");
#     else
#       Print(")\n");
#     fi;
#   od;
# end);
#
#
# ###############################################################################
# ##
# #M  ExpandRen(a)
# ##
# InstallMethod(ExpandRen, [IsFGAutom],
# function(a)
#   local letters, deg, listrep, list, states, names, i, j, pf;
#
#   listrep := ListRep(a);
#   deg := Degree(a);
#   states := listrep.names;
#   list := listrep.list;
#   names := [];
#   for i in [1..Length(list)] do
#     names[i] := Concatenation("s", String(i));
#   od;
#
#   pf := function(w)
#     if IsOne(w) then
#       Print(AutomataParameters.identity_symbol);
#     else
#       Print(w);
#     fi;
#   end;
#
#   for i in [1..Length(list)] do
#     Print(names[i]);
#     Print(" = (");
#     for j in [1..deg] do
#       Print(names[list[i][j]]);
#       if j <> deg then
#         Print(", ");
#       fi;
#     od;
#     if not IsOne(list[i][deg+1]) then
#       Print(")", list[i][deg+1], "\n");
#     else
#       Print(")\n");
#     fi;
#   od;
#   for i in [1..Length(list)] do
#     Print(names[i], " = "); pf(states[i]); Print("\n");
#   od;
# end);
#
#
# ###############################################################################
# ##
# #M  ListRep(a)
# ##
# InstallMethod(ListRep, [IsFGAutom],
# function(a)
#   local deg, pos, states, list_comp, word, aut, i;
#
#   deg := Degree(a);
#   states := [a!.Word];
#   pos := 0;
#   list_comp := [];
#
#   while pos <> Length(states) do
#     pos := pos + 1;
#     word := states[pos];
#     aut := FGAutom(word, FamilyObj(a));
#     for i in [1..deg] do
#       if not aut!.States[i] in states then
#         Add(states, aut!.States[i]);
#       fi;
#     od;
#
#     Add(list_comp, Concatenation(List(aut!.States, w -> Position(states, w)), [aut!.Perm]));
#   od;
#
#   return rec(  list   := list_comp,
#               names := states  );
# end);
#
#
# ###############################################################################
# ##
# #M  StabilizesPath(a, path)
# ##
# InstallMethod(StabilizesPath, [IsFGAutom, IsList],
# function(a, path)
#   local len, checked_words, cur_state, cur_pos;
#
#   checked_words := [];
#   cur_state := a;
#   cur_pos := 1;
#   len := Length(path);
#
# ##  TODO: error checking
#
#   while true do
#     if cur_pos = 1 and Word(cur_state) in checked_words then
#         return true;
#     fi;
#
#     if path[cur_pos]^cur_state <> path[cur_pos] then
#       return false;
#     fi;
#
#     if cur_pos = 1 then
#       Add(checked_words, Word(cur_state)); fi;
#
#     cur_state := Projection(cur_state, path[cur_pos]);
#
#     if cur_pos < len then
#       cur_pos := cur_pos + 1;
#     else cur_pos := 1; fi;
#   od;
# end);


###############################################################################
##
#M  AbelImagesGenerators(<fam>)
##
InstallMethod(AbelImagesGenerators, "AbelImagesGenerators(IsAutomFamily)",
              [IsAutomFamily],
function(fam)
  return AbelImageAutomatonInList(fam!.automatonlist);
end);

InstallTrueMethod(CanEasilyTestSphericalTransitivity,
                  IsActingOnBinaryTree and IsAutom);

###############################################################################
##
#M  IsSphericallyTransitive(<a>)
##
InstallMethod(IsSphericallyTransitive, "IsSphericallyTransitive(IsAutom)",
              [IsAutom],
function(a)
  local w, i, ab, abs;

  if IsOne(Word(a)) then return false; fi;

  if IsActingOnBinaryTree(a) then
    w := LetterRepAssocWord(Word(a));
    for i in [1..Length(w)] do
      if w[i] < 0 then w[i] := -w[i]+FamilyObj(a)!.numstates; fi;
    od;

    abs := AbelImagesGenerators(FamilyObj(a));
    ab := Sum(List(w, x -> abs[x]));
    return ab = One(ab)/(One(ab) + IndeterminateOfUnivariateRationalFunction(ab));
  fi;

  TryNextMethod();
end);


###############################################################################
##
#M  Order(<a>)
##
InstallMethod(Order, "Order(IsAutom)",
              [IsAutom],
function(a)
  if IsOne(a) then return 1; fi;
  if CanEasilyTestSphericalTransitivity(a) and
      IsSphericallyTransitive(a) then return infinity; fi;
  TryNextMethod();
end);


#E
[Project Dir]
Dirs=
Files=automatagroup.gd/automatagroup.gi/automaton.gd/automaton.gi/automatonobj.gd/automatonobj.gi/autom.gd/autom.gi/automgroup.gd/automgroup.gi/globals.g/init.g/listops.gd/listops.gi/PackageInfo.g/utilsfrgrp.gd/utilsfrgrp.gi/utils.gd/utils.gi/utilsratfun.gd/utilsratfun.gi

[Project File]
Name=autom
Type=Default
#############################################################################
##
#W  automgroup.gd             automata package                 Yevgen Muntyan
#W                                                             Dmytro Savchuk
##
##  automata v0.9, started 01/22/2004
##

Revision.automgroup_gd :=
  "@(#)$Id$";


#############################################################################
##
#C  IsAutomGroup( <G> )
##
##  returns true if G is a group generated by elements from category
##  IsAutom
##
DeclareSynonym("IsAutomGroup", IsGroup and IsAutomCollection);
InstallTrueMethod(IsAutomataGroup, IsAutomGroup);


#############################################################################
##
#O  AutomGroup(<G>)
##
DeclareOperation("AutomGroup", [IsList]);


#############################################################################
##
#A  UnderlyingAutomFamily(<G>)
##
DeclareAttribute("UnderlyingAutomFamily", IsAutomGroup);
InstallSubsetMaintenance(UnderlyingAutomFamily, IsCollection, IsCollection);


#############################################################################
##
#P  IsGroupOfAutomFamily(<G>)
##
DeclareProperty("IsGroupOfAutomFamily", IsAutomGroup);
InstallTrueMethod(IsSelfSimilar, IsGroupOfAutomFamily);


#############################################################################
##
#P  IsFractalByWords(<G>)
##
DeclareProperty("IsFractalByWords", IsAutomGroup);
InstallTrueMethod(IsFractal, IsFractalByWords);


#############################################################################
##
#A  MihaylovSystem(<G>)
##
DeclareAttribute("MihaylovSystem", IsAutomGroup, "mutable");


#E
#############################################################################
##
#W  automgroup.gi             automata package                 Yevgen Muntyan
#W                                                             Dmytro Savchuk
##
##  automata v0.9, started 01/22/2004
##

Revision.automgroup_gi :=
  "@(#)$Id$";


###############################################################################
##
#M  AutomGroup(<list>)
##
InstallMethod(AutomGroup, "AutomGroup(IsList)", [IsList],
function (list)
  local fam, g;

  if not IsCorrectAutomatonList(list) then
    Print("error in AutomGroup(IsList):\n");
    Print("  given list is not a correct list representing automaton\n");
    return fail;
  fi;

  fam := AutomFamily(list);
  if fam = fail then return fail; fi;
  g := Group(fam!.automgens{[1..fam!.numstates]});
  SetUnderlyingAutomFamily(g, fam);
  SetIsGroupOfAutomFamily(g, true);
  SetGeneratingAutomatonList(g, fam!.automatonlist);
  SetAutomatonList(g, fam!.automatonlist);
  SetAutomatonListInitialStatesGenerators(g, [1..fam!.numstates]);
  SetDegreeOfTree(g, fam!.deg);
  SetIsActingOnBinaryTree(g, fam!.deg = 2);
  return g;
end);


###############################################################################
##
#M  AutomGroup(<list>, <names>)
##
InstallOtherMethod(AutomGroup, "AutomGroup(IsList, IsList)", [IsList, IsList],
function (list, names)
  local fam, g;

  if not IsCorrectAutomatonList(list) then
    Print("error in AutomGroup(IsList):\n");
    Print("  given list is not a correct list representing automaton\n");
    return fail;
  fi;

  fam := AutomFamily(list, names);
  if fam = fail then return fail; fi;
  g := Group(fam!.automgens{[1..fam!.numstates]});
  SetUnderlyingAutomFamily(g, fam);
  SetIsGroupOfAutomFamily(g, true);
  SetGeneratingAutomatonList(g, fam!.automatonlist);
  SetAutomatonList(g, fam!.automatonlist);
  SetAutomatonListInitialStatesGenerators(g, [1..fam!.numstates]);
  SetDegreeOfTree(g, fam!.deg);
  SetIsActingOnBinaryTree(g, fam!.deg = 2);
  return g;
end);


###############################################################################
##
#M  UnderlyingAutomFamily(<G>)
##
InstallMethod(UnderlyingAutomFamily, "UnderlyingAutomFamily(IsAutomGroup)",
              [IsAutomGroup],
function(G)
  return FamilyObj(GeneratorsOfGroup(G)[1]);
end);


###############################################################################
##
#M  UseSubsetRelation(<G>)
##
InstallMethod(UseSubsetRelation,
              "UseSubsetRelation(IsAutomGroup, IsAutomGroup)",
              [IsAutomGroup, IsAutomGroup],
function(super, sub)
  ## the full group is self similar, so if <super> is smaller than the full
  ##  group then sub is smaller either
  if HasIsGroupOfAutomFamily(super) then
    if not IsGroupOfAutomFamily(super) then
      SetIsGroupOfAutomFamily(sub, false); fi; fi;

  TryNextMethod();
end);


###############################################################################
##
#M  DegreeOfTree(<G>)
##
InstallMethod(DegreeOfTree, "DegreeOfTree(IsAutomGroup)",
              [IsAutomGroup],
function(G)
  return DegreeOfTree(UnderlyingAutomFamily(G));
end);


###############################################################################
##
#M  PrintObj(<G>)
##
InstallMethod(PrintObj, "PrintObj(IsAutomGroup)",
              [IsAutomGroup],
function(G)
  local i, gens;
  gens := GeneratorsOfGroup(G);
  if gens = [] then Print("< >"); fi;
  if Length(gens) = 1 then
    Print("< ", gens[1], " >\n");
  else
    Print("< ", gens[1], " \n");
    for i in [2..Length(gens)-1] do
      Print("  ", gens[i], ", \n");
    od;
    Print("  ", gens[Length(gens)], " >");
  fi;
end);


###############################################################################
##
#M  ViewObj(<G>)
##
InstallMethod(ViewObj, "ViewObj(IsAutomGroup)",
              [IsAutomGroup],
function(G)
  local i, gens;
  gens := List(GeneratorsOfGroup(G), g -> Word(g));
  if gens = [] then Print("< >"); fi;
  Print("< ");
  for i in [1..Length(gens)-1] do
    Print(gens[i], ", ");
  od;
  Print(gens[Length(gens)], " >");
end);


###############################################################################
##
#M  StabilizerOfFirstLevel(G)
##
InstallMethod(StabilizerOfFirstLevel,
              "StabilizerOfFirstLevel(IsAutomGroup)",
              [IsAutomGroup],
function (G)
  local freegens, S, F, hom, chooser, s, f, gens;

  if GeneratorsOfGroup(G) = [] then return G; fi;
  if Set( List(GeneratorsOfGroup(G), g -> Perm(g)) ) = [()] then
    return G;
  fi;

  freegens := List(GeneratorsOfGroup(G), a -> [a!.word, a!.perm]);
  S := Group(List(freegens, x -> x[2]));
  F := FreeGroup(Length(freegens));
  hom := GroupHomomorphismByImagesNC(F, S,
              GeneratorsOfGroup(F), List(freegens, x -> x[2]));
  gens := GeneratorsOfGroup(Kernel(hom));
  gens := List(gens, w -> CalculateWord(w, GeneratorsOfGroup(G)));
  return SubgroupNC(G, gens);
end);


###############################################################################
##
#M  MihaylovSystem(G)
##
## TODO
InstallMethod(MihaylovSystem, "MihaylovSystem(IsAutomGroup)", [IsAutomGroup],
function (G)
  local gens, mih, mih_gens, i;

  if not IsActingOnBinaryTree(G) then
    Error("MihaylovSystem(IsAutomGroup):\n  sorry, group is not acting on binary tree\n");
  fi;
  if not IsFractalByWords(G) then
    Info(InfoAutomata, 1, "given group is not IsFractalByWords");
    return fail;
  fi;

  gens := GeneratorsOfGroup(StabilizerOfFirstLevel(G));
  mih := ComputeMihaylovSystemPairs(List(gens, a -> StatesWords(a)));
  if not mih[3] then return gens; fi;

  mih_gens := [];
  for i in [1..Length(gens)] do
    mih_gens[i] := CalculateWord(mih[2][i], gens);
  od;
  return mih_gens;
end);


###############################################################################
##
#M  StabilizerOfLevelOp(G, k)
##
InstallMethod(StabilizerOfLevelOp,
              "StabilizerOfLevelOp(IsAutomGroup, IsPosInt)",
              [IsAutomGroup, IsPosInt],
function (G, k)
  local freegens, S, F, hom, chooser, s, f, gens;

  if FixesLevel(G, k) then return G; fi;

  freegens := List(GeneratorsOfGroup(G), a -> [a!.word, Perm(a, k)]);
  S := Group(List(freegens, x -> x[2]));
  F := FreeGroup(Length(freegens));
  hom := GroupHomomorphismByImagesNC(F, S,
              GeneratorsOfGroup(F), List(freegens, x -> x[2]));
  gens := GeneratorsOfGroup(Kernel(hom));
  gens := List(gens, w -> CalculateWord(w, GeneratorsOfGroup(G)));
  return SubgroupNC(G, gens);
end);


###############################################################################
##
#M  StabilizerOfVertex(G, k)
##
InstallOtherMethod( StabilizerOfVertex,
                    "StabilizerOfVertex(IsAutomGroup, IsPosInt)",
                    [IsAutomGroup, IsPosInt],
function (G, k)
  local X, S, F, hom, s, f, gens, stab, rt, map, canonreprs,
          action;

  if not k in [1..DegreeOfTree(G)] then
    Error("StabilizerOfVertex(IsAutomGroup, IsPosInt): k is not a valid vertex\n");
  fi;
  if FixesVertex(G, k) then return G; fi;

  X := List(G!.Gens, a -> [a!.word, a!.perm]);
  S := Group(List(X, x -> x[2]));
  F := FreeGroup(Length(X));
  hom := GroupHomomorphismByImagesNC(F, S,
              GeneratorsOfGroup(F), List(X, x -> x[2]));
  action := function(k, w)
      return k^Image(hom, w);
  end;
  gens := GeneratorsOfGroup(Stabilizer(F, k, action));
  gens := List(gens, w -> CalculateWord(w, GeneratorsOfGroup(G)));
  return SubgroupNC(G, gens);
end);


###############################################################################
##
#M  StabilizerOfVertex(G, seq)
##
InstallMethod(StabilizerOfVertex,
              "StabilizerOfVertex(IsAutomGroup, IsList)",
              [IsAutomGroup, IsList],
function (G, seq)
  local X, S, F, hom, s, f, gens, stab, rt, map, canonreprs,
          action, i, v;

  if Length(seq) = 0 then return G; fi;
  if FixesVertex(G, seq) then return G; fi;

  for i in [1..Length(seq)] do
    if not seq[i] in [1..DegreeOfTree(G)] then
      Error("StabilizerOfVertex(IsAutomGroup, IsList): list is not a valid vertex\n");
    fi;
  od;

  v := Position(AsList(Tuples([1..DegreeOfTree(G)], Length(seq))), seq);

  X := List(G!.Gens, a -> [a!.Word, Perm(a, Length(seq))]);
  S := Group(List(X, x -> x[2]));
  F := FreeGroup(Length(X));
  hom := GroupHomomorphismByImagesNC(F, S,
              GeneratorsOfGroup(F), List(X, x -> x[2]));
  action := function(k, w)
      return k^Image(hom, w);
  end;
  gens := GeneratorsOfGroup(Stabilizer(F, v, action));
  gens := List(gens, w -> CalculateWord(w, GeneratorsOfGroup(G)));
  return SubgroupNC(G, gens);
end);


###############################################################################
##
#M  IsFractalByWords(G)
##
InstallMethod(IsFractalByWords, "IsFractalByWords(IsAutomGroup)",
              [IsAutomGroup],
function (G)
  local freegens, stab, i, proj, sym;

  sym := Group(List(GeneratorsOfGroup(G), g -> Perm(g)));
  if not IsTransitive(sym, [1..DegreeOfTree(G)]) then
    Info(InfoAutomata, 1, "group is not transitive on first level");
    return false;
  fi;

  freegens := List(GeneratorsOfGroup(G), g -> Word(g));
  freegens := Difference(Nielsen(freegens)[1], [One(freegens[1])]);
  stab := StabilizerOfFirstLevel(G);
  stab := List(GeneratorsOfGroup(stab), a -> StatesWords(a));
  for i in [1..DegreeOfTree(G)] do
    proj := List(stab, s -> s[i]);
    if Difference(Nielsen(proj)[1], [One(proj[1])]) <> freegens then
      return false;
    fi;
  od;

  return true;
end);


###############################################################################
##
#M  IsFractal(G)
##
InstallMethod(IsFractal, "IsFractal(IsAutomGroup)", [IsAutomGroup],
function (G)
  if CanEasilyComputeSize(G) then
    if Size(G) < infinity then
      return false; fi; fi;

  if CanEasilyTestSphericalTransitivity(G) then
    if not IsSphericallyTransitive(G) then
      return false; fi; fi;

  if IsFractalByWords(G) then
    return true; fi;

  TryNextMethod();
end);


###############################################################################
##
#M  IsFreeNonabelian(G)
##
InstallMethod(IsFreeNonabelian, "IsFreeNonabelian(IsAutomGroup)",
              [IsAutomGroup],
function (G)
  if IsTrivial(G) then
    return false; fi;

  if IsAbelian(G) then
    return false; fi;

  if CanEasilyComputeSize(G) then
    if IsFinite(G) then
      return false; fi; fi;

  TryNextMethod();
end);


###############################################################################
##
#M  IsFreeAbelian(G)
##
InstallMethod(IsFreeAbelian, "IsFreeAbelian(IsAutomGroup)",
              [IsAutomGroup],
function (G)
  if IsTrivial(G) then
    return false; fi;

  if not IsAbelian(G) then
    return false; fi;

  if CanEasilyComputeSize(G) then
    if IsFinite(G) then
      return false; fi; fi;

  TryNextMethod();
end);


###############################################################################
##
#M  Size(G)
##
InstallMethod(Size, "Size(IsAutomGroup)", [IsAutomGroup],
function (G)
  if IsTrivial(G) then
    return 1; fi;

  if CanEasilyTestSphericalTransitivity(G) then
    if IsSphericallyTransitive(G) then
      return infinity; fi; fi;

  if IsFractalByWords(G) then
    return infinity; fi;

  if CanEasilyTestFractalness(G) then
    if IsFractal(G) then
      return infinity; fi; fi;

  if CanEasilyTestBeingFreeNonabelian(G) then
    if IsFreeNonabelian(G) then
      return infinity; fi; fi;

  if CanEasilyTestBeingFreeAbelian(G) then
    if IsFreeAbelian(G) then
      return infinity; fi; fi;

  TryNextMethod();
end);


###############################################################################
##
#M  IsSphericallyTransitive(G)
##
InstallMethod(IsSphericallyTransitive, "IsSphericallyTransitive(IsAutomGroup)",
              [IsAutomGroup],
function (G)
  local x, rat_gens, abel_hom;

  if IsTrivial(G) then
    return false; fi;

  if CanEasilyComputeSize(G) then
    if IsFinite(G) then
      return false; fi; fi;

  if IsActingOnBinaryTree(G) then
  fi;

  TryNextMethod();
end);


#E
#############################################################################
##
#W  globals.g               automata package                   Yevgen Muntyan
#W                                                             Dmytro Savchuk
##
##  automata v 0.91 started June 07 2004
##

Revision.globals_g :=
  "@(#)$Id$";


###############################################################################
##
#V  AutomataParameters
##
##  This record contains various global variables for automata package.
##  It's made as one record with million (possible:) entries in order to not
##  pollute global namespace (and we can put any trash in here).
##
BindGlobal ( "AutomataParameters", rec (
  identity_symbol := "e",
  state_symbol := "s"
));


###############################################################################
##
#V  InfoAutomata
##
DeclareInfoClass("InfoAutomata");




#############################################################################
##
#W  listops.gd              automata package                   Yevgen Muntyan
#W                                                             Dmytro Savchuk
##
##  automata v 0.91 started June 07 2004
##

Revision.listops_gd :=
  "@(#)$Id$";


###############################################################################
##
#F  IsCorrectAutomatonList( <list> )
##
##  Checks whether the list is correct list to define automaton, i.e.:
##  [[a_11,...,a_1n,p_1],[a_21,...,a_2n,p_2],...,[a_m1...a_mn,p_m]],
##  where n >= 2, m >= 1, a_ij are IsInt in [1..m], and all p_i are
##  in SymmetricalGroup(n).
##
DeclareGlobalFunction("IsCorrectAutomatonList");


###############################################################################
##
#F  ConnectedStatesInList( <state>, <list>)
##
##  Returns list of states which can be reached from given state.
##  It does not check correctness of arguments.
##
DeclareGlobalFunction("ConnectedStatesInList");


###############################################################################
##
#F  IsTrivialStateInList( <state>, <list>)
##
##  Checks whether given state is trivial.
##  Does not check correctness of arguments.
##
DeclareGlobalFunction("IsTrivialStateInList");


###############################################################################
##
#F  AreEquivalentStatesInList( <state1>, <state2>, <list> )
##
##  Checks whether two given states are equivalent.
##  Does not check correctness of arguments.
##
DeclareGlobalFunction("AreEquivalentStatesInList");


###############################################################################
##
#F  AreEquivalentStatesInLists( <state1>, <state2>, <list1>, <list2>)
##
##  Checks whether two given states in different lists are equivalent.
##  Does not check correctness of arguments.
##
DeclareGlobalFunction("AreEquivalentStatesInLists");


###############################################################################
##
#F  ReducedAutomatonInList( <list> )
##
##  Returns [new_list, list_of_states] where new_list is a new list which
##  represents reduced form of given automaton, i-th elmt of list_of_states
##  is the number of i-th state of new automaton in the old one.
##
##  First state of returned list is always first state of given one.
##  It does not remove trivial state, so it's not really "reduced automaton",
##  it just removes equivalent states.
##  TODO: write such function which removes trivial state
##
##  Does not check correctness of list.
##
DeclareGlobalFunction("ReducedAutomatonInList");


###############################################################################
##
#F  MinimalSubAutomatonInlist(<states>, <list>)
##
##  Returns list representation of automaton given by <list> which is minimal
##  subatomaton of automaton containing states <states>.
##
##  Does not check correctness of list.
##
DeclareGlobalFunction("MinimalSubAutomatonInlist");


###############################################################################
##
#F  PermuteStatesInList(<list>, <perm>)
##
##  Try to see what it does. I can never memorize what does "permute" mean.
##  I guess it means that i-th state goes to (i^perm)-th place.
##  Does not check correctness of arguments.
##
DeclareGlobalFunction("PermuteStatesInList");


###############################################################################
##
#F  ImageOfVertexInList(<list>, <init>, <vertex>)
##
DeclareGlobalFunction("ImageOfVertexInList");


###############################################################################
##
#F  WordStateInList(<word>, <s>, <list>)
#F  WordStateAndPermInList(<word>, <s>, <list>)
##
##  It's ProjectWord from selfs.g
##  Does not check correctness of arguments.
##
DeclareGlobalFunction("WordStateInList");
DeclareGlobalFunction("WordStateAndPermInList");



#E
#############################################################################
##
#W  listops.gd             automata package                    Yevgen Muntyan
#W                                                             Dmytro Savchuk
##
##  automata v 0.91 started June 07 2004
##

Revision.listops_gd :=
  "@(#)$Id$";


###############################################################################
##
#F  IsCorrectAutomatonList( <list> )
##
##  Checks whether the list is correct list to define automaton, i.e.:
##  [[a_11,...,a_1n,p_1],[a_21,...,a_2n,p_2],...,[a_m1...a_mn,p_m]],
##  where n >= 2, m >= 1, a_ij are IsInt in [1..m], and all p_i are
##  in SymmetricalGroup(n).
##
InstallGlobalFunction(IsCorrectAutomatonList,
function(list)
  local len, deg, i, j;

  if not IsDenseList(list) then
    return false;
  fi;

  len := Length(list);
  if len = 0 then
    return false;
  fi;

  for i in [1..len] do
    if not IsDenseList(list[i]) then
      return false;
    fi;
    if Length(list[i]) <> Length(list[1]) then
      return false;
    fi;
  od;

  deg := Length(list[1]) - 1;
  if deg < 2 then
    return false;
  fi;

  for i in [1..len] do
    for j in [1..deg] do
      if not IsInt(list[i][j]) then
        return false;
      fi;
      if list[i][j] > len or list[i][j] < 1 then
        return false;
      fi;
    od;
    if not list[i][deg + 1] in SymmetricGroup(deg) then
      return false;
    fi;
  od;

  return true;
end);


###############################################################################
##
#F  ConnectedStatesInList(state, list)
##
##  Returns list of states which are reachable from given state,
##  it does not check correctness of arguments
##
InstallGlobalFunction(ConnectedStatesInList,
function(state, list)
  local i, s, d, to_check, checked;

  d := Length(list[1]) - 1;

  to_check := [state];
  checked := [];

  while Length(to_check) <> 0 do
    for s in to_check do
      for i in [1..d] do
        if (not list[s][i] in checked) and (not list[s][i] in to_check)
        then
          to_check := Union(to_check, [list[s][i]]);
        fi;
      od;
      checked := Union(checked, [s]);
      to_check := Difference(to_check, [s]);
    od;
  od;

  return checked;
end);


###############################################################################
##
#F  IsTrivialStateInList( <state>, <list>)
##
##  Checks whether given state is trivial.
##  Does not check correctness of arguments.
##
InstallGlobalFunction(IsTrivialStateInList,
function(state, list)
  local i, s, d, to_check, checked;

  d := Length(list[1]) - 1;
  to_check := [state];
  checked := [];

  while Length(to_check) <> 0 do
    for s in to_check do
      for i in [1..d] do
        if not IsOne(list[s][d+1]) then
          return false;
        fi;
        if (not list[s][i] in checked) and (not list[s][i] in to_check)
        then
          to_check := Union(to_check, [list[s][i]]);
        fi;
      od;
      checked := Union(checked, [s]);
      to_check := Difference(to_check, [s]);
    od;
  od;

  return true;
end);


###############################################################################
##
#F  AreEquivalentStatesInList( <state1>, <state2>, <list> )
##
##  Checks whether two given states are equivalent.
##  Does not check correctness of arguments.
##
InstallGlobalFunction(AreEquivalentStatesInList,
function(state1, state2, list)
  local d, checked_pairs, pos, s1, s2, np, i;

  d := Length(list[1]) - 1;
  checked_pairs := [[state1, state2]];
  pos := 0;

  while Length(checked_pairs) <> pos do
    pos := pos + 1;
    s1 := checked_pairs[pos][1];
    s2 := checked_pairs[pos][2];

    if list[s1][d+1] <> list[s2][d+1] then
      return false;
    fi;

    for i in [1..d] do
      np := [list[s1][i], list[s2][i]];
      if not np in checked_pairs then
        checked_pairs := Concatenation(checked_pairs, [np]);
      fi;
    od;
  od;

  return true;
end);


###############################################################################
##
#F  AreEquivalentStatesInLists( <state1>, <state2>, <list1>, <list2>)
##
##  Checks whether two given states in different lists are equivalent.
##  Does not check correctness of arguments.
##
InstallGlobalFunction(AreEquivalentStatesInLists,
function(state1, state2, list1, list2)
  local d, checked_pairs, pos, s1, s2, np, i;

  d := Length(list1[1]) - 1;
  checked_pairs := [[state1, state2]];
  pos := 0;

  while Length(checked_pairs) <> pos do
    pos := pos + 1;
    s1 := checked_pairs[pos][1];
    s2 := checked_pairs[pos][2];

    if list1[s1][d+1] <> list2[s2][d+1] then
      return false;
    fi;

    for i in [1..d] do
      np := [list1[s1][i], list2[s2][i]];
      if not np in checked_pairs then
        checked_pairs := Concatenation(checked_pairs, [np]);
      fi;
    od;
  od;

  return true;
end);


###############################################################################
##
#F  ReducedAutomatonInList( <list> )
##
##  Returns [new_list, list_of_states] where new_list is a new list which
##  represents reduced form of given automaton, i-th elmt of list_of_states
##  is the number of i-th state of new automaton in the old one.
##
##  First state of returned list is always first state of given one.
##  It does not remove trivial state, so it's not really "reduced automaton",
##  it just removes equivalent states.
##  TODO: write such function which removes trivial state
##
##  Does not check correctness of list.
##
InstallGlobalFunction(ReducedAutomatonInList,
function(list)
  local   i, n, triv_states, equiv_classes, checked_states, s, s1, s2,
          eq_cl, eq_cl_1, eq_cl_2, are_equiv, eq_cl_reprs,
          new_states, new_list, deg,
          reduced_automaton, state, states_reprs;

  n := Length(list);
  triv_states := [];
  equiv_classes := [];
  checked_states := [];
  deg := Length(list[1]) - 1;

  for s in [1..n] do
      if IsTrivialStateInList(s, list) then
          triv_states := Union(triv_states, [s]);
      fi;
  od;

  equiv_classes:=[triv_states];
  for s1 in Difference([1..n], triv_states) do
  for s2 in Difference([s1+1..n], triv_states) do
    are_equiv := AreEquivalentStatesInList(s1, s2, list);

    if s1 in checked_states then
      for eq_cl in equiv_classes do
        if s1 in eq_cl then
          eq_cl_1 := StructuralCopy(eq_cl);
          break; fi; od;
    else
      equiv_classes := Union(equiv_classes, [[s1]]);
      eq_cl_1 := [s1];
      checked_states := Union(checked_states, [s1]);
    fi;
    if s2 in checked_states then
      for eq_cl in equiv_classes do
        if s2 in eq_cl then
          eq_cl_2 := StructuralCopy(eq_cl);
          break; fi; od;
    else
      equiv_classes := Union(equiv_classes, [[s2]]);
      eq_cl_2 := [s2];
      checked_states := Union(checked_states, [s2]);
    fi;

    if are_equiv then
      equiv_classes := Difference(equiv_classes, [eq_cl_1, eq_cl_2]);
      equiv_classes := Union(equiv_classes, [Union(eq_cl_1, eq_cl_2)]);
    fi;
  od;
  od;
  states_reprs := [1..n];
  for eq_cl in equiv_classes do
    for s in eq_cl do
      states_reprs[s] := Minimum(eq_cl);
    od;
  od;


  new_states := Set(states_reprs);
  new_list := [];

  for s in new_states do
    state := [];
    state[deg+1] := list[s][deg+1];
    for i in [1..deg] do
      state[i] := Position(new_states, states_reprs[list[s][i]]);
    od;
    new_list := Concatenation(new_list, [state]);
  od;

  return [new_list, new_states];
end);


###############################################################################
##
#F  MinimalSubAutomatonInlist(<states>, <list>)
##
##  Returns list representation of automaton given by <list> which is minimal
##  subatomaton of automaton containing states <states>.
##
##  Does not check correctness of list.
##
InstallGlobalFunction(MinimalSubAutomatonInlist,
function(states, list)
  local s, new_states, state, new_list, i, deg;

  new_states := [];
  for s in states do
    new_states := Union(new_states, ConnectedStatesInList(s, list));
  od;

  new_list := [];
  deg := Length(list[1]) - 1;

  for s in new_states do
    state := [];
    for i in [1..deg] do
      state[i] := Position(new_states, list[s][i]);
    od;
    state[deg+1] := list[s][deg+1];
    new_list := Concatenation(new_list, [state]);
  od;

  return [new_list, new_states];
end);


###############################################################################
##
#F  PermuteStatesInList(<list>, <perm>)
##
##  Does not check correctness of arguments.
##
InstallGlobalFunction(PermuteStatesInList,
function(list, perm)
  local new_list, i, j, deg;

  deg := Length(list[1]) - 1;
  new_list := [];
  for i in [1..Length(list)] do
    new_list[i^perm] := [];
    for j in [1..deg] do
      new_list[i^perm][j] := list[i][j]^perm;
    od;
    new_list[i^perm][deg+1] := list[i][deg+1];
  od;

  return new_list;
end);


###############################################################################
##
#F  WordStateInList(<w>, <s>, <list>)
##
##  It's ProjectWord from selfs.g
##  Does not check correctness of arguments.
##
InstallGlobalFunction(WordStateInList,
function(w, s, list)
  local i, perm, d, proj;
  d := Length(list[1])-1;
  proj := [];
  perm := ();
  for i in [1..Length(w)] do
    Add(proj, list[w[i]][s^perm]);
    perm := perm * list[w[i]][d+1];
  od;
  return proj;
end);


###############################################################################
##
#F  WordStateAndPermInList(<w>, <s>, <list>)
##
##  Does not check correctness of arguments.
##
InstallGlobalFunction(WordStateAndPermInList,
function(w, s, list)
  local i, perm, perm_res, new_state, d, proj;
  d := Length(list[1])-1;
  proj := [];
  perm := ();
  perm_res := ();
  for i in [1..Length(w)] do
    new_state := list[w[i]][s^perm];
    Add(proj, new_state);
    perm := perm * list[w[i]][d+1];
    perm_res := perm_res * list[new_state][d+1];
  od;
  return [proj, perm_res];
end);


###############################################################################
##
#F  ImageOfVertexInList(<list>, <init>, <vertex>)
##
##  Does not check correctness of arguments.
##
InstallGlobalFunction(ImageOfVertexInList,
function(list, s, seq)
  local deg, img, x;

  deg := Length(list[1]) - 1;
  img := [];
  for x in seq do
      Add(img, x^list[s][deg+1]);
      s := list[s][x];
  od;

  return img;
end);


#E
