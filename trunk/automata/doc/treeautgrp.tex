% This file was created automatically from treeautgrp.msk.
% DO NOT EDIT!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Properties and operations for all groups acting on trees}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations with group elements}

In the examples below we will consider the elements of the lamplighter group. First we define it as
\beginexample
gap> G:=AutomGroup("a=(a,b)(1,2),b=(a,b)");
< a, b >
\endexample

The multiplication of tree homomorphisms is defined in the standard way 

\>`<a> \* <b>'{product}!{for tree homomorphisms}

The following operations allow to compute the actions of tree homomorphisms on letters and vertices

\>`<letter> ^ <a>'{action}!{of tree homomorphism on letter}
\>`<vertex> ^ <a>'{action}!{of tree homomorphism on vertex}

\beginexample
gap> 1^a;
2
gap> [1,2,2,1,2,1]^(a*b^2);
[ 2, 1, 2, 2, 1, 2 ]
\endexample

\>Perm( <a>[, <lev>] ) O

Returns permutation induced by tree automorphism <a> on the level <lev>
(or first level if <lev> is not given). See also
`TransformationOnLevel'~("TransformationOnLevel").


\>PermOnLevel( <a>, <k> ) O

Does the same thing as `Perm'~("Perm").


\>PermOnLevelAsMatrix( <g>, <lev> ) F

Computes the action of the element <g> on the <lev>-th level as a permutational matrix.
\beginexample
gap> PermOnLevelAsMatrix(a*b,2);
[ [ 0, 0, 0, 1 ], [ 0, 0, 1, 0 ], [ 0, 1, 0, 0 ], [ 1, 0, 0, 0 ] ]
\endexample


The operations below describe how to work with sections of tree homomorphisms.

\>State( <a>, <v> ) O

Returns the section of given automorphism at the given vertex.
Vertex <v> can be a list representing vertex; or a positive integer
representing a vertex at the first level of the tree.
\beginexample
gap> State(a*b*a^2,[1,2,2,1,2,1]);
a^2*b^2
\endexample


\>States( <a> [, <lev>] ) O

Returns the list of states of <a> at the <lev>-th level. If <lev> is ommited
it is assumed to be 1.
\beginexample
gap> States(a*b*a^2);
[ a*b^2*a, b*a^2*b ]
\endexample


\>Expand( <a>[, <k>] ) O

Returns an ``expanded'' form of tree homomorphism <a>, i.e. the
representation of the form $$a = (a_1, a_2, ..., a_{d_1\times...\times d_k})s$$
where $a_i$ are the states of <a> at the <k>-th level, and $s$ is the
transformation of the k-th level. By default <k> is equal to 1.
\beginexample
gap> Expand(a*b^2);
(a*b^2, b*a^2)(1,2)
gap> Expand(a*b^2,3);
(a*b^2, b*a^2, a^2*b, b^2*a, a*b*a, b*a*b, a^3, b^3)(1,8,3,5)(2,7,4,6)
\endexample



One can compute the following properties.
\>`IsSphericallyTransitive( <a> )'{IsSphericallyTransitive![treeaut]}@{`IsSphericallyTransitive'!`[treeaut]'} P

Returns whether the action of <a> is spherically transitive (see "Short math background").


\>IsTransitiveOnLevel( <a>, <lev> ) O

Whether <a> acts transitively on level <lev>.


\>Word( <a> ) O

Returns <a> as an associative word (an element of underlying free group) in
generators of the self-similar group
to which <a> belongs.
\beginexample
gap> w:=Word(a*b^2*a^-1);
a*b^2*a^-1
gap> Length(w);
4
\endexample





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations with groups}

In the examples below we will consider the elements of Basilica group and 
Grigorchuk group. First we define them as
\beginexample
gap> Basilica:=AutomGroup("u=(v,1)(1,2),v=(u,1)");
< u, v >
gap> GrigorchukGroup:=AutomGroup("a=(1,1)(1,2),b=(a,c),c=(a,d),d=(1,b)");
< a, b, c, d >
\endexample

\>IsFractal( <G> ) P

Returns whether the group <G> is fractal.
\beginexample
gap> IsFractal(GrigorchukGroup);
true
\endexample


\>`IsSphericallyTransitive( <G> )'{IsSphericallyTransitive![treeautgrp]}@{`IsSphericallyTransitive'!`[treeautgrp]'} P

Returns whether the group <G> is spherically transitive (see~"Short math background").
\beginexample
gap> IsSphericallyTransitive(GrigorchukGroup);
true
\endexample


\>`IsTransitiveOnLevel( <G>, <lev> )'{IsTransitiveOnLevel![treeautgrp]}@{`IsTransitiveOnLevel'!`[treeautgrp]'} O

Returns whether the group <G> acts transitively on level <lev>.
\beginexample
gap> IsTransitiveOnLevel(Group([a,b]),3);
true
gap> IsTransitiveOnLevel(Group([a,b]),4);
false
\endexample


\>IsSelfSimilar( <G> ) P

Whether semigroup <G> is "self-similar".


\>AbelImage( <obj> ) A

Returns image of <obj> in canonical projection onto abelianization of
the full group of tree automorphisms, represented as a subgroup of additive
group of rational functions.
XXX it doesn't make sense for non-invertible automata, does it?


\>PermGroupOnLevel( <G>, <k> ) O

Returns group of permutations induced by action of group <G> at the <k>-th
level.
\beginexample
gap> PermGroupOnLevel(Basilica,4);
Group([ (1,11,3,9)(2,12,4,10)(5,13)(6,14)(7,15)(8,16), (1,6,2,5)(3,7)(4,8) ])
gap> H:=PermGroupOnLevel(Group([u,v^2]),4);
Group([ (1,11,3,9)(2,12,4,10)(5,13)(6,14)(7,15)(8,16), (1,2)(5,6) ])
gap> Size(H);
64
\endexample


\>StabilizerOfLevel( <G>, <k> ) O

Returns the stabilizer of the <k>-th level.
\beginexample
gap> StabilizerOfLevel(Basilica, 2);
< u*v^2*u^-1, u*v*u*v^2*u^-1*v^-1*u^-1, v^2, v*u^2*v^-1, u*v*u^2*v^-1*u^-1, u^
2, v*u*v*u*v^-1*u^-1*v^-1*u^-1 >
\endexample


\>StabilizerOfFirstLevel( <G> ) A

Returns the stabilizer of the first level, see also~"StabilizerOfLevel".
\beginexample
gap> StabilizerOfFirstLevel(Basilica);
< u^2, u*v*u^-1, v >
\endexample


\>StabilizerOfVertex( <G>, <v> ) O

Returns stabilizer of the vertex <v>. <v> can be a list represnting a
vertex, or a positive intger representing a vertex at the first level.
\beginexample
gap> StabilizerOfVertex(Basilica,[1,2,1]);
< v*u^4*v^-1, v*u^2*v^2*u^-2*v^-1, v^2, u^2, v*u^2*v*u^2*v^-1*u^-2*v^-1, u*v*u^
-1, v*u^-1*v*u*v^-1, v*u^2*v*u*v*u^-1*v^-1*u^-2*v^-1 >
\endexample


\>FixesLevel( <obj>, <lev> ) O

Whether <obj> fixes level <lev>, i.e. fixes every vertex at the level
<lev>.


\>FixesVertex( <obj>, <v> ) O

Whether <obj> fixes vertex <v>. Vertex <v> may be given as a list, or as
a positive integer, in which case it denotes <v>-th vertex at the first
level.


\>Projection( <G>, <v> ) O
\>ProjectionNC( <G>, <v> ) O

Returns projection of the group <G> at the vertex <v>. The group <G> must fix the
the vertex <v>, otherwise `Error'() will be called. The operation `ProjectionNC' does the
same thing, except it does not check whether <G> fixes vertex <v>.
\beginexample
gap> Projection(StabilizerOfVertex(Basilica,[1,2,1]),[1,2,1]);
< v, u >
\endexample


\>ProjStab( <G>, <v> ) O

Returns projection of the stabilizer of <v> at itself. It is a shortcut for
`Projection'(`StabilizerOfVertex'(G, v), v) (see "Projection",
"StabilizerOfVertex").
\beginexample
gap> ProjStab(Basilica,[1,2,1]);
< v, u >
\endexample


\>FindGroupElement( <G>, <func>, <val>, <max_len> ) F
\>FindGroupElements( <G>, <func>, <val>, <max_len> ) F

The first function enumerates elements of the group <G> until it finds
an element $g$ of length at most <max_len>, for which <func>($g$)=<val>. Returns $g$.

The second function enumerates elements of the group of length at most <max_len>
and returns the list of elements $g$, for which <func>($g$)=<val>.

The following examlpe illustrates how one can find an element of order 16 in
Grigorchuk group and the list of all such elements of length at most 5.
\beginexample
gap> FindGroupElement(GrigorchukGroup,Order,16,5);
a*b
gap> FindGroupElements(GrigorchukGroup,Order,16,5);
[ a*b, b*a, c*a*d, d*a*c, a*b*a*d, a*c*a*d, a*d*a*b, a*d*a*c, b*a*d*a, c*a*d*a,
  d*a*b*a, d*a*c*a, a*c*a*d*a, a*d*a*c*a, b*a*b*a*c, b*a*c*a*c, c*a*b*a*b,
  c*a*c*a*b ]
\endexample


\>FindElementOfInfiniteOrder( <G>, <max_len>, <depth> ) F
\>FindElementsOfInfiniteOrder( <G>, <max_len>, <depth> ) F

The first function enumerates elements of the group <G> up to length <max_len>
until it finds an element $g$ of infinite order, such that
`OrderUsingSections'($g$,<depth>) is `infinity' (see "OrderUsingSections").
In other words all sections of every element up to depth <depth> are
investigated. In case if the element belongs to the group generated by bounded
automaton (see "IsGeneratedByBoundedAutomaton") one can set <depth> to be `infinity'.

The second function returns the list of all such elements up to length <max_len>.

\beginexample
gap> G:=AutomGroup("a=(1,1)(1,2),b=(a,c),c=(b,1)");
< a, b, c >
gap> FindElementOfInfiniteOrder(G,5,10);
a*b*c
\endexample


\>GroupGrowth( <G>, <len> ) F

Returns the list of first <len> values of the growth function of a group <G>.
\beginexample
gap> GroupGrowth(GrigorchukGroup,7);
#I  Length not greater than 2: 11
#I  Length not greater than 3: 23
#I  Length not greater than 4: 40
#I  Length not greater than 5: 68
#I  Length not greater than 6: 108
#I  Length not greater than 7: 176
[ 1, 5, 11, 23, 40, 68, 108, 176 ]
\endexample


\>GroupElements( <G>, <len> ) F

Returns the list of all different elements of a group <G> up to length <len>.
\beginexample
gap> GroupElements(GrigorchukGroup,3);
[ 1, a, b, c, d, a*b, a*c, a*d, b*a, c*a, d*a, a*b*a, a*c*a, a*d*a, b*a*b, b*a*c, b*a*d, c*a*b, c*a*c, c*a*d, d*a*b,
  d*a*c, d*a*d ]
\endexample



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
