% This file was created automatically from automgroup.msk.
% DO NOT EDIT!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Properties and operations for groups generated by automata}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations with automata group elements}

\>OrbitOfVertex( <ver>, <g>[, <n>] ) O

Returns the list of vertices in the orbit of vertex <ver> under the
action of a semigroup generated by an automorphism <g>.
If <n> is specified, it returns only first <n> elements of the orbit.
Vertices are defined either as lists with entries from `[1..d]', or as
strings containing characters `1,...,d', where `d'
is the degree of the tree.
\beginexample
gap> g:=AutomGroup("t=(1,t)(1,2)");;
gap> OrbitOfVertex([1,1,1],t);
[ [ 1, 1, 1 ], [ 2, 1, 1 ], [ 1, 2, 1 ], [ 2, 2, 1 ], [ 1, 1, 2 ], [ 2, 1, 2 ],
[ 1, 2, 2 ], [ 2, 2, 2 ] ]
gap> OrbitOfVertex("111111111111",t,6);
[ [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
[ 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
[ 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ]
\endexample


\>PrintOrbitOfVertex( <ver>, <g>[, <n>] ) O

Prints the orbit of vertex <A>ver</A> under the action of a semigroup generated by
<g>. Each vertex is printed as a string containing characters 1, ..., d, where `d'
is the degree of the tree. In case of binary tree the symbols `` '' and ```x'''
are used to represent `1' and `2'.
If <n> is specified only first <n> elements of the orbit are printed.
Vertices are defined either as lists with entries from `[1..d]', or as
strings.
\beginexample
gap> g:=AutomGroup("a=(b,a)(1,2),b=(b,a)");
< a, b >
gap> PrintOrbitOfVertex("2222222222222222222222222222222",a*b^-2,6);
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

x x x x x x x x x x x x x x x x
 xx  xx  xx  xx  xx  xx  xx  xx
xxx xxx xxx xxx xxx xxx xxx xxx
   xxxx    xxxx    xxxx    xxxx
gap> h:=AutomGroup("a=(b,1,1)(1,2,3),b=(a,b,a)(1,2)");;
gap> PrintOrbitOfVertex([1,2,1],b^2);
121
132
123
131
122
133
\endexample


\>IsOneWordSelfSim( <word>, <G> ) F

Checks if the word <word> is trivial in a self-similar group <G>.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations with automata groups}

%\cite{harpe}

\>UnderlyingAutomFamily( <G> ) A

Returns the family to which elements of <G> belong.


\>DegreeOfTree( <obj> ) A

This is a synonym for TopDegreeOfTree~("TopDegreeOfTree") for the case of
regular tree. It is an error to call this method for an object which acts
on a non-regular tree.


\>MihaylovSystem( <G> ) AM


\>IsFractalByWords( <G> ) P


\>LevelOfFaithfulAction( <G> ) A
\>LevelOfFaithfulAction( <G>, <max_lev> ) A

For a given finite self-similar group <G> determines the smallest level of
the tree, where <G> acts faithfully, i.e. the stabilizer of this level in <G>
is trivial. The idea here is that for self-similar group all nontrivial level
stabilizers are different. If <max_lev> is given it finds only first <max_lev>
quotients by stabilizers and if all of them have different size returns 'fail'.
If <G> is infinite and <max_lev> is not specified will loop forever.

See also "IsomorphismPermGroup".
\beginexample
gap> H:=AutomGroup("a=(a,a)(1,2),b=(a,a),c=(b,a)(1,2)");
< a, b, c >
gap> LevelOfFaithfulAction(H);
3
gap> LevelOfFaithfulAction(AddingMachine,10);
fail
\endexample


\>IsomorphismPermGroup( <G> ) O
\>IsomorphismPermGroup( <G>, <max_lev> ) O

For a given finite group <G> generated by initial automata (see "IsAutomGroup")
computes an isomorphism from <G> into a finite permutational group.
If <G> is not known to be self-similar (see "IsSelfSimilar") the isomorphism is based on the
regular representation, which works generally much slower. If <G> is self-similar
there is a level of the tree (see "LevelOfFaithfulAction"), where <G> acts faithfully.
The corresponding representation is returned in this case. If <max_lev> is given
it finds only first <max_lev> quotients by stabilizers and if all of them have
different size returns 'fail'.
If <G> is infinite and <max_lev> is not specified will loop forever.
\beginexample
gap> G:=GrigorchukGroup;
< a, b, c, d >
gap> f:=IsomorphismPermGroup(Group(a,b));
[ a, b ] -> [ (1,2)(3,5)(4,6)(7,9)(8,10)(11,13)(12,14)(15,17)(16,18)(19,21)(20,
    22)(23,25)(24,26)(27,29)(28,30)(31,32), (1,3)(2,4)(5,7)(6,8)(9,11)(10,12)(13,
    15)(14,16)(17,19)(18,20)(21,23)(22,24)(25,27)(26,28)(29,31)(30,32) ]
gap> Size(Image(f));
32
gap> H:=AutomGroup("a=(a,a)(1,2),b=(a,a),c=(b,a)(1,2)");
< a, b, c >
gap> f1:=IsomorphismPermGroup(H);
[ a, b, c ] -> [ (1,8)(2,7)(3,6)(4,5), (1,4)(2,3)(5,8)(6,7), (1,6,3,8)(2,5,4,7) ]
gap> Size(Image(f1));
16
\endexample


\>DiagonalAction( <fam> ) O


\>MultAutomAlphabet( <fam> ) O


\>UnderlyingFreeSubgroup( <G> ) AM
\>UnderlyingFreeGenerators( <G> ) AM
\>UnderlyingFreeGroup( <G> ) A


\>IndexInFreeGroup( <G> ) AM


\>IsAutomatonGroup( <G> ) P

                          means that the group is generated by its automaton

\>IsSelfSimilar( <G> ) P

Whether semigroup <G> is "self-similar".


\>FindNucleus( <G>[, <max_nucl>] ) O

Given a self-similar group <G> it tries to find its nucleus. If the group
is not contracting it will loop forever. When it finds the nucleus it returns
the triple [`NucleusIncludingGeneratingSet'(<G>), `AutomNucleus'(<G>),
`NucleusIncludingGeneratingSetAutom'(<G>)] (see "NucleusIncludingGeneratingSet",
"AutomNucleus", "NucleusIncludingGeneratingSetAutom").

If <max_nucl> is given stops after finding <max_nucl> elements that need to be in
the nucleus and returns `fail' if the nucleus was not found.

Use `IsNoncontracting'~(see "IsNoncontracting") to try to show that <G> is
noncontracting.

\beginexample
gap> FindNucleus(Basilica);
[ [ e, u, v, u^-1, v^-1, u^-1*v, v^-1*u ], [ e, u, v, u^-1, v^-1, u^-1*v, v^-1*u ]
  , [ [ 1, 1, () ], [ 3, 1, (1,2) ], [ 2, 1, () ], [ 1, 5, (1,2) ],
    [ 4, 1, () ], [ 1, 7, (1,2) ], [ 6, 1, (1,2) ] ] ]
\endexample


\>IsContracting( <G> ) A

Given a self-similar group <G> tries to compute whether it is contracting or not.
Only the partial method is implemented (since there is no general algorithm so far).
First it tries to find the nucleus up to size 50 using `FindNucleus'(<G>,50) (see~"FindNucleus"), then
it tries to find the evidence that the group is noncontracting using
`IsNoncontracting'(<G>,10,10) (see~"IsNoncontracting"). If the answer was not found one can try to use
`FindNucleus' and `IsNoncontracting' with bigger tolerances.

\beginexample
gap> IsContracting(Basilica);
true
gap> IsContracting(AutomGroup("a=(c,a)(1,2),b=(c,b),c=(b,a)"));
#I  (b*c^-1)^1 has b*a^-1 as a section at vertex [ 2 ]
#I  (b*a^-1)^2 has congutate of a^-1*b as a section at vertex [ 1 ]
false
\endexample


\>IsNoncontracting( <G>[, <max_len>, <depth>] ) F

Tries to show that the group <G> is not contracting.
Enumerates the elements of the group <G> up to length <max_len>
until it finds an element which has a section <g> of infinite order, such that
`OrderUsingSections'(<g>, <depth>) (see "OrderUsingSections")
is infinity and such that <g> stabilizes some vertex and has itself as a
section at this vertex. See also `IsContracting'~("IsContracting").

\beginexample
gap> G:=AutomGroup("a=(b,a)(1,2),b=(c,b)(),c=(c,a)");
< a, b, c >
gap> IsNoncontracting(G,10,10);
true
\endexample


\>IsGeneratedByAutomatonOfPolynomialGrowth( <G> ) P

For a group <G> generated by all states of finite automaton (see "IsAutomatonGroup")
determines whether this automaton has polynomial growth in terms of Sidki~\cite{sidki:acyclic}.

See also `IsGeneratedByBoundedAutomaton' ("IsGeneratedByBoundedAutomaton" and
`PolynomialDegreeOfGrowthOfAutomaton' ("PolynomialDegreeOfGrowthOfAutomaton").
\beginexample
gap> B:=AutomGroup("a=(b,1)(1,2),b=(a,1)");
< a, b >
gap> IsGeneratedByAutomatonOfPolynomialGrowth(B);
true
gap> D:=AutomGroup("a=(a,b)(1,2),b=(b,a)");
< a, b >
gap> IsGeneratedByAutomatonOfPolynomialGrowth(D);
false
\endexample


\>IsGeneratedByBoundedAutomaton( <G> ) P

For a group <G> generated by all states of finite automaton (see "IsAutomatonGroup")
determines whether this automaton is bounded in terms of Sidki~\cite{sidki:acyclic}.

See also `IsGeneratedByAutomatonOfPolynomialGrowth' ("IsGeneratedByAutomatonOfPolynomialGrowth")
and `PolynomialDegreeOfGrowthOfAutomaton' ("PolynomialDegreeOfGrowthOfAutomaton").
\beginexample
gap> B:=AutomGroup("a=(b,1)(1,2),b=(a,1)");
< a, b >
gap> IsGeneratedByBoundedAutomaton(B);
true
gap> C:=AutomGroup("a=(a,b)(1,2),b=(b,c),c=(c,1)(1,2)");
< a, b >
gap> IsGeneratedByBoundedAutomaton(C);
false
\endexample


\>PolynomialDegreeOfGrowthOfAutomaton( <G> ) P

For a group <G> generated by all states of finite automaton (see "IsAutomatonGroup")
of polynomial growth in terms of Sidki~\cite{sidki:acyclic} determines the degree of
polynomial growth of this automaton. This degree is 0 if and only if automaton is bounded.
If the growth of automaton is exponential returns `fail'.

See also `IsGeneratedByAutomatonOfPolynomialGrowth' ("IsGeneratedByAutomatonOfPolynomialGrowth")
and `IsGeneratedByBoundedAutomaton' ("IsGeneratedByBoundedAutomaton").
\beginexample
gap> B:=AutomGroup("a=(b,1)(1,2),b=(a,1)");
< a, b >
gap> PolynomialDegreeOfGrowthOfAutomaton(B);
0
gap> C:=AutomGroup("a=(a,b)(1,2),b=(b,c),c=(c,1)(1,2)");
< a, b >
gap> PolynomialDegreeOfGrowthOfAutomaton(C);
2
\endexample


\>MarkovOperator( <G>, <lev> ) F

Computes the matrix of Markov operator related to group <G> on the <lev>-th level
of a tree.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Properties and operations for contracting groups}

\>AutomNucleus( <G> ) AM

Tries to compute the <nucleus> (the minimal set that need not contain original
generators) of a self-similar group <G>. It uses `FindNucleus' (see "FindNucleus")
operation and behaves accordingly: if the group is not contracting it will loop
forever. See also "NucleusIncludingGeneratingSet".

\beginexample
gap> AutomNucleus(Basilica);
[ e, u, v, u^-1, v^-1, u^-1*v, v^-1*u ]
\endexample


\>NucleusIncludingGeneratingSet( <G> ) AM

Tries to compute the generating set of the group which includes original
generators and the <nucleus> (the minimal set that need not contain original
generators) of a self-similar group <G>. It uses `FindNucleus' operation
and behaves accordingly: if the group is not contracting
it will loop forever (modulo memory constraints, of course).
See also "AutomNucleus".

\beginexample
gap> NucleusIncludingGeneratingSet(Basilica);
[ e, u, v, u^-1, v^-1, u^-1*v, v^-1*u ]
\endexample


\>NucleusIncludingGeneratingSetAutom( <G> ) AM

Computes automaton of nucleus.


\>ContractingLevel( <G> ) AM

Given a contracting group <G> with nucleus $N$, stored in
`NucleusIncludingGeneratingSet'(<G>) (see "NucleusIncludingGeneratingSet") computes the
minimal level $n$, such that for every vertex $v$ of the $n$-th
level and all $g, h \in N$ the section $gh|_v \in N$.

In case if it is not known whether <G> is contracting it first tries to compute
the nucleus. If <G> is happened to be noncontracting, it will loop forever. One can
also use `IsNoncontracting' (see "IsNoncontracting") or `FindNucleus' (see
"FindNucleus") directly.
\beginexample
gap> ContractingLevel(GrigorchukGroup);
1
gap> ContractingLevel(Basilica);
2
\endexample


\>ContractingTable( <G> ) AM

Given a contracting group <G> with nucleus $N$ of size $k$, stored in
`NucleusIncludingGeneratingSet'(<G>)~(see "NucleusIncludingGeneratingSet")
computes the $k\times k$ table, whose
[i][j]-th entry contains decomposition of $N$[i]$N$[j] on
the `ContractingLevel'(<G>) level~(see "ContractingLevel"). By construction the sections of
$N$[i]$N$[j] on this level belong to $N$. This table is used in the
algorithm solving the word problem in polynomial time.

In case if it is not known whether <G> is contracting it first tries to compute
the nucleus. If <G> is happened to be noncontracting, it will loop forever. One can
also use `IsNoncontracting' (see "IsNoncontracting") or `FindNucleus' (see
"FindNucleus") directly.
\beginexample
gap> ContractingTable(GrigorchukGroup);
[ [ (1, 1), (1, 1)(1,2), (a, c), (a, d), (1, b) ],
  [ (1, 1)(1,2), (1, 1), (c, a)(1,2), (d, a)(1,2), (b, 1)(1,2) ],
  [ (a, c), (a, c)(1,2), (1, 1), (1, b), (a, d) ],
  [ (a, d), (a, d)(1,2), (1, b), (1, 1), (a, c) ],
  [ (1, b), (1, b)(1,2), (a, d), (a, c), (1, 1) ] ]
\endexample


\>UseContraction( <G> ) AM

For a contracting automaton group <G> determines whether to use the algorithm
of polynomial complexity solving the word problem in the group. By default
it is set to <true> as soon as the nucleus of the group was computed. Sometimes
when the nucleus is very big, the standard algorithm of exponential complexity
is faster for short words, but this heavily depends on the group. Therefore
the decision on which algorithm to use is left to the user. To use the
exponential algorithm one can change the value of `UseContraction'(<G>) by
`SetUseContraction'(<G>, <false>).

Below we provide an example which shows that both methods can be of use.
\beginexample
gap> G:=AutomGroup("a=(b,b)(1,2),b=(c,a),c=(a,a)");;
gap> IsContracting(G);
true
gap> Length(AutomNucleus(G));
41
gap> Order(a); Order(b); Order(c);
2
2
2
gap> SetUseContraction(G,true);
gap> H:=Group(a*b,b*c);;
gap> St2:=StabilizerOfLevel(H,2);time;
< b*c*b*c, b^-1*a^-1*b*c*b^-1*a^-1*c^-1*b^-1, a*b*a*b*a*b*a*b, a*b^2*c*a*b*c^-1*b^
-1, a*b^2*c*b*c*b^-1*a^-1, b*c*a*b^2*c*a*b, b*c*a*b*a*b*c^-1*b^-2*a^-1*b^-1*a^
-1, a*b*a*b^2*c*a*b*c^-1*b^-2*a^-1, a*b*a*b^2*c*b*c*b^-1*a^-1*b^-1*a^-1 >
741
gap> IsAbelian(St2);time;
true
11977
gap> SetUseContraction(G,false);
gap> H:=Group(a*b,b*c);
gap> St2:=StabilizerOfLevel(H,2);;time;
240
gap> IsAbelian(St2);time;
true
542060
\endexample
Here we show that the group <G> is virtually abelian. First we check that the group
is contracting. Then we see that the size of the nucleus is 41. Since all of generators have
order 2, the subgroup $H = \langle ab,bc \rangle$ has index 2 in <G>. Now we compute
the stabilizer of the second level in $H$ and verify, that it is abelian by 2 methods:
with and without using the contraction. We see, that the time required to compute the stabilizer
is approximately the same in both methods, while verification of commutativity works much faster
with contraction. Here it was enough to consider the first level stabilizer, but the difference
in performance of two methods is better seen for the second level stabilizer.


\>AutomPortrait( <a> ) F
\>AutomPortraitBoundary( <a> ) F
\>AutomPortraitDepth( <a> ) F

Constructs the portrait of an element <a> of a
contracting group $G$. The portrait of <a> is defined recursively as follows.
For $g$ in the nucleus of $G$ the portrait is just $[g]$. For any other
element $g=(g_1,g_2,...,g_d)\sigma$ the portrait of $g$ is
$[\sigma, `AutomPortrait'(g_1), ..., `AutomPortrait'(g_d)]$, where $d$ is
the degree of the tree. This structure describes a tree whose inner vertices
are labelled by permutations from $S_d$ and the leaves are labelled by
the elements of the nucleus. The contraction in $G$ guarantees that the
portrait of any element is finite.

The portraits may be considered as a ``normal forms''
of the elements of $G$, since different elements have different portraits.

One also can be interested only in the boundary of a portrait, which consists
of all leaves of the portrait. This boundary can be described by an ordered set of
pairs $[level_i, g_i]$, $i=1,\ldots,r$ representing the leaves of the tree ordered from left
to right (where $level_i$ and $g_i$ are the level and the label of the $i$-th leaf
correspondingly). `AutomPortraitBoundary'(<a>) computes this boundary. It returns a list
consisting of 2 components. The first one is just the degree of the tree, and the
second one is a list of pairs described above.

`AutomPortraitDepth'( <a> ) returns the depth of the portrait, i.e. the minimal
level such that all sections of <a> at this level belong to the nucleus of $G$.

\beginexample
gap> B:=AutomGroup("a=(b,1)(1,2),b=(a,1)");
< a, b >
gap> AutomPortrait(a^3*b^-2*a);
[ (), [ (), [ (), [ b ], [ b ] ], [ 1 ] ],
  [ (), [ (), [ b ], [ a^-1*b ] ], [ b^-1 ] ] ]
gap> AutomPortrait(a^3*b^-2*a^3);
[ (), [ (), [ (1,2), [ (), [ (), [ b ], [ b ] ], [ 1 ] ], [ b ] ], [ 1 ] ],
  [ (), [ (1,2), [ (), [ (), [ b ], [ b ] ], [ 1 ] ], [ a^-1*b ] ], [ b^-1 ] ] ]
gap> AutomPortraitBoundary(a^3*b^-2*a^3);
[ 2, [ [ 5, b ], [ 5, b ], [ 4, 1 ], [ 3, b ], [ 2, 1 ], [ 5, b ], [ 5, b ],
      [ 4, 1 ], [ 3, a^-1*b ], [ 2, b^-1 ] ] ]
gap> AutomPortraitDepth(a^3*b^-2*a^3);
5
\endexample



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
