% This file was created automatically from treeautgrp.msk.
% DO NOT EDIT!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Properties and operations for all groups acting on trees}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations with group elements}

\>Perm( <a>[, <lev>] ) O

Returns permutation induced by tree automorphism <a> on the level <lev>
(or first level if <lev> is not given). See also
`TransformationOnLevel'~("TransformationOnLevel").


\>Word( <a> ) O

Returns <a> as an associative word in generators of the self-similar group
to which <a> belongs.


\>State( <a>, <v> ) O

Returns the "state" of given automorphism at the given vertex.
Vertex <v> can be a list representing vertex; or a positive integer
representing a vertex at the first level of the tree.


\>Expand( <a>[, <k>] ) O

Returns an ``expanded'' form of tree homomorphism <a>, i.e. the
representation of the form $$a = (a_1, a_2, ..., a_{d_1\times...\times d_k})s$$
where $a_i$ are the states of <a> at the <k>-th level, and $s$ is the
transformation of the k-th level. By default <k> is equal to 1.


\>PermOnLevel( <a>, <k> ) O

Does the same thing as `Perm'~("Perm").


\>IsSphericallyTransitive( <G> ) P

Whether group <G> is spherically transitive (see~"spherically
transitive").


\>IsTransitiveOnLevel( <a>, <lev> ) O

Whether <a> acts transitively on level <lev>.




  [1,2,1,2]^a
  k^a

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations with groups}

\>IsFractal( <G> ) P

Whether group <G> is fractal.


\>IsSphericallyTransitive( <G> ) P

Whether group <G> is spherically transitive (see~"spherically
transitive").


\>IsTransitiveOnLevel( <a>, <lev> ) O

Whether <a> acts transitively on level <lev>.


\>IsSelfSimilar( <G> ) P

Whether semigroup <G> is "self-similar".


\>AbelImage( <obj> ) A

Returns image of <obj> in canonical projection onto abelianization of
the full group of tree automorphisms, represented as a subgroup of additive
group of rational functions.
XXX it doesn't make sense for non-invertible automata, does it?


\>PermGroupOnLevel( <G>, <k> ) O

Returns group of permutations induced by action of group <G> at the <k>-th
level.


\>StabilizerOfLevel( <G>, <k> ) O

Returns stabilizer of the <k>-th level.


\>StabilizerOfFirstLevel( <G> ) A

Returns stabilizer of the first level, see also~"StabilizerOfLevel".


\>StabilizerOfVertex( <G>, <v> ) O

Returns stabilizer of the vertex <v>. <v> can be a list represnting a
vertex, or a positive intger representing a vertex at the first level.


\>FixesLevel( <obj>, <lev> ) O

Whether <obj> fixes level <lev>, i.e. fixes every vertex at the level
<lev>.


\>FixesVertex( <obj>, <v> ) O

Whether <obj> fixes vertex <v>. Vertex <v> may be given as a list, or as
a positive integer, in which case it denotes <v>-th vertex at the first
level.


\>Projection( <G>, <v> ) O
\>ProjectionNC( <G>, <v> ) O

Returns projection of the group <G> at the vertex <v>. <G> must fix the
the vertex <v>, otherwise `Error'() will be called. `ProjectionNC' does the
same thing, except it does not check whether <G> fixes vertex <v>.


\>ProjStab( <G>, <v> ) O

Returns projection of the stabilizer of <v> at itself. It is a shortcut for
`Projection'(`StabilizerOfVertex'(G, v), v) (see "Projection",
"StabilizerOfVertex").


\>FindGroupElement( <G>, <func>, <val>, <max_len> ) F
\>FindGroupElements( <G>, <func>, <val>, <max_len> ) F

The first function enumerates elements of the group <G> until it finds
an element $g$ of length at most <max_len>, for which <func>($g$)=<val>. Returns $g$.

The second function enumerates elements of the group of length at most <max_len>
and returns the list of elements $g$, for which <func>($g$)=<val>.

The following examlpe illustrates how one can find an element of order 16 in
Grigorchuk group and the list of all such elements of length at most 5.
\beginexample
gap> FindGroupElement(GrigorchukGroup,Order,16,5);
a*b
gap> FindGroupElements(GrigorchukGroup,Order,16,5);
[ a*b, b*a, c*a*d, d*a*c, a*b*a*d, a*c*a*d, a*d*a*b, a*d*a*c, b*a*d*a, c*a*d*a,
  d*a*b*a, d*a*c*a, a*c*a*d*a, a*d*a*c*a, b*a*b*a*c, b*a*c*a*c, c*a*b*a*b,
  c*a*c*a*b ]
\endexample


\>FindElementOfInfiniteOrder( <G>, <max_len>, <depth> ) F
\>FindElementsOfInfiniteOrder( <G>, <max_len>, <depth> ) F

The first function enumerates elements of the group <G> up to length <max_len>
until it finds an element $g$ of infinite order, such that
`OrderUsingSections'($g$,<depth>) is `infinity' (see "OrderUsingSections").
In other words all sections of every element up to depth <depth> are
investigated. In case if the element belongs to the group generated by bounded
automaton (see "IsGeneratedByBoundedAutomaton") one can set <depth> to be `infinity'.

The second function returns the list of all such elements up to length <max_len>.

\beginexample
gap> G:=AutomGroup("a=(1,1)(1,2),b=(a,c),c=(b,1)");
< a, b, c >
gap> FindElementOfInfiniteOrder(G,5,10);
a*b*c
\endexample


\>`AutomGroupGrowth'{AutomGroupGrowth}@{`AutomGroupGrowth'} F

Computes the first <max_len> values of the growth function of a group <G>


\>AutomGroupElements( <G>, <max_len> ) F

Enumerates all elements of a self-similar group <G> up to length <max_len>



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
