%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Introduction}

The project was originally started in 2000 mostly for personal use. It was gradually
expandig during consequent years, including both addition of new algorithms and simplification of
user interface. It was used in the process of classification of groups generated by $3$-state
automata over 2-letter alphabet.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Short math background}

This package deals mostly with groups acting on rooted trees. In 
this section we recall necessary definitions and notations that will 
be used throughout the manual. For more detailed introduction in the 
theory of groups generated by automata we refer the reader 
to~\cite{gns00:automata}. 

The \emph{regular homogeneous rooted tree of degree $d$ (or $d$-ary 
tree)} is an infinite connected tree with selected vertex, called 
\emph{the root}, in which the degree of every vertex except the root 
is $d+1$ and the degree of the root is $d$. A rooted tree of degree 
$2$ is called \emph{the binary tree}.

The $n$-th \emph{level} of the tree consists of all vertices located 
at distance $n$ from the root (here we mean combinatorial distance 
in the graph).

Similarly one defines \emph{spherically homogeneous} rooted trees as 
rooted trees, such that the degrees of all vertices of each level 
coincide.

Given a finite alphabet $X=\{1,2,\ldots,d\}$ the set $X^*$ of all 
finite words over $X$ may be endowed with the structure of $d$-ary 
tree in which the empty word $\emptyset$ is the \emph{root}, the 
\emph{level} $n$ in $X^*$ consists of the words of length $n$ over 
$X$ and every vertex $v$ has $d$ children, labeled by $vx$, for $x 
\in X$.

Any automorphism $f$ of the rooted tree $T$ fixes the root and the 
levels. For any vertex $v$ of the tree automorphism $f$ induces the 
automorphism $f|_v$ of the subtree hanging down from vertex $v$ by 
$f|_v(u)=w$ if $f(vu)=v'w$ for some $v'\in X^{|v|}$ from the same 
level as $v$. This automorphism is called \emph{the section} of $f$ 
at $v$. 

If the tree $T$ is regular, then the subtrees hanging down from 
vertices of $T$ are canonically isomorphic to $T$ and, thus, the 
sections of any automotphism $f$ of $T$ can be considered as 
automorphisms of $T$ again.

A group $G$ of automorphisms of regular rooted tree $T$ is called 
\emph{self-similar} if all sections of every element of $G$ belong 
to $G$.

A finitely generated self-similar group $G$ is called 
\emph{contracting} if there is a finite set $N$ of elements of $G$, 
such that for any $g\in G$ there is a level $n$ such that all 
sections of $g$ at vertices of levels bigger than $n$ belong to $N$.
The smallest set with such property is called the \emph{nucleus} of 
$G$.

Any automorphism $f$ of a rooted tree can be decomposed as 
\[f=(f_1,f_2,\ldots,f_d)\sigma,\] 

where $f_1,\ldots,f_d$ are the sections of $f$ at the vertices of 
the first level and $\sigma$ is a permutation which permutes the 
subtrees hanging down from these vertices.

This notation is very convenient for performing multiplication of 
elements. If $f=(f_1,f_2,\ldots,f_d)\sigma$ and 
$g=(g_1,g_2,\ldots,g_d)\pi$, then 

\[fg=(f_1g_{\sigma(1)},\ldots,f_dg_{\sigma(d)})\sigma\pi,\] 

\[f^{-1}=(f_{\sigma^{-1}(1)}^{-1},\ldots,f_{\sigma^{-1}(d)}^{-1})\sigma^{-1}.\]

The special class of self-similar groups is the class of groups 
generated by finite automata. This class is especially nice from 
algorithmical point of view. Recall basic definitions.

The \emph{Mealy automaton} (\emph{transducer, synchronous 
automaton}, or, simply, \emph{automaton}) is a $4$-tuple 
$A=(Q,X,\rho,\tau)$ where $Q$ is a set of \emph{states}, $X$ is a 
finite \emph{alphabet} of cardinality $d \geq 2$, $\rho:Q \times X 
\to X$ is a map, called \emph{output map}, $\tau:Q \times X \to Q$ 
is a map, called \emph{transition map}. 

If for each state $q$ in $Q$, the restriction $\rho_q: X \to X$ 
given by $\rho_q(x)=\rho(q,x)$ is a permutation, i.e. $\rho_q \in 
\Sym(X)$, the automaton is called \emph{finite}.

If the set $Q$ of states is finite, the automaton is called 
\emph{finite}.

If some state $q\in Q$ of automaton $A$ is selected to be initial, 
the automaton is called \emph{initial} and denoted $A_q$. 

An initial automaton naturally acts on $X^*$ by homomorphisms 
(automorphisms in case of invertible automation). Given a word 
$x_1x_2\ldots x_n$ the automaton starts at the initial state $q$, 
reads the first input letter $x_1$, outputs the letter $\rho_q(x_1)$ 
and changes its state to $q_1=\tau(q,x_1)$. The rest of the input 
word is handled by the new state $q_1$ in the same way. Formally 
speaking, the functions $\rho$ and $\tau$ can be extended to $\rho:Q 
\times X^* \to X^*$ and $\tau:Q \times X^* \to Q$.

Given an automaton $A$ the group $G(A)$ of automotphisms of $X^*$ 
generated by the states of $A$ is called the \emph{automaton group} 
defined by $A$.

Every automaton group is self-similar, because the section of $A_q$ 
at vertex $v$ is just $A_{\tau(q,v)}$.

A special case is the case of groups generated by finite automata 
and their subgroups. In this class we can solve a word problem, 
which makes it much nicer from computatoinal point of view.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\Section{Quick example}


Here is how to define Grigorchuk group $G$ and Basilica group $B$

\beginexample
gap> G:=AutomGroup("a=(1,1)(1,2),b=(a,c),c=(a,d),d=(1,b)");
< a, b, c, d >
gap> B:=AutomGroup("u=(v,1)(1,2),v=(u,1)");
< u, v >
\endexample

Now we can compute several properties of $G$ and $B$

\beginexample
gap> IsFinite(G);
false
gap> IsSphericallyTransitive(G);
true
gap> IsFractal(G);
true
gap> IsAbelian(G);
false
gap> IsTransitiveOnLevel(G,4);
true
\endexample

We can also check that $G$ is contracting and compute its nucleus
\beginexample
gap> IsContracting(G);
#I  n=5
true
gap> GroupNucleus(G);
[e, a, b, c, d]
\endexample

The group $G$ is generated by bounded automaton and, thus, is amenable (see \cite{bartholdi-k-n-v:bounded})
\beginexample
gap> IsGeneratedByBoundedAutomaton(G);
true
gap> IsAmenable(G);
true
\endexample


We can compute the stabilizers of levels and vertices
\beginexample
gap> StabilizerOfLevel(G,2);
< c*b^-1, d, a^2, a*c*b^-1*a^-1, a*d*a^-1, b^2, b*c, b*d*b^-1, a*b^2*a^
-1, a*b*c*a^-1, a*b*d*b^-1*a^-1, b*a^2*b^-1, b*a*c*b^-1*a^-1*b^-1, b*a*d*a^-1*b^
-1, a*b*a^2*b^-1*a^-1, a*b*a*c*b^-1*a^-1*b^-1*a^-1, a*b*a*d*a^-1*b^-1*a^
-1, b*a*b*a*b^-1*a^-1*b^-1*a^-1, b*a*b^2*a^-1*b^-1, b*a*b*c*a^-1*b^-1, b*a*b*d*b^
-1*a^-1*b^-1, a*b*a*b*a*b^-1*a^-1*b^-1, a*b*a*b^2*a^-1*b^-1*a^-1, a*b*a*b*c*a^
-1*b^-1*a^-1, a*b*a*b*d*b^-1*a^-1*b^-1*a^-1 >
gap> StabilizerOfVertex(G,[2,1]);
< b, c, d, a^2, a*c*b^-1*a^-1, a*d*a^-1, a*b^2*a^-1, a*b*c*a^-1, a*b*d*b^-1*a^
-1, a*b*a^2*b^-1*a^-1, a*b*a*b*a^-1*b^-1*a^-1, a*b*a*c*a^-1*b^-1*a^-1, a*b*a*d*a^
-1*b^-1*a^-1 >
\endexample

In case of finite group we can produce an isomorphism into permutational group
\beginexample
gap> f:=IsomorphismPermGroup(Group(a,b));
[ a, b ] -> [ (1,2)(3,5)(4,6)(7,9)(8,10)(11,13)(12,14)(15,17)(16,18)(19,21)(20,
    22)(23,25)(24,26)(27,29)(28,30)(31,32), (1,3)(2,4)(5,7)(6,8)(9,11)(10,12)(13,
    15)(14,16)(17,19)(18,20)(21,23)(22,24)(25,27)(26,28)(29,31)(30,32) ]
gap> Size(Image(f));
32
\endexample

Here is how to find relations in $B$ between elements of length not greater than 5.
\beginexample
gap> FindRelations(B,5);
#I  v*u*v*u^-1*v^-1*u*v^-1*u^-1
#I  v*u*v^2*u^-1*v^-1*u*v^-2*u^-1
#I  v^2*u*v*u^-1*v^-2*u*v^-1*u^-1
[ v*u*v*u^-1*v^-1*u*v^-1*u^-1, v*u*v^2*u^-1*v^-1*u*v^-2*u^-1,
  v^2*u*v*u^-1*v^-2*u*v^-1*u^-1 ]
\endexample

Or relations in the subgroup <x=u*v^{-1}, y=v*u>
\beginexample
gap> FindRelationsSubs([u*v^-1,v*u],["x","y"],5);
#I  y*x^2*y*x^-1*y^-2*x^-1
[ y*x^2*y*x^-1*y^-2*x^-1 ]
\endexample


Some basic operations with elements are the following:

The function ``IsOne'' computes whether an element represents the trivial automorphism of the tree
\beginexample
gap> IsOne((a*b)^16);
true
\endexample

Here is how to compute the order (this function might not stop in saome cases)
\beginexample
gap> Order(a*b);
16
gap> Order(u^22*v^-15*u^2*v*u^10);
#I  (u^22*v^-15*u^2*v*u^10)^1 has v as a section at vertex [ 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
#I  (v)^2 has congutate of v as a section at vertex [ 1, 1 ]
infinity
\endexample

One can check if a particular element acts spherically transitively on the tree
\beginexample
gap> IsSphericallyTransitive(a*b);
false
gap> IsSphericallyTransitive(u*v);
true
\endexample


The sections of an element can be obtained as follows
\beginexample
gap> State(u*v^2*u,2);
u^2*v
gap> Expand(u*v^2*u);  
(v, u^2*v)
gap> Expand(u*v^2*u,3);
(v, 1, 1, 1, u*v, 1, u, 1)(1,2)(5,6)
\endexample

To get the action of an element on the vertex or on the particular level of the tree 
use the following commands
\beginexample
gap> [1,2,1,1]^(a*b);
[ 2, 2, 1, 1 ]
gap> PermOnLevel(u*v^2*v,3);
(1,6,4,8,2,5,3,7)
\endexample

The action of the whole group $G$ on some level can be computes via ``PermGroupOnLevel( <G>, <lev> )''.
\beginexample
gap> PermGroupOnLevel(G,3);
Group([ (1,5)(2,6)(3,7)(4,8), (1,3)(2,4)(5,6), (1,3)(2,4), (5,6) ])
gap> Size(last);
128
\endexample

The last example shows how to find all elements of Grigorchuk group of length at most 5, which have order 16.
\beginexample
gap> FindGroupElements(G,Order,16,5);
[ a*b, b*a, c*a*d, d*a*c, a*b*a*d, a*c*a*d, a*d*a*b, a*d*a*c, b*a*d*a, c*a*d*a,
  d*a*b*a, d*a*c*a, a*c*a*d*a, a*d*a*c*a, b*a*b*a*c, b*a*c*a*c, c*a*b*a*b,
  c*a*c*a*b ]
\endexample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
