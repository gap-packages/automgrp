#############################################################################
##
#W  freegrp.gi               automata package                  Yevgen Muntyan
##
##  automata v0.9, started 01/22/2004
##


#############################################################################
##
#F  automata_lt(w1, w2)
##
automata_lt := function(w1, w2)
	local i, er1, er2;

	if Length(w1) <> Length(w2) then
		return Length(w1) < Length(w2);
	fi;

	er1 := LetterRepAssocWord(w1);
	er2 := LetterRepAssocWord(w2);
	for i in [1..Length(er1)] do
		if AbsInt(er1[i]) <> AbsInt(er2[i]) then
			return AbsInt(er1[i]) < AbsInt(er2[i]);
		fi;
		if er1[i] <> er2[i] then
			return er1[i] > er2[i];
		fi;
	od;

	return false;
end;


# #############################################################################
# ##
# #F  automata_swap(list, i, j)
# ##
# automata_swap := function(list, i, j)
# 	local t;
# 
# 	t := list[i];
# 	list[i] := list[j];
# 	list[j] := t;
# 	
# 	return;
# end;


#############################################################################
##
#M  Nielsen(<list>)
#M  NielsenBack(<list>)
##
##	It calls appropriate method depending on first element of <list>.
##
##	Returned value is triple [result, transform, did_something] :
##		<result> is the list of words (or whatever depending on type of 
##			argument) obtained from <list> using Nielsen transformations;
##			lexicographic ordering on set of words is generated by the following
##			ordering: x_1 < x_1^{-1} < x_2 < x_2^{-1} < ...
##		<transform> is the list of words for obtaining <result> from 
##			<list> by substituting
##		<did_something> is true if <result> differs from <list> and is
##			false otherwise
##
##	NielsenBack is almost identical to Nielsen: the difference is in the 
##		the order of comparisons performed inside of main loop;
##		it makes Mihaylov feel better?
##
InstallMethod(Nielsen, [IsList],
function(list)
	if IsEmpty(list) or not IsDenseList(list) then
		Error("Nielsen(IsList): argument is empty list\n");
	fi;
	return Nielsen(list, list[1]);
end);

InstallMethod(NielsenBack, [IsList],
function(list)
	if IsEmpty(list) or not IsDenseList(list) then
		Error("NielsenBack(IsList): argument is empty list\n");
	fi;
	return NielsenBack(list, list[1]);
end);


#############################################################################
##
#M  Nielsen(<words_list>, <associative_word>)
##
InstallOtherMethod(Nielsen, [IsList, IsAssocWord],
function(words_list, fictive_arg)
	local result, transform, did_something, n, i, j, try_again, tmp;
	
	n := Length(words_list);
	result := ShallowCopy(words_list);
	transform := ShallowCopy(FreeGeneratorsOfFpGroup(FreeGroup(n)));
	did_something := false;
	try_again := true;
	
	for i in [1..n] do
		if not IsAssocWord(result[i]) then
			Error("Nielsen(IsList, IsAssocWord): ", i, "-th element of list is not associative word\n");
		fi;
	od;
	
	while try_again do
		try_again := false;
		
		for i in [1..n] do
		for j in [1..n] do
			
			if i = j then
				if automata_lt(result[i]^-1, result[i]) then
					result[i] := result[i]^-1;
					transform[i] := transform[i]^-1;
					did_something := true;
					try_again := true;
				fi;
				continue;
			fi;
			
			if i > j and automata_lt(result[i], result[j]) then
				tmp := result[i];
				result[i] := result[j];
				result[j] := tmp;
				tmp := transform[i];
				transform[i] := transform[j];
				transform[j] := tmp;
				did_something := true;
				try_again := true;
			fi;
			
			if automata_lt(result[i]*result[j], result[i]) then
				result[i] := result[i]*result[j];
				transform[i] := transform[i]*transform[j];
				did_something := true;
				try_again := true;
			fi;
			if automata_lt(result[i]*result[j], result[j]) then
				result[j] := result[i]*result[j];
				transform[j] := transform[i]*transform[j];
				did_something := true;
				try_again := true;
			fi;
			
			if automata_lt(result[i]^-1*result[j], result[i]) then
				result[i] := result[i]^-1*result[j];
				transform[i] := transform[i]^-1*transform[j];
				did_something := true;
				try_again := true;
			fi;
			if automata_lt(result[i]^-1*result[j], result[j]) then
				result[j] := result[i]^-1*result[j];
				transform[j] := transform[i]^-1*transform[j];
				did_something := true;
				try_again := true;
			fi;
			
			if automata_lt(result[i]*result[j]^-1, result[i]) then
				result[i] := result[i]*result[j]^-1;
				transform[i] := transform[i]*transform[j]^-1;
				did_something := true;
				try_again := true;
			fi;
			if automata_lt(result[i]*result[j]^-1, result[j]) then
				result[j] := result[i]*result[j]^-1;
				transform[j] := transform[i]*transform[j]^-1;
				did_something := true;
				try_again := true;
			fi;
			
			if automata_lt(result[i]^-1*result[j]^-1, result[i]) then
				result[i] := result[i]^-1*result[j]^-1;
				transform[i] := transform[i]^-1*transform[j]^-1;
				did_something := true;
				try_again := true;
			fi;
			if automata_lt(result[i]^-1*result[j]^-1, result[j]) then
				result[j] := result[i]^-1*result[j]^-1;
				transform[j] := transform[i]^-1*transform[j]^-1;
				did_something := true;
				try_again := true;
			fi;
		od;
		od;
	od;
	
	return [result, transform, did_something];
end);


#############################################################################
##
#M  NielsenBack(<words_list>, <associative_word>)
##
InstallOtherMethod(NielsenBack, [IsList, IsAssocWord],
function(words_list, fictive_arg)
	local result, transform, did_something, n, i, j, try_again, tmp;
	
	n := Length(words_list);
	result := ShallowCopy(words_list);
	transform := ShallowCopy(FreeGeneratorsOfFpGroup(FreeGroup(n)));
	did_something := false;
	try_again := true;
	
	for i in [1..n] do
		if not IsAssocWord(result[i]) then
			Error("NielsenBack(IsList, IsAssocWord): ", i, "-th element of list is not associative word\n");
		fi;
	od;
	
	while try_again do
		try_again := false;
		
		for i in [1..n] do
		for j in [1..n] do
			
			if i = j then
				if automata_lt(result[i]^-1, result[i]) then
					result[i] := result[i]^-1;
					transform[i] := transform[i]^-1;
					did_something := true;
					try_again := true;
				fi;
				continue;
			fi;
			
			if i > j and automata_lt(result[i], result[j]) then
				tmp := result[i];
				result[i] := result[j];
				result[j] := tmp;
				tmp := transform[i];
				transform[i] := transform[j];
				transform[j] := tmp;
				did_something := true;
				try_again := true;
			fi;
			
			if automata_lt(result[i]^-1*result[j]^-1, result[j]) then
				result[j] := result[i]^-1*result[j]^-1;
				transform[j] := transform[i]^-1*transform[j]^-1;
				did_something := true;
				try_again := true;
			fi;
			if automata_lt(result[i]^-1*result[j]^-1, result[i]) then
				result[i] := result[i]^-1*result[j]^-1;
				transform[i] := transform[i]^-1*transform[j]^-1;
				did_something := true;
				try_again := true;
			fi;
			
			if automata_lt(result[i]*result[j]^-1, result[j]) then
				result[j] := result[i]*result[j]^-1;
				transform[j] := transform[i]*transform[j]^-1;
				did_something := true;
				try_again := true;
			fi;
			if automata_lt(result[i]*result[j]^-1, result[i]) then
				result[i] := result[i]*result[j]^-1;
				transform[i] := transform[i]*transform[j]^-1;
				did_something := true;
				try_again := true;
			fi;
			
			if automata_lt(result[i]^-1*result[j], result[i]) then
				result[i] := result[i]^-1*result[j];
				transform[i] := transform[i]^-1*transform[j];
				did_something := true;
				try_again := true;
			fi;
			if automata_lt(result[i]^-1*result[j], result[j]) then
				result[j] := result[i]^-1*result[j];
				transform[j] := transform[i]^-1*transform[j];
				did_something := true;
				try_again := true;
			fi;
			
			if automata_lt(result[i]*result[j], result[j]) then
				result[j] := result[i]*result[j];
				transform[j] := transform[i]*transform[j];
				did_something := true;
				try_again := true;
			fi;
			if automata_lt(result[i]*result[j], result[i]) then
				result[i] := result[i]*result[j];
				transform[i] := transform[i]*transform[j];
				did_something := true;
				try_again := true;
			fi;			
		od;
		od;
	od;
	
	return [result, transform, did_something];
end);


# #############################################################################
# ##
# #O  NielsenMihaylov(<words_list>, m, n)
# #M  NielsenMihaylov(<words_list>, m, n)
# ##
# DeclareOperation("NielsenMihaylov", [IsList, IsInt, IsInt]);
# InstallOtherMethod(NielsenMihaylov, [IsList, IsInt, IsInt],
# function(words_list, m, n)
# 	local result, transform, did_something, i, j, try_again, tmp;
# 	
# 	if m + n <> Length(words_list) then
# 		Error("NielsenMihaylov(IsList, IsInt, IsInt): m + n <> Length(words_list)\n");
# 	fi;
# 	
# 	if m <= 0 or n <= 0 then
# 		Error("NielsenMihaylov(IsList, IsInt, IsInt): m or n is not positive\n");
# 	fi;
# 	
# 	for i in [1..m+n] do
# 		if not IsAssocWord(words_list[i]) then
# 			Error("NielsenMihaylov(IsList, IsAssocWord): ", i, "-th element of list is not associative word\n");
# 		fi;
# 	od;
# 	
# 	result := ShallowCopy(words_list);
# 	transform := ShallowCopy(FreeGeneratorsOfFpGroup(FreeGroup(m+n)));
# 	did_something := false;
# 	try_again := true;
# 
# Print("0: ", result, "\n");					
# Print("0: ", transform, "\n");						
# 		
# 	while try_again do
# 		try_again := false;
# 		
# 		for i in [1..m] do
# 			for j in [1..m] do
# 				if j = i then
# 					if automata_lt(result[i]^-1, result[i]) then
# 						result[i] := result[i]^-1;
# 						transform[i] := transform[i]^-1;
# 						try_again := true;
# 						did_something := true;
# Print("1: ", i, " ", j, "", result, "\n");					
# 					fi;
# 					continue;
# 				fi;
# 				
# 				if i > j and automata_lt(result[i], result[j]) then
# 					tmp := result[i];
# 					result[i] := result[j];
# 					result[j] := tmp;
# 					tmp := transform[i];
# 					transform[i] := transform[j];
# 					transform[j] := tmp;
# 					try_again := true;
# 					did_something := true;
# Print("2: ", i, " ", j, "", result, "\n");					
# 				fi;
# 			
# 				if automata_lt(result[i]*result[j], result[i]) then
# 					result[i] := result[i]*result[j];
# 					transform[i] := transform[i]*transform[j];
# 					did_something := true;
# 					try_again := true;
# Print("3: ", i, " ", j, "", result, "\n");					
# 				fi;
# 				if automata_lt(result[j]*result[i], result[i]) then
# 					result[i] := result[j]*result[i];
# 					transform[i] := transform[j]*transform[i];
# 					did_something := true;
# 					try_again := true;
# Print("4: ", i, " ", j, "", result, "\n");					
# 				fi;
# 			
# 				if automata_lt(result[i]*result[j]^-1, result[i]) then
# 					result[i] := result[i]*result[j]^-1;
# 					transform[i] := transform[i]*transform[j]^-1;
# 					did_something := true;
# 					try_again := true;
# Print("5: ", i, " ", j, "", result, "\n");					
# 				fi;
# 				if automata_lt(result[j]*result[i]^-1, result[i]) then
# 					result[i] := result[j]*result[i]^-1;
# 					transform[i] := transform[j]*transform[i]^-1;
# 					did_something := true;
# 					try_again := true;
# Print("6: ", i, " ", j, "", result, "\n");					
# 				fi;
# 			
# 				if automata_lt(result[i]^-1*result[j], result[i]) then
# 					result[i] := result[i]^-1*result[j];
# 					transform[i] := transform[i]^-1*transform[j];
# 					did_something := true;
# 					try_again := true;
# Print("7: ", i, " ", j, "", result, "\n");					
# 				fi;
# 				if automata_lt(result[j]^-1*result[i], result[i]) then
# 					result[i] := result[j]^-1*result[i];
# 					transform[i] := transform[j]^-1*transform[i];
# 					did_something := true;
# 					try_again := true;
# Print("8: ", i, " ", j, "", result, "\n");					
# 				fi;
# 			
# 				if automata_lt(result[i]^-1*result[j], result[i]) then
# 					result[i] := result[i]^-1*result[j];
# 					transform[i] := transform[i]^-1*transform[j];
# 					did_something := true;
# 					try_again := true;
# Print("9: ", i, " ", j, "", result, "\n");					
# 				fi;
# 				if automata_lt(result[j]^-1*result[i]^-1, result[i]) then
# 					result[i] := result[j]^-1*result[i]^-1;
# 					transform[i] := transform[j]^-1*transform[i]^-1;
# 					did_something := true;
# 					try_again := true;
# Print("10: ", i, " ", j, "", result, "\n");					
# 				fi;
# 			od;
# 			
# 			for j in [m+1..m+n] do
# 				if automata_lt(result[i]^result[j], result[i]) then
# 					result[i] := result[i]^result[j];
# 					transform[i] := transform[i]^transform[j];
# 					did_something := true;
# 					try_again := true;
# Print("11: ", i, " ", j, "", result, "\n");					
# 				fi;
# 			
# 				if automata_lt(result[i]^(result[j]^-1), result[i]) then
# 					result[i] := result[i]^(result[j]^-1);
# 					transform[i] := transform[i]^(transform[j]^-1);
# 					did_something := true;
# 					try_again := true;
# Print("12: ", i, " ", j, "", result, "\n");					
# 				fi;
# 				
# 				if automata_lt((result[i]^-1)^result[j], result[i]) then
# 					result[i] := (result[i]^-1)^result[j];
# 					transform[i] := (transform[i]^-1)^transform[j];
# 					did_something := true;
# 					try_again := true;
# Print("13: ", i, " ", j, "", result, "\n");					
# 				fi;
# 			
# 				if automata_lt((result[i]^-1)^(result[j]^-1), result[i]) then
# 					result[i] := (result[i]^-1)^(result[j]^-1);
# 					transform[i] := (transform[i]^-1)^(transform[j]^-1);
# 					did_something := true;
# 					try_again := true;
# Print("14: ", i, " ", j, "", result, "\n");					
# 				fi;			
# 			od;
# 		od;
# 		
# 		for i in [m+1..m+n] do
# 			for j in [1..m] do
# 				if IsOne(result[i]) and not IsOne(result[j]) 
# 					and not Contains(result{[m+1..m+n]}, result[j]) then
# 						result[i] := result[j];	
# 						transform[i] := transform[i] * transform[j];
# 						did_something := true;
# 						try_again := true;
# Print("31: ", i, " ", j, "", result, "\n");					
# 				fi;
# 				
# 				if automata_lt(result[i]*result[j], result[i]) 
# 					and not IsOne(result[i]*result[j]) then
# 						result[i] := result[i]*result[j];
# 						transform[i] := transform[i]*transform[j];
# 						did_something := true;
# 						try_again := true;
# Print("15: ", i, " ", j, "", result, "\n");					
# 				fi;
# 				if automata_lt(result[j]*result[i], result[i]) 
# 					and not IsOne(result[j]*result[i]) then
# 						result[i] := result[j]*result[i];
# 						transform[i] := transform[j]*transform[i];
# 						did_something := true;
# 						try_again := true;
# Print("16: ", i, " ", j, "", result, "\n");					
# 				fi;
# 			
# 				if automata_lt(result[i]*result[j]^-1, result[i]) 
# 					and not IsOne(result[i]*result[j]^-1) then
# 						result[i] := result[i]*result[j]^-1;
# 						transform[i] := transform[i]*transform[j]^-1;
# 						did_something := true;
# 						try_again := true;
# Print("17: ", i, " ", j, "", result, "\n");					
# 				fi;
# 				if automata_lt(result[j]*result[i]^-1, result[i]) 
# 					and not IsOne(result[j]*result[i]^-1) then
# 						result[i] := result[j]*result[i]^-1;
# 						transform[i] := transform[j]*transform[i]^-1;
# 						did_something := true;
# 						try_again := true;
# Print("18: ", i, " ", j, "", result, "\n");					
# 				fi;
# 			
# 				if automata_lt(result[i]^-1*result[j], result[i]) 
# 					and not IsOne(result[i]^-1*result[j]) then
# 						result[i] := result[i]^-1*result[j];
# 						transform[i] := transform[i]^-1*transform[j];
# 						did_something := true;
# 						try_again := true;
# Print("19: ", i, " ", j, "", result, "\n");					
# 				fi;
# 				if automata_lt(result[j]^-1*result[i], result[i]) 
# 					and not IsOne(result[j]^-1*result[i]) then
# 						result[i] := result[j]^-1*result[i];
# 						transform[i] := transform[j]^-1*transform[i];
# 						did_something := true;
# 						try_again := true;
# Print("20: ", i, " ", j, "", result, "\n");					
# 				fi;
# 			
# 				if automata_lt(result[i]^-1*result[j], result[i]) 
# 					and not IsOne(result[i]^-1*result[j]) then
# 						result[i] := result[i]^-1*result[j];
# 						transform[i] := transform[i]^-1*transform[j];
# 						did_something := true;
# 						try_again := true;
# Print("21: ", i, " ", j, "", result, "\n");					
# 				fi;
# 				if automata_lt(result[j]^-1*result[i]^-1, result[i]) 
# 					and not IsOne(result[j]^-1*result[i]^-1) then
# 						result[i] := result[j]^-1*result[i]^-1;
# 						transform[i] := transform[j]^-1*transform[i]^-1;
# 						did_something := true;
# 						try_again := true;
# Print("22: ", i, " ", j, "", result, "\n");					
# 				fi;
# 			od;
# 			
# 			for j in [m+1..m+n] do
# 				if j = i then
# 					if automata_lt(result[i]^-1, result[i]) then
# 						result[i] := result[i]^-1;
# 						transform[i] := transform[i]^-1;
# 						try_again := true;
# 						did_something := true;
# Print("23: ", i, " ", j, "", result, "\n");					
# 					fi;
# 					continue;
# 				fi;
# 			
# 				if i > j and automata_lt(result[i], result[j]) then
# 					tmp := result[i];
# 					result[i] := result[j];
# 					result[j] := tmp;
# 					tmp := transform[i];
# 					transform[i] := transform[j];
# 					transform[j] := tmp;
# 					try_again := true;
# 					did_something := true;
# Print("24: ", i, " ", j, "", result, "\n");					
# 				fi;
# 			
# 				if automata_lt(result[i]*result[j], result[i]) then
# 					result[i] := result[i]*result[j];
# 					transform[i] := transform[i]*transform[j];
# 					did_something := true;
# 					try_again := true;
# Print("32: ", i, " ", j, "", result, "\n");					
# 				fi;
# 				if automata_lt(result[j]*result[i], result[i]) then
# 					result[i] := result[j]*result[i];
# 					transform[i] := transform[j]*transform[i];
# 					did_something := true;
# 					try_again := true;
# Print("33: ", i, " ", j, "", result, "\n");					
# 				fi;
# 			
# 				if automata_lt(result[i]*result[j]^-1, result[i]) then
# 					result[i] := result[i]*result[j]^-1;
# 					transform[i] := transform[i]*transform[j]^-1;
# 					did_something := true;
# 					try_again := true;
# Print("34: ", i, " ", j, "", result, "\n");					
# 				fi;
# 				if automata_lt(result[j]*result[i]^-1, result[i]) then
# 					result[i] := result[j]*result[i]^-1;
# 					transform[i] := transform[j]*transform[i]^-1;
# 					did_something := true;
# 					try_again := true;
# Print("35: ", i, " ", j, "", result, "\n");					
# 				fi;
# 			
# 				if automata_lt(result[i]^-1*result[j], result[i]) then
# 					result[i] := result[i]^-1*result[j];
# 					transform[i] := transform[i]^-1*transform[j];
# 					did_something := true;
# 					try_again := true;
# Print("36: ", i, " ", j, "", result, "\n");					
# 				fi;
# 				if automata_lt(result[j]^-1*result[i], result[i]) then
# 					result[i] := result[j]^-1*result[i];
# 					transform[i] := transform[j]^-1*transform[i];
# 					did_something := true;
# 					try_again := true;
# Print("37: ", i, " ", j, "", result, "\n");					
# 				fi;
# 			
# 				if automata_lt(result[i]^-1*result[j], result[i]) then
# 					result[i] := result[i]^-1*result[j];
# 					transform[i] := transform[i]^-1*transform[j];
# 					did_something := true;
# 					try_again := true;
# Print("38: ", i, " ", j, "", result, "\n");					
# 				fi;
# 				if automata_lt(result[j]^-1*result[i]^-1, result[i]) then
# 					result[i] := result[j]^-1*result[i]^-1;
# 					transform[i] := transform[j]^-1*transform[i]^-1;
# 					did_something := true;
# 					try_again := true;
# Print("39: ", i, " ", j, "", result, "\n");					
# 				fi;
# 			od;
# 		od;
# 	od;
# 	
# 	return [result, transform, did_something];
# end);


InstallMethod(CalculateWord, [IsAssocWord, IsList],
function(w, img)
    local result, i;

    result := One(img[1]);

    for i in [1..NumberSyllables(w)] do
        result := result *
                    img[GeneratorSyllable(w, i)]^ExponentSyllable(w, i);
    od;

    return result;
end);


InstallMethod(CalculateWords, [IsList, IsList],
function(words, domain)
    local result, i;

    result := [];
    for i in [1..Length(words)] do
        result[i] := CalculateWord(words[i], domain);
    od;

    return result;
end);


InstallMethod(Rang, [IsList],
function(list)
    return Rang(list, list[1]);
end);

InstallOtherMethod(Rang, [IsList, IsAssocWord],
function(words, fictive_argument)
    return Length(Difference(Nielsen(words)[1], [One(words[1])]));
end);


#############################################################################
##
#M  Mihaylov(<list>)
##
InstallMethod(Mihaylov, [IsList],
function(pairs)
	local result, i, nie, m, n, w, t;

	if not IsList(pairs[1]) then
		Error("Mihaylov(IsList): first element of list is not IsList\n");
	fi;
	
	if Length(pairs[1]) <> 2 then
		Error("Mihaylov(IsList): can work only with pairs\n");
	fi;
	
	if not IsAssocWord(pairs[1][1]) then
		Error("Mihaylov(IsList): <arg>[1][1] is not IsAssocWord\n");
	fi;
	
	result := StructuralCopy(pairs);
	
##	TODO: do something with m and n	
	
	nie := Nielsen(List(result, p -> p[1]));
	if nie[3] then
		t := StructuralCopy(result);
		for i in [1..Length(result)] do
			t[i][1] := CalculateWord(nie[2][i], List(result, p -> p[1]));
			t[i][2] := CalculateWord(nie[2][i], List(result, p -> p[2]));
		od;
		result := StructuralCopy(t);
	fi;
# if DEBUG_LEVEL > 1 then Print("Mihaylov(IsList): result = ", result, "\n"); fi;

	for i in [1..Length(result)] do
		if not IsOne(result[i][1]) then
			break;
		fi;
	od;
	m := i - 1; n := Length(result) - m;
# if DEBUG_LEVEL > 1 then Print("Mihaylov(IsList): m = ", m, ", n = ", n, "\n"); fi;
	if m = 0 then
		return result;
	fi;
	##	impossible?
	if n = 0 then
		Error("Mihaylov(IsList): n = 0\n");
	fi;	
	

	nie := NielsenMihaylov(List(result, p -> p[2]), m, n);
	if nie[3] then
		t := StructuralCopy(result);
		for i in [1..Length(result)] do
			t[i][1] := CalculateWord(nie[2][i], List(result, p -> p[1]));
			t[i][2] := CalculateWord(nie[2][i], List(result, p -> p[2]));
		od;
		result := StructuralCopy(t);
	fi;
# if DEBUG_LEVEL > 1 then Print("Mihaylov(IsList): result = ", result, "\n"); fi;

	nie := NielsenBack(List(result{[m+1..m+n]}, p -> p[1]));
	if nie[3] then
		t := StructuralCopy(result);
		for i in [1..n] do
			t[m+i][1] := CalculateWord(nie[2][i], List(result{[m+1..m+n]}, p -> p[1]));
			t[m+i][2] := CalculateWord(nie[2][i], List(result{[m+1..m+n]}, p -> p[2]));
		od;
		result := StructuralCopy(t);
	fi;
# if DEBUG_LEVEL > 1 then Print("Mihaylov(IsList): result = ", result, "\n"); fi;

	return result;
end);


#############################################################################
##
#M  Contains(<words_list>, <a>)
##
InstallMethod(Contains, [IsList, IsAssocWord],
function(words, v)
    return Contains(words, v, words[1]);
end);

#############################################################################
##
#M  Contains(<words_list>, <w>, <w>)
##
InstallOtherMethod(Contains, [IsList, IsAssocWord, IsAssocWord],
function(words, v, fictive_argument)
    local proceed, w, lt;

    lt := function(w1, w2)
        local i, er1, er2;

        if Length(w1) <> Length(w2) then
            return Length(w1) < Length(w2);
        fi;

        er1 := LetterRepAssocWord(w1);
        er2 := LetterRepAssocWord(w2);
        for i in [1..Length(er1)] do
            if AbsInt(er1[i]) <> AbsInt(er2[i]) then
                return AbsInt(er1[i]) < AbsInt(er2[i]);
            fi;
            if er1[i] <> er2[i] then
                return er1[i] > er2[i];
            fi;
        od;

        return false;
    end;

    words := Set(Nielsen(words)[1]);

    proceed := true;
    while proceed do
        proceed := false;
        for w in words do
        if lt(v*w, v) then
            v := v*w;
            proceed := true;
        fi;
        if lt(v*w^-1, v) then
            v := v*w^-1;
            proceed := true;
        fi;
        if lt(w*v, v) then
            v := w*v;
            proceed := true;
        fi;
        if lt(w^-1*v, v) then
            v := w^-1*v;
            proceed := true;
        fi;
        od;
    od;

    if IsOne(v) then return true;
    else return false; fi;
end);


#############################################################################
##
#M  NielsenLow(<words_list>, m, n)
##
InstallMethod(NielsenLow, [IsList, IsInt, IsInt],
function(words_list, m, n)
	local result, transform, did_something, i, j, try_again, tmp, nie;
	
##	Error checking should be done outside
#
# 	if m + n <> Length(words_list) then
# 		Error("NielsenLow(IsList, IsInt, IsInt): m + n <> Length(words_list)\n");
# 	fi;
# 	
# 	if m <= 0 or n <= 0 then
# 		Error("NielsenLow(IsList, IsInt, IsInt): m or n is not positive\n");
# 	fi;
# 	
# 	for i in [1..m+n] do
# 		if not IsAssocWord(words_list[i]) then
# 			Error("NielsenLow(IsList, IsAssocWord): ", i, "-th element of list is not associative word\n");
# 		fi;
# 	od;
	
	result := ShallowCopy(words_list);
	transform := ShallowCopy(FreeGeneratorsOfFpGroup(FreeGroup(m+n)));
	did_something := false;
	try_again := true;

# Print("0: ", result, "\n");					
# Print("0: ", transform, "\n");						
		
	while try_again do
		try_again := false;
		
		nie := Nielsen(result{[1..m]});
# Print("123: ", nie, "\n");
		if nie[3] then
			result := Concatenation(CalculateWords(nie[2], result{[1..m]}), result{[m+1..m+n]});
			transform := Concatenation(CalculateWords(nie[2], transform{[1..m]}), transform{[m+1..m+n]});
			did_something := true;
			try_again := true;		
		fi;
# Print("125: ", result, "\n");					
# Print("125: ", transform, "\n");						
		
		for i in [1..m] do			
			for j in [m+1..m+n] do
				if automata_lt(result[i]^result[j], result[i]) then
					result[i] := result[i]^result[j];
					transform[i] := transform[i]^transform[j];
					did_something := true;
					try_again := true;
# Print("11: ", i, " ", j, "", result, "\n");					
				fi;
			
				if automata_lt(result[i]^(result[j]^-1), result[i]) then
					result[i] := result[i]^(result[j]^-1);
					transform[i] := transform[i]^(transform[j]^-1);
					did_something := true;
					try_again := true;
# Print("12: ", i, " ", j, "", result, "\n");					
				fi;
				
				if automata_lt((result[i]^-1)^result[j], result[i]) then
					result[i] := (result[i]^-1)^result[j];
					transform[i] := (transform[i]^-1)^transform[j];
					did_something := true;
					try_again := true;
# Print("13: ", i, " ", j, "", result, "\n");					
				fi;
			
				if automata_lt((result[i]^-1)^(result[j]^-1), result[i]) then
					result[i] := (result[i]^-1)^(result[j]^-1);
					transform[i] := (transform[i]^-1)^(transform[j]^-1);
					did_something := true;
					try_again := true;
# Print("14: ", i, " ", j, "", result, "\n");					
				fi;			
			od;
		od;
	od;
	
	return [result, transform, did_something];
end);


#############################################################################
##
#O  NielsenMihaylov(<words_list>, m, n)
#M  NielsenMihaylov(<words_list>, m, n)
##
InstallOtherMethod(NielsenMihaylov, [IsList, IsInt, IsInt],
function(words_list, m, n)
	local result, transform, did_something, try_again, nie, i, j, tf, pair,
				good_tf, good_pair, tmp;
	
	result := StructuralCopy(words_list);
	transform := ShallowCopy(FreeGeneratorsOfFpGroup(FreeGroup(m+n)));
	did_something := false;
	try_again := true;
	
# Print("0: ", result, " ", transform, "\n");
	while try_again do
		try_again := false;
		
		nie := NielsenLow(result, m, n);
		if nie[3] then
			did_something := true;
			try_again := true;
			result := nie[1];
			transform := CalculateWords(nie[2], transform);
# Print("1: ", result, " ", transform, "\n");
		fi;
		
		nie := Nielsen(result{[m+1..m+n]});
		if nie[3] then
			did_something := true;
			try_again := true;
			result := Concatenation(result{[1..m]}, nie[1]);
			transform := Concatenation(transform{[1..m]}, CalculateWords(nie[2], transform{[m+1..m+n]}));
# Print("2: ", result, " ", transform, "\n");
		fi;
		
		if Rang(result{[m+1..m+n]}) = n then
			if List(result{[m+1..m+n]}, w -> Length(w)) = List([1..n], i -> 1) then
				## ok
				try_again := false;
# Print("3: ", result, " ", transform, "\n");
			else
				##	try to minimize sum of lengths
# Print("4: ", result, " ", transform, "\n");
				good_pair := false;
				for pair in ListX([m+1..m+n], [1..m], function(i,j) return [i,j]; end) do
					good_tf := false;
					for tf in [	[1,1,2,1],[2,1,1,1],[1,-1,2,1],[2,-1,1,1],
											[1,1,2,-1],[2,1,1,-1],[1,-1,2,-1],[2,-1,1,-1]	] do
						tmp := StructuralCopy(result);
						tmp[pair[1]] := tmp[pair[tf[1]]]^tf[2] * tmp[pair[tf[3]]]^tf[4];
						if 	Rang(tmp{[m+1..m+n]}) = n and 
								NumberOfLetters(tmp{[m+1..m+n]}) = NumberOfLetters(result{[m+1..m+n]}) and
								Sum(List(tmp{[m+1..m+n]}, w -> Length(w))) < Sum(List(result{[m+1..m+n]}, w -> Length(w)))
						then
							good_tf := true;
							break;
						fi;
					od;
					if good_tf then
						good_pair := true;
						break;
					fi;
				od;
				if not good_pair then
					##	give up
# Print("7: ", result, " ", transform, "\n");
					return [result, transform, did_something];
				else
					result[pair[1]] := result[pair[tf[1]]]^tf[2] * result[pair[tf[3]]]^tf[4];
					transform[pair[1]] := transform[pair[tf[1]]]^tf[2] * transform[pair[tf[3]]]^tf[4];
					try_again := true;
					did_something := true;
# Print("5: ", result, " ", transform, "\n");
				fi;
			fi;
		else
			##	try to make rang bigger
			for i in [1..m] do
# Print("6: ", result, " ", transform, "\n");
				good_tf := false;
				pair := [m+1, i];
				for tf in [	[1,1,2,1],[2,1,1,1],[1,-1,2,1],[2,-1,1,1],
										[1,1,2,-1],[2,1,1,-1],[1,-1,2,-1],[2,-1,1,-1]	] do
					tmp := StructuralCopy(result);
					tmp[pair[1]] := tmp[pair[tf[1]]]^tf[2] * tmp[pair[tf[3]]]^tf[4];
					if 	Rang(tmp{[m+1..m+n]}) > Rang(result{[m+1..m+n]}) and 
							NumberOfLetters(tmp{[m+1..m+n]}) >= NumberOfLetters(result{[m+1..m+n]}) 
					then
						good_tf := true;
						break;
					fi;
				od;
				if good_tf then
					good_pair := true;
					break;
				fi;
			od;
			if not good_pair then
				##	give up
# Print("8: ", result, " ", transform, "\n");
				return [result, transform, did_something];					
			else
				result[pair[1]] := result[pair[tf[1]]]^tf[2] * result[pair[tf[3]]]^tf[4];
				transform[pair[1]] := transform[pair[tf[1]]]^tf[2] * transform[pair[tf[3]]]^tf[4];
				try_again := true;
				did_something := true;
# Print("9: ", result, " ", transform, "\n");
			fi;
		fi;
	
	od;

	return [result, transform, did_something];


end);


InstallOtherMethod(NumberOfLetters, [IsList],
function(list)
	local letters, i, j;
	
	letters := [];
	for i in [1..Length(list)] do
		for j in [1..NumberSyllables(list[i])] do
			AddSet(letters, GeneratorSyllable(list[i], j)); 
		od;
	od;
	return Length(letters);
end);


# 					if automata_lt(result[p[1]] * result[p[2]], result[p[1]]) then
# 						tf := [1,1,2,1];
# 					elif automata_lt(result[p[2]] * result[p[1]], result[p[1]]) then
# 						tf := [2,1,1,1];
# 					elif automata_lt(result[p[1]]^-1 * result[p[2]], result[p[1]]) then
# 						tf := [1,-1,2,1];
# 					elif automata_lt(result[p[2]]^-1 * result[p[1]], result[p[1]]) then
# 						tf := [2,-1,1,1];
# 					elif automata_lt(result[p[1]] * result[p[2]]^-1, result[p[1]]) then
# 						tf := [1,1,2,-1];
# 					elif automata_lt(result[p[2]] * result[p[1]]^-1, result[p[1]]) then
# 						tf := [2,1,1,-1];
# 					elif automata_lt(result[p[1]]^-1 * result[p[2]]^-1, result[p[1]]) then
# 						tf := [1,-1,2,-1];
# 					elif automata_lt(result[p[2]]^-1 * result[p[1]]^-1, result[p[1]]) then
# 						tf := [2,-1,1,-1];
# 					else
# 						continue;
# 					fi;


