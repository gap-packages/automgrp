% This file was created automatically from elements.msk.
% DO NOT EDIT!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Properties and operations with group and semigroup elements}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Creation of tree automorphisms and homomorphisms}

\>TreeAutomorphism( <states>, <perm> ) O

Constructs a tree automorphism with states <states> and acting
on the first level as permutation <perm>. The <states> must belong to the same family.
\beginexample
gap> G:=AutomatonGroup("a=(a,b)(1,2), b=(a,b)");
< a, b >
gap> c:=TreeAutomorphism([a,b,a,b^2],(1,2)(3,4));
(a, b, a, b^2)(1,2)(3,4)
gap> d:=TreeAutomorphism([b,1,a*b,b],(1,2));
(b, 1, a*b, b)(1,2)
gap> c*d;
(a, b^2, a*b, b^2*a*b)(3,4)
\endexample


\>Representative( <word>, <fam> ) O
\>Representative( <word>, <a> ) O

Given assosiative word <word> constructs a tree homomorphism from the family
<fam>, or to which homomorphism <a> belongs. This function is useful when
one needs to make some operations with associative words. See also `Word' ("Word").
\beginexample
gap> G := AutomatonGroup("a=(a,b)(1,2), b=(a,b)");
< a, b >
gap> F := UnderlyingFreeGroup(G);
<free group on the generators [ a, b ]>
gap> c := Representative( F.1*F.2^2, a);
a*b^2
gap> Decompose(c);
(a*b^2, b*a^2)(1,2)
gap> H := SelfSimilarGroup("x=(x*y,x)(1,2), y=(x^-1,y)");
< x, y >
gap> F := UnderlyingFreeGroup(H);
<free group on the generators [ x, y ]>
gap> c := SelfSim( F.1^-1*F.2, x);
x^-1*y
gap> Decompose(c);
(x^-1*y, y^-1*x^-2)(1,2)
\endexample


%Declaration{AutomFamily}


In the examples below we will consider the elements of the lamplighter and Basilica groups. First 
we define them as
\beginexample
gap> G:=AutomatonGroup("a=(a,b)(1,2),b=(a,b)");
< a, b >
gap> Basilica:=AutomatonGroup("u=(v,1)(1,2),v=(u,1)");
< u, v >
\endexample

Note also that these groups are predefined in a global variable `AG_Groups' (see "Some predefined groups").


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Properties and attributes of tree automorphisms and homomorphisms}


\>IsOne( <a> ) O

Returns whether automorphism <a> acs trivially on the tree. For contracting groups see also 
`UseContraction' ("UseContraction") and `IsOneContr' ("IsOneContr").
\beginexample
gap> IsOne(b*a^-1*b*a^-1);
true
\endexample

\>IsOneContr( <a> ) F

Returns `true' if <a> is trivial automorphism and `false' otherwise. Works for
contracting groups only. Uses polynomial time algorithm.




\>Order( <a> ) O

Computes the order of automorphism <a>. In some cases does not stop. Works always (modulo memory 
restrictions) for groups generated by bounded automata.
\beginexample
gap> Order(a*b^-1);
2
gap> Order(u^35*v^-12*u^2*v^-3);
#I  (u^35*v^-12*u^2*v^-3)^68719476736 has congutate of u^2*v^-3*u^35*v^
-12 as a section at vertex [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
infinity
\endexample

\>OrderUsingSections( <a>[, <max_depth>] ) O

Tries to compute the order of an element <a> by looking at its sections
of depth up to <max_depth>-th level.
If <max_depth> is omitted it is assumed to be `infinity', but then it may not stop. Also note,
that if <max_depth> is not given, it searches the tree in depth first and may be trapped
in some infinite ray, while specifying finite <max_depth> may produce a result by looking at
the section not in that ray.
For bounded automata will always produce a result.
\beginexample
gap> G:=AutomatonGroup("a=(1,1)(1,2),b=(a,c),c=(a,d),d=(1,b)");
< a, b, c, d >
gap> OrderUsingSections(a*b*a*c*b);
16
gap> OrderUsingSections(u^23*v^-2*u^3*v^15,10);
#I  (u^23*v^-2*u^3*v^15)^1 has v^13*u^15 as a section at vertex [ 1 ]
#I  (v^13*u^15)^4 has congutate of v^13*u^15 as a section at vertex [ 1, 1 ]
infinity
gap> OrderUsingSections(u^23*v^-2*u^3*v^15,2);
fail
\endexample


\>Perm( <a>[, <lev>] ) O

Returns permutation induced by tree automorphism <a> on the level <lev>
(or first level if <lev> is not given). See also
`TransformationOnLevel'~("TransformationOnLevel").


\>PermOnLevel( <a>, <k> ) O

Does the same thing as `Perm'~("Perm").


\>PermOnLevelAsMatrix( <g>, <lev> ) F

Computes the action of the element <g> on the <lev>-th level as a permutational matrix.
\beginexample
gap> PermOnLevelAsMatrix(a*b,2);
[ [ 0, 0, 0, 1 ], [ 0, 0, 1, 0 ], [ 0, 1, 0, 0 ], [ 1, 0, 0, 0 ] ]
\endexample

\>TransformationOnLevel( <a>, <lev> ) O
\>TransformationOnFirstLevel( <a> ) O

The first function returns transformation induced by tree homomorphism
<a> on the level <lev>. See also `PermOnLevel'~("PermOnLevel").

If the transformation is invertible then it returns a permutation, and
`Transformation'~("ref:Transformation") otherwise.

`TransformationOnFirstLevel'(<a>) is equivalent to
`TransformationOnLevel'(<a>, `1').


\>Word( <a> ) O

Returns <a> as an associative word (an element of underlying free group) in
generators of the self-similar group
to which <a> belongs.
\beginexample
gap> w:=Word(a*b^2*a^-1);
a*b^2*a^-1
gap> Length(w);
4
\endexample




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Operations with tree automorphisms and homomorphisms}

The multiplication of tree homomorphisms is defined in the standard way 

\>`<a> \* <b>'{product}!{for tree homomorphisms}

The following operations allow to compute the actions of tree homomorphisms on letters and vertices

\>`<letter> ^ <a>'{action}!{of tree homomorphism on letter}
\>`<vertex> ^ <a>'{action}!{of tree homomorphism on vertex}

\beginexample
gap> 1^a;
2
gap> [1,2,2,1,2,1]^(a*b^2);
[ 2, 1, 2, 2, 1, 2 ]
\endexample


The operations below describe how to work with sections of tree homomorphisms.

\>Section( <a>, <v> ) O

Returns the section of automorphism (homomorphism) <a> at vertex <v>.
Vertex <v> can be a list representing vertex, or a positive integer
representing a vertex of the first level of the tree.
\beginexample
gap> Section(a*b*a^2,[1,2,2,1,2,1]);
a^2*b^2
\endexample


\>Sections( <a> [, <lev>] ) O

Returns the list of sections of <a> at the <lev>-th level. If <lev> is ommited
it is assumed to be 1.
\beginexample
gap> Sections(a*b*a^2);
[ a*b^2*a, b*a^2*b ]
\endexample


\>Decompose( <a>[, <k>] ) O

Returns a decomposition of tree homomorphism <a> on the <k>-th level of the tree, i.e. the
representation of the form $$a = (a_1, a_2, \ldots, a_{d_1\times...\times d_k})\sigma$$
where $a_i$ are the sections of <a> at the <k>-th level, and $\sigma$ is the
transformation of the <k>-th level. If <k> is omitted it is assumed to be 1.
\beginexample
gap> Decompose(a*b^2);
(a*b^2, b*a^2)(1,2)
gap> Decompose(a*b^2,3);
(a*b^2, b*a^2, a^2*b, b^2*a, a*b*a, b*a*b, a^3, b^3)(1,8,3,5)(2,7,4,6)
\endexample







\>`<a> in <G>'{in}

Returns whether automorphism <a> belongs to group <G>. In some cases does not stop.
\beginexample
gap> H:=Group([a^2,b^2]);
< a^2, b^2 >
gap> a in H;
false
\endexample



\>OrbitOfVertex( <ver>, <g>[, <n>] ) O

Returns the list of vertices in the orbit of vertex <ver> under the
action of a semigroup generated by an automorphism <g>.
If <n> is specified, it returns only first <n> elements of the orbit.
Vertices are defined either as lists with entries from $\{1,\ldots,d\}$, or as
strings containing characters $1,\ldots,d$, where $d$
is the degree of the tree.
\beginexample
gap> g:=AutomatonGroup("t=(1,t)(1,2)");;
gap> OrbitOfVertex([1,1,1],t);
[ [ 1, 1, 1 ], [ 2, 1, 1 ], [ 1, 2, 1 ], [ 2, 2, 1 ], [ 1, 1, 2 ], [ 2, 1, 2 ],
[ 1, 2, 2 ], [ 2, 2, 2 ] ]
gap> OrbitOfVertex("111111111111",t,6);
[ [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
[ 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
[ 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ]
\endexample


\>PrintOrbitOfVertex( <ver>, <g>[, <n>] ) O

Prints the orbit of vertex <ver> under the action of a semigroup generated by
<g>. Each vertex is printed as a string containing characters $1,\ldots,d$, where $d$
is the degree of the tree. In case of binary tree the symbols `` '' and ```x'''
are used to represent `1' and `2'.
If <n> is specified only first <n> elements of the orbit are printed.
Vertices are defined either as lists with entries from $\{1,\ldots,d\}$, or as
strings. See also `OrbitOfVertex' ("OrbitOfVertex").
\beginexample
gap> PrintOrbitOfVertex("2222222222222222222222222222222",a*b^-2,6);
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

x x x x x x x x x x x x x x x x
 xx  xx  xx  xx  xx  xx  xx  xx
xxx xxx xxx xxx xxx xxx xxx xxx
   xxxx    xxxx    xxxx    xxxx
gap> H:=AutomatonGroup("t=(s,1,1)(1,2,3),s=(t,s,t)(1,2)");;
gap> PrintOrbitOfVertex([1,2,1],s^2);
121
132
123
131
122
133
\endexample


\>PermActionOnLevel( <perm>, <big_lev>, <sm_lev>, <deg> ) F

Given a permutation <perm> on the <big_lev>-th level of the tree of degree
<deg> returns the permutation induced by <perm> on a smaller level
<sm_lev>.
\beginexample
gap> PermActionOnLevel((1,4,2,3),2,1,2);
(1,2)
gap> PermActionOnLevel((1,13,5,9,3,15,7,11)(2,14,6,10,4,16,8,12),4,2,2);
(1,4,2,3)
\endexample




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Elements of groups and semigroups defined by wreath recursion}

\>`IsFiniteState( <a> )'{IsFiniteState![selfsim]}@{`IsFiniteState'!`[selfsim]'} P

Returns `true' if <a> has finitely many different sections at the vertices
of the tree. It will never stop if the free reduction of words is not sufficient
to establish the finite-state property or if <a> is not finite-state (has
infinitely many different sections).

See also `AllSections' ("AllSections") for the list of all sections and
`MealyAutomaton' ("MealyAutomaton"), which allows to construct
a Mealy automaton whose states are the sections of <a> and which
encodes its action on the tree.
\beginexample
gap> gap> D:=SelfSimilarGroup("x=(1,y)(1,2),y=(z^-1,1)(1,2),z=(1,x*y)");
< x, y, z >
gap> IsFiniteState(x*y^-1);
true
\endexample


\>AllSections( <a> ) A

Returns the list of all sections of <a> if there are finitely many of them and
that can be established using free reduction of words in sections. Otherwise
will never stop. Note, that it does not check whether all elements of the list 
are actually different elements of a group (semigroup).
\beginexample
gap> D := SelfSimilarGroup("x=(1,y)(1,2),y=(z^-1,1)(1,2),z=(1,x*y)");
< x, y, z >
gap> AllSections(x*y^-1);
[ x*y^-1, z, 1, x*y, y*z^-1, z^-1*y^-1*x^-1, y^-1*x^-1*z*y^-1, z*y^-1*x*y*z,
  y*z^-1*x*y, z^-1*y^-1*x^-1*y*z^-1, x*y*z, y, z^-1, y^-1*x^-1, z*y^-1 ]
\endexample



See also operation `MealyAutomaton' ("MealyAutomaton"), which allows to construct 
a Mealy automaton whose states are the sections of given tree homomorphism and which
encodes its action on the tree.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Elements of contracting groups}

\>AutomPortrait( <a> ) F
\>AutomPortraitBoundary( <a> ) F
\>AutomPortraitDepth( <a> ) F

Constructs the portrait of an element <a> of a
contracting group $G$. The portrait of <a> is defined recursively as follows.
For $g$ in the nucleus of $G$ the portrait is just $[g]$. For any other
element $g=(g_1,g_2,\ldots,g_d)\sigma$ the portrait of $g$ is
$[\sigma, `AutomPortrait'(g_1),\ldots, `AutomPortrait'(g_d)]$, where $d$ is
the degree of the tree. This structure describes a finite tree whose inner vertices
are labelled by permutations from $S_d$ and the leaves are labelled by
the elements of the nucleus. The contraction in $G$ guarantees that the
portrait of any element is finite.

The portraits may be considered as ``normal forms''
of the elements of $G$, since different elements have different portraits.

One also can be interested only in the boundary of a portrait, which consists
of all leaves of the portrait. This boundary can be described by an ordered set of
pairs $[level_i, g_i]$, $i=1,\ldots,r$ representing the leaves of the tree ordered from left
to right (where $level_i$ and $g_i$ are the level and the label of the $i$-th leaf
correspondingly, $r$ is the number of leaves). `AutomPortraitBoundary'(<a>) computes
this boundary.

`AutomPortraitDepth'( <a> ) returns the depth of the portrait, i.e. the minimal
level such that all sections of <a> at this level belong to the nucleus of $G$.

\beginexample
gap> AutomPortrait(u^3*v^-2*u);
[ (), [ (), [ (), [ v ], [ v ] ], [ 1 ] ],
  [ (), [ (), [ v ], [ u^-1*v ] ], [ v^-1 ] ] ]
gap> AutomPortrait(u^3*v^-2*u^3);
[ (), [ (), [ (1,2), [ (), [ (), [ v ], [ v ] ], [ 1 ] ], [ v ] ], [ 1 ] ],
  [ (), [ (1,2), [ (), [ (), [ v ], [ v ] ], [ 1 ] ], [ u^-1*v ] ], [ v^-1 ] ] ]
gap> AutomPortraitBoundary(u^3*v^-2*u^3);
[ [ 5, v ], [ 5, v ], [ 4, 1 ], [ 3, v ], [ 2, 1 ], [ 5, v ], [ 5, v ], [ 4, 1 ],
  [ 3, u^-1*v ], [ 2, v^-1 ] ]
gap> AutomPortraitDepth(u^3*v^-2*u^3);
5
\endexample


%Declaration{AutomPortraitBoundary}
%Declaration{AutomPortraitDepth}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
