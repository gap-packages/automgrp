% This file was created automatically from autom.msk.
% DO NOT EDIT!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{Noninitial Automata}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Definition}


\>Automaton( <string> ) O

Creates a Mealy automaton defined by the conventional notation in <string>
(see~`AutomGroup' "AutomGroup").
\beginexample
D:=Automaton("a=(a,b)(1,2),b=(b,a)");
<automaton>
\endexample


\>`IsAutomaton'{IsAutomaton}@{`IsAutomaton'} C

A category of non-initial finite Mealy automata with the same input and
output alphabet.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Tools}

\>IsInvertible( <A> ) P

Is `true' if <A> is invertible and `false' otherwise.

\>MinimizationOfAutomaton( <A> ) F

Returns an automaton obtained from automaton <A> by minimization.
\beginexample
gap> B:=Automaton("a=(1,a)(1,2),b=(1,a)(1,2),c=(a,b),d=(a,b)");
<automaton>
gap> C:=MinimizationOfAutomaton(B);
<automaton>
gap> Print(C);
a = (1, a)(1,2), c = (a, a), 1 = (1, 1)
\endexample


\>MinimizationOfAutomatonTrack( <A> ) F

Returns an automaton `A_new' obtained from automaton <A> by minimization. Returns the list
`[A_new,track_s,track_l]', where
`track_s' is how new states are expressed in terms of the old ones, and
`track_l' is how old states are expressed in terms of the new ones.
\beginexample
gap> B:=Automaton("a=(1,a)(1,2),b=(1,a)(1,2),c=(a,b),d=(a,b)");
<automaton>
gap> B_min:=MinimizationOfAutomatonTrack(B);
[ <automaton>, [ 1, 3, 5 ], [ 1, 1, 2, 2, 3 ] ]
gap> Print(B_min);
[ a = (1, a)(1,2), c = (a, a), 1 = (1, 1), [ 1, 3, 5 ], [ 1, 1, 2, 2, 3 ] ]
\endexample



\>IsOfPolynomialGrowth( <A> ) P

Determines whether an automaton <A> has polynomial growth in terms of Sidki~\cite{sidki:circuit}.

See also `IsBounded' ("IsBounded" and
`PolynomialDegreeOfGrowthOfAutomaton' ("PolynomialDegreeOfGrowthOfAutomaton").
\beginexample
gap> B:=Automaton("a=(b,1)(1,2),b=(a,1)");
<automaton>
gap> IsOfPolynomialGrowth(B);
true
gap> D:=Automaton("a=(a,b)(1,2),b=(b,a)");
<automaton>
gap> IsOfPolynomialGrowth(D);
false
\endexample



\>IsBounded( <A> ) P

Determines whether an automaton <A> is bounded in terms of Sidki~\cite{sidki:acyclic}.

See also `IsOfPolynomialGrowth' ("IsOfPolynomialGrowth")
and `PolynomialDegreeOfGrowthOfAutomaton' ("PolynomialDegreeOfGrowthOfAutomaton").
\beginexample
gap> B:=Automaton("a=(b,1)(1,2),b=(a,1)");
<automaton>
gap> IsBounded(B);
true
gap> C:=Automaton("a=(a,b)(1,2),b=(b,c),c=(c,1)(1,2)");
<automaton>
gap> IsBounded(C);
false
\endexample


\>PolynomialDegreeOfGrowthOfAutomaton( <G> ) A

For a group <G> generated by all states of finite automaton (see "IsAutomatonGroup")
of polynomial growth in terms of Sidki~\cite{sidki:acyclic} determines the degree of
polynomial growth of this automaton. This degree is 0 if and only if automaton is bounded.
If the growth of automaton is exponential returns `fail'.

See also `IsGeneratedByAutomatonOfPolynomialGrowth' ("IsGeneratedByAutomatonOfPolynomialGrowth")
and `IsGeneratedByBoundedAutomaton' ("IsGeneratedByBoundedAutomaton").
\beginexample
gap> B:=AutomGroup("a=(b,1)(1,2),b=(a,1)");
< a, b >
gap> PolynomialDegreeOfGrowthOfAutomaton(B);
0
gap> C:=AutomGroup("a=(a,b)(1,2),b=(b,c),c=(c,1)(1,2)");
< a, b >
gap> PolynomialDegreeOfGrowthOfAutomaton(C);
2
\endexample



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
