<html><head><title>[automgrp] 1 Introduction</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP002.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>1 Introduction</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP001.htm#SECT001">Short math background</a>
<li> <A HREF="CHAP001.htm#SECT002">Installation instructions</a>
<li> <A HREF="CHAP001.htm#SECT003">Quick example</a>
</ol><p>
<p>
The <code>AutomGrp</code> package provides methods for computation with groups and
semigroups generated by finite automata or given by wreath recursions, as well
as with their finitely generated subgroups, subsemigroups and elements.
<p>
The project originally started in 2000 mostly for personal use.
It was gradually expanding during consequent years, including both
addition of new algorithms and simplification of user interface. It
was used in the process of classification of groups generated by
3-state automata over a 2-letter alphabet (see
<a href="biblio.htm#BGK32"><cite>BGK32</cite></a>), as well as many subsequent papers.
<p>
First author thanks Sveta and Max Muntyan for their infinite patience and
understanding. Second author thanks Olga, Anna, Irina and Andrey Savchuk for their help
and understanding. This project would be impossible without them.
<p>
We would like to express our warm gratitude to Rostislav Grigorchuk, Zoran Sunic,
Volodymyr Nekrashevych, Ievgen Bondarenko, Rostyslav Kravchenko, Yaroslav and Maria
Vorobets and Ben Steinberg for their support, valuable comments, feature requests and constant interest
in the project. 
<p>
We also appreciate the code provided by Andrey Russev that was used to optimize the minimization of autmata function. Last, but not the least, we want to thank the anonymous referee for a very detailed review and numeruous constructive comments that significantly increased the quality of the accepted version of the package.
<p>
Both authors were partially supported by NSF grants DMS-0600975, DMS-0456185 and DMS-0308985. The second author
appreciates the support from the New Researcher Grant from University of South Florida and the Simons
Collaboration Grant from Simons Foundation.
<p>
<p>
<h2><a name="SECT001">1.1 Short math background</a></h2>
<p><p>
This package deals mostly with groups acting on rooted trees. In
this section we recall necessary definitions and notation that will
be used throughout the manual. For more detailed introduction to the
theory of groups generated by automata we refer the reader
to&nbsp;<a href="biblio.htm#GNS00"><cite>GNS00</cite></a>.
<p>
The infinite connected tree with selected vertex, called
the <var>root</var>, in which the degree of every vertex except the root is
<i>d</i>+1 and the degree of the root is <i>d</i> is called the <var>regular
homogeneous rooted tree of degree <i>d</i></var> (or <var><i>d</i>-ary
tree</var>). The rooted tree of degree 2 is called the <var>binary tree</var>.
<p>
The <i>n</i>-th <var>level</var> of the tree consists of all vertices located at
distance <i>n</i> from the root (here we mean combinatorial distance in
the graph).
<p>
Similarly one defines <var>spherically homogeneous</var> (or <var>spherically-transitive</var>)
 rooted trees as rooted trees, such that the degrees of all vertices at each level
coincide (but may depend on the level).
<p>
Given a finite alphabet <i>X</i>={1,2,&#8230;,<i>d</i>} the set <i>X</i><sup>*</sup> of all
finite words over <i>X</i> may be endowed with the structure of a <i>d</i>-ary
tree in which the empty word &#8709; is the <var>root</var>, the <var>level</var>
<i>n</i> in <i>X</i><sup>*</sup> consists of the words of length <i>n</i> over <i>X</i> and
every vertex <i>v</i> has <i>d</i> children, labeled by <i>vx</i>, for <i>x</i> &#8712; <i>X</i>.
<p>
Any automorphism <i>f</i> of a rooted tree <i>T</i> fixes the root and the
levels. For any vertex <i>v</i> of the tree <i>T</i> each automorphism <i>f</i> induces the
automorphism <i>f</i>&#124;<sub><i>v</i></sub> of the subtree of <i>T</i> hanging down from the vertex <i>v</i> by
<i>f</i>&#124;<sub><i>v</i></sub>(<i>u</i>)=<i>w</i> if <i>f</i>(<i>vu</i>)=<i>v</i>&#8242;<i>w</i> for some <i>v</i>&#8242; &#8712; <i>X</i><sup>&#124;<i>v</i>&#124;</sup> from the same
level as <i>v</i> (here  &#124;<i>v</i>&#124; denotes the combinatorial distance from <i>v</i> to
the root of the tree). This automorphism is called the <var>section</var> of <i>f</i> at
<i>v</i>.
<p>
If the tree <i>T</i> is regular, then the subtrees hanging down from
vertices of <i>T</i> are canonically isomorphic to <i>T</i> and, thus, the
sections of any automorphism <i>f</i> of <i>T</i> can be considered as
automorphisms of <i>T</i> again.
<p>
A group <i>G</i> of automorphisms of a regular rooted tree <i>T</i> is called
<var>self-similar</var> if all sections of every element of <i>G</i> belong to
<i>G</i>.
<p>
A self-similar group <i>G</i> is called <var>contracting</var>
if there is a finite set <i>N</i> of elements of <i>G</i>, such that for any
<i>g</i> in <i>G</i> there is a level <i>n</i> such that all sections of <i>g</i> at
vertices of levels bigger than <i>n</i> belong to <i>N</i>. The smallest set
with such a property is called the <var>nucleus</var> of <i>G</i>.
<p>
Any automorphism <i>f</i> of a rooted tree can be decomposed as
<br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"><i>f</i>=(<i>f</i><sub>1</sub>,<i>f</i><sub>2</sub>,&#8230;,<i>f</i><sub><i>d</i></sub>)&#963;,</td></tr></table></td></tr></table>
<p>
where <i>f</i><sub>1</sub>,&#8230;,<i>f</i><sub><i>d</i></sub> are the sections of <i>f</i> at the vertices of
the first level and &#963; is the permutation which permutes the subtrees
hanging down from these vertices.
<p>
This notation is very convenient for performing multiplication of
elements. Throughout this manual and everywhere in the package we use the right
action of (semi)groups acting on trees and for automorphisms (homomorphisms) of
a tree <i>f</i> and <i>g</i>, the composition <i>f</i>&#183;<i>g</i> means that <i>f</i> acts first. This is
consistent with the order of multiplication of permutations in <font face="Gill Sans,Helvetica,Arial">GAP</font> , even though
some authors in the field prefer to use the left action. With this convention
in mind, If <i>f</i>=(<i>f</i><sub>1</sub>,<i>f</i><sub>2</sub>,&#8230;,<i>f</i><sub><i>d</i></sub>)&#963; and
<i>g</i>=(<i>g</i><sub>1</sub>,<i>g</i><sub>2</sub>,&#8230;,<i>g</i><sub><i>d</i></sub>)&#960;, then
<p>
<br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"><i>f</i>&#183;<i>g</i>=(<i>f</i><sub>1</sub>&#183;<i>g</i><sub>&#963;(1)</sub>,&#8230;,<i>f</i><sub><i>d</i></sub>&#183;<i>g</i><sub>&#963;(<i>d</i>)</sub>)&#963;&#960;,</td></tr></table></td></tr></table>
<p>
<br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"><i>f</i><sup>&#8722;1</sup>=(<i>f</i><sub>&#963;<sup>&#8722;1</sup>(1)</sub><sup>&#8722;1</sup>,&#8230;,<i>f</i><sub>&#963;<sup>&#8722;1</sup>(<i>d</i>)</sub><sup>&#8722;1</sup>)&#963;<sup>&#8722;1</sup>.</td></tr></table></td></tr></table>
<p>
The group of automorphisms of a rooted tree is said to be
<var>level-transitive</var> if it acts transitively on each level of the
tree.
<p>
Everything above applies also for homomorphisms of rooted trees
(maps preserving the root and incidence relation of the vertices).
The only difference is that in this case we get semigroups and
monoids of tree homomorphisms.
<p>
A special class of self-similar groups is the class of groups
generated by finite automata. This class is especially nice from
the algorithmic point of view. Let us recall basic definitions.
<p>
A <var>Mealy automaton</var> (<var>transducer</var>, <var>synchronous automaton</var>, or,
simply, <var>automaton</var>) is a tuple <i>A</i>=(<i>Q</i>,<i>X</i>,&#961;,&#964;), where <i>Q</i> is
a set of <var>states</var>, <i>X</i> is a finite <var>alphabet</var> of cardinality <i>d</i>  &#8805; 2, &#961;:<i>Q</i> &times;<i>X</i> &#8594; <i>X</i> is a map, called the <var>output map</var>, &#964;:<i>Q</i> &times;<i>X</i> &#8594; <i>Q</i> is a map, called the <var>transition map</var>.
<p>
If for each state <i>q</i> in <i>Q</i>, the restriction &#961;<sub><i>q</i></sub>: <i>X</i> &#8594; <i>X</i>
given by &#961;<sub><i>q</i></sub>(<i>x</i>)=&#961;(<i>q</i>,<i>x</i>) is a permutation, the automaton is
called <var>invertible</var>.
<p>
If the set <i>Q</i> of states is finite, the automaton is called
<var>finite</var>.
<p>
If some state <i>q</i> in <i>Q</i> of the automaton <i>A</i> is selected to be initial,
the automaton is called <var>initial</var> and denoted <i>A</i><sub><i>q</i></sub>. If an initial
state is not specified, the automaton is called <var>noninitial</var>.
<p>
An initial automaton naturally acts on <i>X</i><sup>*</sup> by homomorphisms
(automorphisms in the case of an invertible automation) in the following way.
Given a word
<i>x</i><sub>1</sub><i>x</i><sub>2</sub>&#8230;<i>x</i><sub><i>n</i></sub>, the automaton starts at the initial state <i>q</i>,
reads the first input letter <i>x</i><sub>1</sub>, outputs the letter &#961;<sub><i>q</i></sub>(<i>x</i><sub>1</sub>)
and changes its state to <i>q</i><sub>1</sub>=&#964;(<i>q</i>,<i>x</i><sub>1</sub>). The rest of the input
word is handled by the new state <i>q</i><sub>1</sub> in the same way. Formally
speaking, the functions &#961; and &#964; can be extended to &#961;:<i>Q</i> &times;<i>X</i><sup>*</sup> &#8594; <i>X</i><sup>*</sup> and &#964;:<i>Q</i> &times;<i>X</i><sup>*</sup> &#8594; <i>Q</i>.
<p>
Given an automaton <i>A</i> the group <i>G</i>(<i>A</i>) of automorphisms of <i>X</i><sup>*</sup>
generated by all the states of <i>A</i> (as initial automata) is called the
<var>automaton group</var> defined by <i>A</i>.
<p>
Every automaton group is self-similar, because the section of <i>A</i><sub><i>q</i></sub>
at vertex <i>v</i> is just <i>A</i><sub>&#964;(<i>q</i>,<i>v</i>)</sub>.
<p>
A special case is the case of groups generated by finite automata
and their subgroups. In this class we can solve the word problem,
which makes it much nicer from the computational point of view.
<p>
Finite automata are often described by <var>recursive relations</var> (or <var>wreath recursion</var>) of
the form
<p>
<br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"><i>q</i>=(&#964;(<i>q</i>,1),&#8230;,&#964;(<i>q</i>,<i>d</i>)) &#961;<sub><i>q</i></sub></td></tr></table></td></tr></table>
<p>
for every state <i>q</i>. For example, the line <i>a</i>=(<i>a</i>,<i>b</i>)(1,2), <i>b</i>=(<i>a</i>,<i>b</i>)
describes the automaton with 2 states <i>a</i> and <i>b</i>, such that <i>a</i>
permutes the letters 1 and 2 of the alphabet <i>X</i>={1,2} and <i>b</i>
does not; and, independently
of the current state, the automaton changes its initial state to <i>a</i> if
it reads 1 and to <i>b</i> if it reads 2. This particular automaton
generates the, so-called, lamplighter group.
<p>
Semigroups generated by noninvertible automata are defined in a similar way.
<p>
<p>
<h2><a name="SECT002">1.2 Installation instructions</a></h2>
<p><p>
<code>AutomGrp</code> package requires <font face="Gill Sans,Helvetica,Arial">GAP</font> version at least 4.4.6 and <code>FGA</code> (Free
Group Algorithms) package available at <a href="http://www.gap-system.org/Packages/fga.html">http://www.gap-system.org/Packages/fga.html</a>
<p>
The installation of the <code>AutomGrp</code> package follows the standard <font face="Gill Sans,Helvetica,Arial">GAP</font> rules, i.e.
to install it unpack the archive into the <code>pkg</code> directory of
your <font face="Gill Sans,Helvetica,Arial">GAP</font> distribution. This will create <code>automgrp</code> subdirectory.
<p>
To load package issue the command
<pre>
gap&gt; LoadPackage("automgrp");
----------------------------------------------------------------
Loading  AutomGrp 1.3 (Automata Groups and Semigroups)
by Yevgen Muntyan (muntyan@fastmail.fm)
   Dmytro Savchuk (http://savchuk.myweb.usf.edu/)
Homepage: https://gap-packages.github.io/automgrp/
----------------------------------------------------------------
true
</pre>
<p>
Note, that if the <code>FR</code> package by Laurent Bartholdi is installed as well, <font face="Gill Sans,Helvetica,Arial">GAP</font> 
will automatically load it, together with the packages on which it depends. The <code>FR</code>
package functionality partially overlaps with the one of <code>AutomGrp</code>. For the
user's convenience and to expand the functionality of both packages, several converters (see operations <code>AutomGrp2FR</code> (<a href="CHAP005.htm#SSEC001.2">AutomGrp2FR</a>)
and <code>FR2AutomGrp</code> (<a href="CHAP005.htm#SSEC001.1">FR2AutomGrp</a>)) of the basic data types were implemented in <code>AutomGrp</code>.
<p>
To test the installation, issue the command
<pre>
gap&gt; Read( Filename( DirectoriesPackageLibrary( "automgrp", "tst" ), "testall.g"));
</pre>
in the <font face="Gill Sans,Helvetica,Arial">GAP</font> command line.
<p>
<p>
<h2><a name="SECT003">1.3 Quick example</a></h2>
<p><p>
Here is how to define the Grigorchuk group and Basilica group.
<p>
<pre>
gap&gt; Grigorchuk_Group := AutomatonGroup("a=(1,1)(1,2),b=(a,c),c=(a,d),d=(1,b)");
&lt; a, b, c, d &gt;
gap&gt; Basilica := AutomatonGroup( "u=(v,1)(1,2), v=(u,1)" );
&lt; u, v &gt;
</pre>
<p>
Similarly one can define a group (or semigroup) generated by
a noninvertible automaton. As an example we consider the semigroup of
intermediate growth generated by the two state automaton
(<a href="biblio.htm#BRS06"><cite>BRS06</cite></a>)
<p>
<pre>
gap&gt; SG := AutomatonSemigroup( "f0=(f0,f0)(1,2), f1=(f1,f0)[2,2]" );
&lt; f0, f1 &gt;
</pre>
<p>
Another type of groups (semigroups) implemented in the package is
the class of groups (semigroups) defined by wreath recursion
(finitely generated self-similar groups).
<p>
<pre>
gap&gt; WRG := SelfSimilarGroup("x=(1,y)(1,2),y=(z^-1,1)(1,2),z=(1,x*y)");
&lt; x, y, z &gt;
</pre>
<p>
Now we can compute several properties of <code>Grigorchuk_Group</code>, <code>Basilica</code> and <code>SG</code>
<p>
<pre>
gap&gt; IsFinite(Grigorchuk_Group);
false
gap&gt; IsSphericallyTransitive(Grigorchuk_Group);
true
gap&gt; IsFractal(Grigorchuk_Group);
true
gap&gt; IsAbelian(Grigorchuk_Group);
false
gap&gt; IsTransitiveOnLevel(Grigorchuk_Group, 4);
true
</pre>
<p>
We can also check that <code>Basilica</code> and <code>WRG</code> are contracting and compute their nuclei
<pre>
gap&gt; IsContracting(Basilica);
true
gap&gt; GroupNucleus(Basilica);
[ 1, u, v, u^-1, v^-1, u^-1*v, v^-1*u ]
gap&gt; IsContracting( WRG );
true
gap&gt; GroupNucleus( WRG );
[ 1, y*z^-1*x*y, z^-1*y^-1*x^-1*y*z^-1, z^-1*y^-1*x^-1, y^-1*x^-1*z*y^-1,
  z*y^-1*x*y*z, x*y*z ]
</pre>
<p>
The group <code>Grigorchuk_Group</code> is generated by a bounded automaton and, thus, is
amenable (see <a href="biblio.htm#BKNV05"><cite>BKNV05</cite></a>)
<pre>
gap&gt; IsGeneratedByBoundedAutomaton(Grigorchuk_Group);
true
gap&gt; IsAmenable(Grigorchuk_Group);
true
</pre>
<p>
We can compute the stabilizers of levels and vertices
<pre>
gap&gt; StabilizerOfLevel(Grigorchuk_Group, 2);
&lt; a*b*a*d*a^-1*b^-1*a^-1, d, b*a*d*a^-1*b^-1, a*b*c*a^-1, b*a*b*a*b^-1*a^-1*b^
-1*a^-1, a*b*a*b*a*b^-1*a^-1*b^-1 &gt;
gap&gt; StabilizerOfVertex(Grigorchuk_Group, [2, 1]);
&lt; a*b*a*d*a^-1*b^-1*a^-1, d, a*c*b^-1*a^-1, c, b, a*b*a*c*a^-1*b^-1*a^
-1, a*b*a*b*a^-1*b^-1*a^-1 &gt;
</pre>
<p>
In the case of a finite group we can produce an isomorphism into a permutation group
<pre>
gap&gt; f := IsomorphismPermGroup(Group(a,b));
[ a, b ] -&gt;
[ (1,2)(3,5)(4,6)(7,9)(8,10)(11,13)(12,14)(15,17)(16,18)(19,21)(20,22)(23,
    25)(24,26)(27,29)(28,30)(31,32), (1,3)(2,4)(5,7)(6,8)(9,11)(10,12)(13,
    15)(14,16)(17,19)(18,20)(21,23)(22,24)(25,27)(26,28)(29,31)(30,32) ]
gap&gt; Size(Image(f));
32
</pre>
<p>
Here is how to find relations in <code>Basilica</code> between elements of length not greater than 5.
<pre>
gap&gt; FindGroupRelations(Basilica, 6);
v*u*v*u^-1*v^-1*u*v^-1*u^-1
v*u^2*v^-1*u^2*v*u^-2*v^-1*u^-2
v^2*u*v^2*u^-1*v^-2*u*v^-2*u^-1
[ v*u*v*u^-1*v^-1*u*v^-1*u^-1, v*u^2*v^-1*u^2*v*u^-2*v^-1*u^-2,
  v^2*u*v^2*u^-1*v^-2*u*v^-2*u^-1 ]
</pre>
<p>
Or relations in the subgroup &#9001;<i>p</i>=<i>uv</i><sup>&#8722;1</sup>, <i>q</i>=<i>vu</i>&#9002;
<pre>
gap&gt; FindGroupRelations([u*v^-1,v*u], ["p", "q"], 5);
q*p^2*q*p^-1*q^-2*p^-1
[ q*p^2*q*p^-1*q^-2*p^-1 ]
</pre>
<p>
Or relations in the semigroup <code>SG</code>
<p>
<pre>
gap&gt; FindSemigroupRelations(SG, 4);
f0^3 = f0
f0^2*f1 = f1
f1*f0^2 = f1
f1^3 = f1
[ [ f0^3, f0 ], [ f0^2*f1, f1 ], [ f1*f0^2, f1 ], [ f1^3, f1 ] ]
</pre>
<p>
Some basic operations with elements are the following:
<p>
The function <code>IsOne</code> computes whether an element represents the
trivial automorphism of the tree
<pre>
gap&gt; IsOne( (a*b)^16 );
true
</pre>
<p>
Here is how to compute the order (this function might not stop in
some cases)
<pre>
gap&gt; Order(a*b);
16
gap&gt; Order(u^22*v^-15*u^2*v*u^10);
infinity
</pre>
<p>
Note that the package contains many helpful notifications that can be enabled
by changing <code>InfoLevel</code> for <code>InfoAutomGrp</code>. In many situations level 3 provides
additional information about the computation that can be used either to track the
progress or to extract the proof from the result as it can be done in the example
below.
<p>
<pre>
gap&gt; SetInfoLevel(InfoAutomGrp,3);
gap&gt; Order(u^22*v^-15*u^2*v*u^10);
#I  v is obtained from (u^22*v^-15*u^2*v*u^10)^1
    by taking sections and cyclic reductions at vertex [ 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
#I  v is obtained from (v)^2
    by taking sections and cyclic reductions at vertex [ 1, 1 ]
infinity
</pre>
<p>
One can check if a particular element acts spherically transitively on the tree
(this function might not stop in some cases)
<pre>
gap&gt; IsSphericallyTransitive(a*b);
false
gap&gt; IsSphericallyTransitive(u*v);
true
</pre>
<p>
The sections of an element can be obtained as follows
<pre>
gap&gt; Section(u*v^2*u, 2);
u^2*v
gap&gt; Decompose(u*v^2*u);
(v, u^2*v)
gap&gt; Decompose(u*v^2*u, 3);
(v, 1, 1, 1, u*v, 1, u, 1)(1,2)(5,6)
</pre>
<p>
One can try to compute whether the elements of group <code>WRG</code> defined
by wreath recursion are finite-state and calculate corresponding
automaton
<p>
<pre>
gap&gt; IsFiniteState(x*y^-1);
true
gap&gt; AllSections(x*y^-1);
[ x*y^-1, z, 1, x*y, y*z^-1, z^-1*y^-1*x^-1, y^-1*x^-1*z*y^-1, z*y^-1*x*y*z,
  y*z^-1*x*y, z^-1*y^-1*x^-1*y*z^-1, x*y*z, y, z^-1, y^-1*x^-1, z*y^-1 ]
gap&gt; A := MealyAutomaton(x*y^-1);
&lt;automaton&gt;
gap&gt; NumberOfStates(A);
15
</pre>
<p>
To get the action of an element on a vertex or on a particular level of the tree
use the following commands
<pre>
gap&gt; [1,2,1,1]^(a*b);
[ 2, 2, 1, 1 ]
gap&gt; PermOnLevel(u*v^2*v, 3);
(1,6,4,8,2,5,3,7)
</pre>
<p>
The action of the whole group <code>Grigorchuk_Group</code> on some level can be computed via
<code>PermGroupOnLevel</code> (see <a href="CHAP002.htm#SSEC003.1">PermGroupOnLevel</a>).
<pre>
gap&gt; PermGroupOnLevel(Grigorchuk_Group, 3);
Group([ (1,5)(2,6)(3,7)(4,8), (1,3)(2,4)(5,6), (1,3)(2,4), (5,6) ])
gap&gt; Size(last);
128
</pre>
<p>
The next example shows how to find all elements of length at most 5 of order 16 in the Grigorchuk group.
<pre>
gap&gt; FindElements(Grigorchuk_Group, Order, 16, 5);
[ a*b, b*a, c*a*d, d*a*c, a*b*a*d, a*c*a*d, a*d*a*b, a*d*a*c, b*a*d*a,
  c*a*d*a, d*a*b*a, d*a*c*a, a*c*a*d*a, a*d*a*c*a, b*a*b*a*c, b*a*c*a*c,
  c*a*b*a*b, c*a*c*a*b ]
</pre>
<p>
<p>
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP002.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<address>automgrp manual<br>September 2019
</address></body></html>