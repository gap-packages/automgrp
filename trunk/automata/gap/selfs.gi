#############################################################################
##
#W  selfs.gi             automata package                      Yevgen Muntyan
#W                                                             Dmytro Savchuk
##  automata v 0.91 started June 07 2004
##
#Y  Copyright (C) 2003-2006 Yevgen Muntyan, Dmytro Savchuk
##



################################################################################
##
#F ReduceWord . . . . . . . . . . . . . . . . . . . . . . .cuts 1s from the word
##
InstallGlobalFunction(ReduceWord,
function(v)
  local i,b;
  b:=[];
  for i in [1..Length(v)] do
    if v[i]<>1 then
      Add(b,v[i]);
    fi;
  od;
  return b;
end);


################################################################################
##
#F ProjectWord. . . . . . . . . . . . . . . .computes the projection of the word
##                                     onto a subtree #s in a self-similar group

InstallGlobalFunction(ProjectWord, function(w,s,G)
  local i,perm,d,proj;
  d:=Length(G[1][1])-1;
  if s>d then
    Error("Incorrect index of a subtree");
  fi;
  proj:=[];
  perm:=();
  for i in [1..Length(w)] do
    Add(proj,G[1][w[i]][s^perm]);
    perm:=perm*G[1][w[i]][d+1];
  od;
  return proj;
end);

################################################################################
##
#F WordActionOnFirstLevel . . . . . . . . . . . .computes the permutation of the
##          first level vertices generated by an element of a self-similar group

InstallGlobalFunction(WordActionOnFirstLevel,function(w,G)
  local i,perm,d;
  d:=Length(G[1][1])-1;
  perm:=();
  for i in [1..Length(w)] do perm:=perm*G[1][w[i]][d+1]; od;
  return perm;
end);


################################################################################
##
#F WordActionOnVertex . . . . . . . . . . . . . computes the image of the vertex
##                        under the action of an element of a self-similar group

InstallGlobalFunction(WordActionOnVertex,function(w,ver,G)
  local i, cur_w, new_ver, perm;
  new_ver:=[];
  cur_w:=ShallowCopy(w);
  for i in [1..Length(ver)] do
    perm:=WordActionOnFirstLevel(cur_w,G);
    new_ver[i]:=ver[i]^perm;
    cur_w:=ProjectWord(cur_w,ver[i],G);
  od;
  return new_ver;
end);


################################################################################
##
#M OrbitOfVertex . . . .Computes the first n elements of the orbit of vertex
##                                   under the element g of self-similat group G

InstallMethod(OrbitOfVertex, "OrbitOfVertex(IsList,IsAutomaton,IsCyclotomic)", true, [IsList,IsAutomaton,IsCyclotomic],
function(ver,g,n)
  local i, ver_tmp, orb;
  i:=0; orb:=[];
  ver_tmp:=ver;
  while i<n and (ver<>ver_tmp or i=0) do
    Add(orb, ver_tmp);
    ver_tmp:=ver_tmp^g;
    i:=i+1;
  od;
  return orb;
end);

################################################################################
##
#M OrbitOfVertex . . . .Computes the orbit of vertex
##                                   under the element g of self-similat group G

InstallMethod(OrbitOfVertex, "OrbitOfVertex(IsList,IsAutomaton)", [IsList,IsAutomaton],
function(ver,g)
  return OrbitOfVertex(ver,g,infinity);
end);


################################################################################
##
#M OrbitOfVertex . . . .Computes the first n elements of the orbit of vertex
##                                   under the element g of self-similat group G

InstallMethod(OrbitOfVertex, "OrbitOfVertex(IsString,IsAutomaton,IsCyclotomic)", true, [IsString,IsAutomaton,IsCyclotomic],
function(ver,g,n)
  local i, ver_tmp, orb, ch;

  ver_tmp:=[];
  for i in [1..Length(ver)] do
    ch:=Int(String([ver[i]]));
    if ch<1 or ch>g!.deg then
      Error("received string ", ver, " does not represent a valid vertex");
    fi;
    Add(ver_tmp,ch);
  od;
  ver:=ver_tmp;

  i:=0; orb:=[];
  ver_tmp:=ver;
  while i<n and (ver<>ver_tmp or i=0) do
    Add(orb, ver_tmp);
    ver_tmp:=ver_tmp^g;
    i:=i+1;
  od;
  return orb;
end);

################################################################################
##
#M OrbitOfVertex . . . .Computes the orbit of vertex
##                                   under the element g of self-similat group G

InstallMethod(OrbitOfVertex, "OrbitOfVertex(IsString,IsAutomaton)", [IsString,IsAutomaton],
function(ver,g)
  return OrbitOfVertex(ver,g,infinity);
end);



################################################################################
##
#F PrintOrbitOfVertex . . . .Computes the first n elements of the orbit of vertex ver
##                                   under the element w of self-similat group G

InstallGlobalFunction(PrintOrbitOfVertex,function(ver,w,n)
  local orb,i,j;
  orb:=OrbitOfVertex(ver,w,n);
  if w!.deg=2 then
    for i in [1..Length(orb)] do
      for j in [1..Length(orb[1])] do
        #  Print(orb[i][j]);
        if orb[i][j]=1 then Print(" "); else Print("x"); fi;
      od;
      Print("\n");
    od;
  else
     for i in [1..Length(orb)] do
      for j in [1..Length(orb[1])] do
        Print(orb[i][j]);
      od;
      Print("\n");
    od;
  fi;
#  Return true;
end);

################################################################################
##
#F IsOneWordSelfSim. . . . . . . . . . . . . . . . checks if the word is trivial
##                             in any self-similar group (exponential algorithm)

InstallGlobalFunction(IsOneWordSelfSim,function(w,G)
  local i,IsOneWordIter,ReachedWords,d;

  IsOneWordIter:=function(v)
  local i,j,perm;
    if v in ReachedWords then return true;
    else
      perm:=();
      for i in [1..Length(v)] do perm:=perm*G[1][v[i]][d+1]; od;
      if perm<>() then return false; fi;
      Add(ReachedWords,v);
      for j in [1..d] do
        if not IsOneWordIter(ProjectWord(v,j,G)) then return false; fi;
      od;
      return true;
    fi;
  end;

  d:=Length(G[1][1])-1;
  if Length(w)=0 then return true; fi;
  ReachedWords:=[];
  return IsOneWordIter(w);
end);


################################################################################
##
#F IsOneWordContr. . . . . . . . . . . . . . . . . checks if the word is trivial
##                                                          in contracting group

InstallGlobalFunction(IsOneWordContr,function(word,G)
  local i,b,l,v,c,k,res,t,w;
  w:=ShallowCopy(word);
  if Length(w)=0 then return true; fi;
  if Length(w)=1 then
    if w=[1] then return true;
             else return false;
    fi;
  fi;
  if Length(w) mod 2=1 then Add(w,1); fi;
  l:=[];
  for i in [1..Length(w)/2] do
    Add(l,StructuralCopy(G[w[2*i-1]][w[2*i]]));
  od;
#  Print("l=",l);
  c:=[(),l[1][Length(l[1])]];
  t:=Length(l);
  for i in [2..t] do
#    Print("c[",i,"]=",c[i],",l[",i,"]=",l[i][Length(l[i])],";");
    Add(c,c[i]*l[i][Length(l[i])]);
    l[i][Length(l[i])]:=c[i];
  od;
  if c[Length(c)]<>() then
    return false;
  fi;
  l[1][Length(l[1])]:=();
  b:=[];
  for i in [1..Length(l)] do
    b[i]:=l[i]^((l[i][Length(l[i])])^(-1));
  od;
  i:=1;
  res:=true;
  while res and (i<=Length(b[1])-1) do
    v:=[];
    for k in [1..Length(b)] do
      Add(v,b[k][i]);
    od;
    v:=ReduceWord(v);
    res:=IsOneWordContr(v,G);
    i:=i+1;
  od;
  return res;
end);


################################################################################
##
#F IsOneWord. . . . . . . . . . . . . . . . . . . .checks if the word is trivial
##                     in any self-similar group (chooses appropriate algorithm)

InstallGlobalFunction(IsOneWord,function(w,G)
  if Length(G)>1 then return IsOneWordContr(w,G);
                 else return IsOneWordSelfSim(w,G);
  fi;
end);


################################################################################
##
#F PowerOfWord. . . . . . . . . . . . . . . . . . Construct n-th power of a given word
##                                                It is NOT sophisticated at all

InstallGlobalFunction(PowerOfWord,function(v,n)
  local w,k;
  v:=ReduceWord(v);
  w:=StructuralCopy(v); k:=1;
  for k in [1..n-1] do Append(w,v); od;
  return w;
end);



################################################################################
##
#M OrderOfElement. . . . . . . Tries to find the order of a periodic element
##                                                       Checks up to order size

InstallOtherMethod(OrderOfElement, "OrderOfElement(IsList, IsList, IsPosInt)", true,
              [IsList, IsList, IsPosInt],
function(v,G,size)
  local w,k;
  v:=ReduceWord(v);
  w:=StructuralCopy(v); k:=1;
  if Length(G[1][1])=3 then
    while (not IsOneWord(w,G)) and k<size do
      Append(w,w);
#     Print(w,";");
      k:=2*k;
    od;
  else
    while (not IsOneWord(w,G)) and k<size do
      Append(w,v);
#     Print(w,";");
      k:=k+1;
    od;
  fi;
  if IsOneWord(w,G) then return k; else return fail; fi;
end);

################################################################################
##
#M OrderOfElement. . . . . . . Tries to find the order of a periodic element
##                                                       Checks up to order size

InstallOtherMethod(OrderOfElement, "OrderOfElement(IsList, IsList, IsInfinity)", true,
              [IsList, IsList, IsInfinity],
function(v,G,size)
  local w,k;
  v:=ReduceWord(v);
  w:=StructuralCopy(v); k:=1;
  if Length(G[1][1])=3 then
    while (not IsOneWord(w,G)) and k<size do
      Append(w,w);
#     Print(w,";");
      k:=2*k;
    od;
  else
    while (not IsOneWord(w,G)) and k<size do
      Append(w,v);
#     Print(w,";");
      k:=k+1;
    od;
  fi;
  if IsOneWord(w,G) then return k; else return fail; fi;
end);


################################################################################
##
#M OrderOfElement. . . . . . . . . . . . . . . . . .Finds the order of a periodic element
##
InstallMethod(OrderOfElement, "OrderOfElementMain(IsList, IsList, IsPosInt)",
              [IsList, IsList],
function(v,G)
  return OrderOfElement(v,G,infinity);
end);

################################################################################
##
#F GeneratorActionOnVertex. . . . . . . . . . . . . . . . Computes the action of
##                                             the generator on the fixed vertex

InstallGlobalFunction(GeneratorActionOnVertex,function(G,g,w)
  local i,v,gen,d;
  d:=Length(G[1][1])-1;
  gen:=g; v:=[];
  for i in [1..Length(w)] do
    Add(v,(w[i]+1)^G[1][gen][d+1]-1);
    gen:=G[1][gen][w[i]+1];
  od;
  return v;
end);


################################################################################
##
#F NumberOfWord. . . . . . . . . . . . . . .Computes the number (1..d^Length(w))
##                                           of a given vertex w of a d-ary tree

InstallGlobalFunction(NumberOfWord,function(w,d)
  local i,s;
  s:=0;
  for i in [1..Length(w)] do
    s:=s+w[i]*d^(Length(w)-i);
  od;
  return s;
end);


################################################################################
##
#F VertexNumber. . . . . . . . . . . . . Constructs the vertex on the n-th level
##                                               of the d-ary tree with number k

InstallGlobalFunction(VertexNumber,function(k,n,d)
  local i,l,l1,t;
  t:=k; l:=[];
  while t>0 do
    Add(l,t mod d);
    t:=(t-(t mod d))/d;
  od;
  for i in [Length(l)+1..n] do Add(l,0); od;
  l1:=[];
  for i in [1..n] do l1[i]:=l[n-i+1]; od;
  return l1;
end);


################################################################################
##
#F GeneratorActionOnLevel . . . . . . . . . . . . . . . . Computes the action of
##                                               the generator on the n-th level

InstallGlobalFunction(GeneratorActionOnLevel,function(G,g,n)
  local l,d,i,s,v,w,k;
  s:=(); d:=Length(G[1][1])-1;
  l:=[];
  for i in [1..d^n] do Add(l,0); od;
  i:=0;
  while i<d^n do
    k:=0;
    while l[k+1]>0 do
      k:=k+1;
    od;
    w:=VertexNumber(k,n,d);
    v:=StructuralCopy(w);
    i:=i+1;
    repeat
      l[NumberOfWord(v,d)+1]:=1;
      v:=GeneratorActionOnVertex(G,g,v);
      if v<>w then
        s:=s*(k+1,NumberOfWord(v,d)+1);
        i:=i+1;
      fi;
    until v=w;
  od;
  return s;
end);


################################################################################
##
#F WordActionOnLevel . . . . . . . . . . . . . . . . . . .Computes the action of
##                                              the given word on the n-th level

InstallGlobalFunction(WordActionOnLevel,function(G,w,n)
  local gen,perm;
  perm:=();
  for gen in w do
    perm:=perm*GeneratorActionOnLevel(G,gen,n);
  od;
  return perm;
end);


################################################################################
##
#F IsWordTransitiveOnLevel. . . . . . . . . .Returns true if element w of G acts
##                                 transitively on level lev and false otherwise

InstallGlobalFunction(IsWordTransitiveOnLevel,function(G,w,lev)
  return Length(OrbitPerms([WordActionOnLevel(G,w,lev)],1))=(Length(G[1][1])-1)^lev;
end);



################################################################################
##
#F GeneratorActionOnLevelAsMatrix. . . . . . . . . . . . . Computes the action of
##                       the generator on the n-th level as permutational matrix

InstallGlobalFunction(GeneratorActionOnLevelAsMatrix,function(G,g,n)
  local perm,i,j,m,d;
  perm:=GeneratorActionOnLevel(G,g,n);
  d:=Length(G[1][1])-1;
  m:=[];
  for i in [1..d^n] do Add(m,[]); od;
  for i in [1..d^n] do
    for j in [1..d^n] do m[i][j]:=0; od;
    m[i][i^perm]:=1;
  od;
  return m;
end);



################################################################################
##
#F NthFactor  . . . . . . . . . . . . . . . . . .Computes Factor group G/St_n(G)
##

InstallGlobalFunction(NthFactor,function(G,n)
  local  i,l;
  l:=[];
  for i in [1..Length(G[1])] do
    Add(l,GeneratorActionOnLevel(G,i,n));
  od;
  return Group(l);
end);



################################################################################
##
#F SubgroupNthFactor  . . . . . . . . . . . . . .Computes Factor group H/St_n(H)
##                     for a subgroup H of G generated by words from a list gens

InstallGlobalFunction(SubgroupNthFactor,function(G,gens,n)
  local  i,l;
  l:=[];
  for i in [1..Length(gens)] do
    Add(l,WordActionOnLevel(G,gens[i],n));
  od;
  return Group(l);
end);


################################################################################
##
#F InvestigatePairs . . . . . . . . . . . . . . . . . . . Searches out relations
##                                               in the recurent group like ab=c

InstallGlobalFunction(InvestigatePairs,function(G)
  local i,j,k,i1,j1,k1,Pairs,Trip,n,IsPairEq,d,res,tmp;

  IsPairEq:=function(i,j,k)   # ij=k?
    local t,res;
    if (not IsList(Pairs[i][j])) or (IsList(Pairs[i][j])
                                     and (Pairs[i][j][1]<>k)) then
      if (not IsList(Pairs[i][j])) and (Pairs[i][j]<>-1) then
        if Pairs[i][j]=k then return true;
                         else return false;
        fi;
      fi;
      if IsList(Pairs[i][j]) then
        if Length(Pairs[i][j])=1 then
          Trip[i][j][Pairs[i][j][1]]:=0;
        else
          Trip[i1][j1][k1]:=0;
          return true;
        fi;
      fi;
      if Trip[i][j][k]=0 then return false;
      else
        if G[1][i][d+1]*G[1][j][d+1]<>G[1][k][d+1] then
          Trip[i][j][k]:=0;
          return false;
        fi;
        Pairs[i][j]:=[k];
        t:=1; res:=true;
        while res and (t<=d) do
#          Print("i=",i,",j=",j,",k=",k,",t=",t,";   ");
          res:=IsPairEq(G[1][i][t],G[1][j][t^G[1][i][d+1]],G[1][k][t]);
          t:=t+1;
        od;
        if res then
          if Trip[i][j][k]<>0 then
            Pairs[i][j]:=[k,1];
            return true;
          else
            Pairs[i][j]:=-1;
            return false;
          fi;
        else
          Trip[i][j][k]:=0;
          Pairs[i][j]:=-1;
          return false;
        fi;
      fi;
    else
      return true;
    fi;
  end;

  Pairs:=[[]]; Trip:=[];
  n:=Length(G[1]);
  d:=Length(G[1][1])-1;
  for j in [1..n] do Add(Pairs[1],j); od;
  for i in [2..n] do
    Add(Pairs,[i]);
    Trip[i]:=[];
    for j in [2..n] do
      Pairs[i][j]:=-1;
      Trip[i][j]:=[];
      for k in [1..n] do Trip[i][j][k]:=-1; od;
    od;
  od;
#  Print(Pairs);
#  Print(Trip);
  for i1 in [2..n] do for j1 in [2..n] do
    if Pairs[i1][j1]=-1 then
      k1:=1; res:=false;
      while (not res) and (k1<=n) do
        res:=IsPairEq(i1,j1,k1);
#        Print(Pairs,"\n");
        for i in [2..n] do for j in [2..n] do
          if IsList(Pairs[i][j]) then
            if res then Pairs[i][j]:=Pairs[i][j][1];
                   else Pairs[i][j]:=-1;
            fi;
          fi;
        od; od;
        k1:=k1+1;
      od;
      if Pairs[i1][j1]=-1 then Pairs[i1][j1]:=0; fi;
    fi;
  od; od;
  return Pairs;
end);



################################################################################
##
#F ContractingLevel . . . . . . . . . . . . . . . . . . Computes the level where
##                                              all pairs contract to the kernel

InstallGlobalFunction(ContractingLevel,function(G)
  local i,j,res,ContPairs,d,maxlev,n,Pairs,DoesPairContract;

  DoesPairContract:=function(i,j,lev)
    local t,res,localmaxlev;
    if lev>maxlev then maxlev:=lev; fi;
    if IsList(ContPairs[i][j]) then
      if lev+ContPairs[i][j][1]>maxlev then maxlev:=lev+ContPairs[i][j][1]; fi;
      return true;
    fi;
    if Pairs[i][j]<>0 then
      ContPairs[i][j]:=[0];
      return true;
    fi;
    if ContPairs[i][j]=2 then return false; fi;
    t:=1; res:=true;
    ContPairs[i][j]:=2;
    localmaxlev:=0;
    while res and (t<=d) do
      res:=DoesPairContract(G[1][i][t],G[1][j][t^G[1][i][d+1]],lev+1);
      if res then
        if ContPairs[G[1][i][t]][G[1][j][t^G[1][i][d+1]]][1]+1>localmaxlev then
          localmaxlev:=ContPairs[G[1][i][t]][G[1][j][t^G[1][i][d+1]]][1]+1;
        fi;
      fi;
      t:=t+1;
    od;
    if res then
             ContPairs[i][j]:=[localmaxlev];
             return true;
           else return false;
    fi;
  end;

  res:=true; maxlev:=0; ContPairs:=[];
  Pairs:=InvestigatePairs(G);
  n:=Length(G[1]);
  for i in [1..n] do
    Add(ContPairs,[[0]]);
    for j in [1..n-1] do
      if i=1 then Add(ContPairs[i],[0]);
             else Add(ContPairs[i],-1);
      fi;
    od;
  od;
  #Print(ContPairs,"\n");
  i:=1;
  d:=Length(G[1][1])-1;
  while res and (i<=n) do
    j:=1;
    while res and (j<=n) do
      if ContPairs[i][j]=0 then return -1; fi;
      if ContPairs[i][j]=-1 then res:=DoesPairContract(i,j,0); fi;
      j:=j+1;
    od;
    i:=i+1;
  od;
  #Print(ContPairs);
  if res then return maxlev;
         else return -1;
  fi;
end);


################################################################################
##
#F ContractingTable . . . . . . . . . . . . . . . . . . Computes the contracting
##                                                           table of the kernel

InstallGlobalFunction(ContractingTable,function(G)
  local lev,n,d,i,j, ContractingPair, Pairs, ContTable;

  ContractingPair:=function(i,j)
    local l,k,t, PairAct, TmpList, g1, g2;
    if Pairs[i][j]<>0 then PairAct:=[Pairs[i][j]];
                      else PairAct:=[[i,j]];
    fi;
    for l in [1..lev] do
      TmpList:=[];
      for t in [1..Length(PairAct)] do
        if not IsList(PairAct[t]) then
          for k in [1..d] do Add(TmpList,G[1][PairAct[t]][k]); od;
        else
          for k in [1..d] do
            g1:=G[1][PairAct[t][1]][k];
            g2:=G[1][PairAct[t][2]][k^G[1][PairAct[t][1]][d+1]];
            if Pairs[g1][g2]<>0 then Add(TmpList,Pairs[g1][g2]);
                                else Add(TmpList,[g1,g2]);
            fi;
          od;
        fi;
      od;
      PairAct:=StructuralCopy(TmpList);
    od;
    Add(PairAct,GeneratorActionOnLevel(G,i,lev)*GeneratorActionOnLevel(G,j,lev));
    return PairAct;
  end;

  lev:=ContractingLevel(G);
  if lev=-1 then return false; fi;
  Pairs:=InvestigatePairs(G);
  n:=Length(G[1]);
  d:=Length(G[1][1])-1;
  ContTable:=[];
  for i in [1..n] do
    Add(ContTable,[]);
    for j in [1..n] do Add(ContTable[i],ContractingPair(i,j)); od;
  od;
  return ContTable;
end);


################################################################################
##
#F MinimizeAutom . . . . . . . . . . . . . . . . . . .Glues equivalent states of
##                                                          noninitial automaton

InstallGlobalFunction(MinimizeAutom,function(G)

  local AreEqualStates,i,j,Pairs,n, tmpG,d,k,l,st;

  AreEqualStates:=function(st1,st2)
    local eq,i;
    if st1=st2 or ([st1,st2] in Pairs) or ([st2,st1] in Pairs) then return true; fi;
    if G[1][st1][d+1]<>G[1][st2][d+1] then return false; fi;
    Add(Pairs, [st1,st2]);
    eq:=true;
    for i in [1..d] do
      if not AreEqualStates(G[1][st1][i],G[1][st2][i]) then eq:=false; break; fi;
    od;
    return eq;
  end;

  n:=Length(G[1]);
  d:=Length(G[1][1])-1;
  for i in [1..n-1] do
    for j in [i+1..n] do
      Pairs:=[];
      if AreEqualStates(i,j) then
        tmpG:=[];  #can be maid better by gluing all pairs from Pairs.
        for k in [1..n] do
          if k<>j then
            st:=StructuralCopy(G[1][k]);
            for l in [1..d] do
              if st[l]=j then st[l]:=i;
              elif st[l]>j then st[l]:=st[l]-1;
              fi;
            od;
            Add(tmpG,st);
          fi;
        od;
        return MinimizeAutom([tmpG]);
      fi;
    od;
  od;
  return G;
end);

################################################################################
##
#F MinimizeAutomTrack  . . . . . . . . . . . . . . . .Glues equivalent states of
##   noninitial automaton and returns correspondence between old and new numbers
##  track_list_short - new generators in terms of old ones
##  track_list_long  - old generators in terms of new ones

InstallGlobalFunction(MinimizeAutomTrack,function(G,track_list_short,track_list_long)

  local AreEqualStates,i,j,Pairs,n, tmpG,d,k,l,st, track_s, track_l;

  AreEqualStates:=function(st1,st2)
    local eq,i;
    if st1=st2 or ([st1,st2] in Pairs) or ([st2,st1] in Pairs) then return true; fi;
    if G[1][st1][d+1]<>G[1][st2][d+1] then return false; fi;
    Add(Pairs, [st1,st2]);
    eq:=true;
    for i in [1..d] do
      if not AreEqualStates(G[1][st1][i],G[1][st2][i]) then eq:=false; break; fi;
    od;
    return eq;
  end;


  if Length(track_list_short)<>Length(G[1]) then
    Error("length of track_list_short is wrong\n");
  fi;

  n:=Length(G[1]);
  d:=Length(G[1][1])-1;
  track_s:=StructuralCopy(track_list_short);
  track_l:=StructuralCopy(track_list_long);
  for i in [1..n-1] do
    for j in [i+1..n] do
      Pairs:=[];
      if AreEqualStates(i,j) then
        tmpG:=[];  #can be maid better by gluing all pairs from Pairs.
        for k in [1..n] do
          if k<>j then
            st:=StructuralCopy(G[1][k]);
            for l in [1..d] do
              if st[l]=j then st[l]:=i;
              elif st[l]>j then st[l]:=st[l]-1;
              fi;
            od;
            Add(tmpG,st);
          fi;
        od;
        track_s:=[];
        for k in [1..Length(track_list_short)] do
          if k<j then track_s[k]:=StructuralCopy(track_list_short[k]);
            elif k>j then track_s[k-1]:=StructuralCopy(track_list_short[k]);
          fi;
        od;
        for k in [1..Length(track_list_long)] do
          if track_l[k]>j then track_l[k]:=track_l[k]-1;
            elif track_l[k]=j then track_l[k]:=i;
          fi;
        od;
        return MinimizeAutomTrack([tmpG],track_s,track_l);
      fi;
    od;
  od;
  return [G,track_s,track_l];
end);


################################################################################
##
#F AddInverses. . . . . . . . . . Adds to the generating set of the self-similar
##                               group inverse elements and the identity element

InstallGlobalFunction(AddInverses,function(H)
  local d,n,G,idEl,st,i,perm,inv;

  d:=Length(H[1][1])-1;
  n:=Length(H[1]);
  if n<1 or d<1 then return fail; fi;
  idEl:=[];
  for i in [1..d] do Add(idEl,1); od;
  Add(idEl,());
  G:=[[idEl]];
  for i in [1..n] do Add(G[1],StructuralCopy(H[1][i])); od;

  for st in [2..n+1] do
    for i in [1..d] do G[1][st][i]:=G[1][st][i]+1; od;
  od;

  for st in [2..n+1] do
    inv:=[];
    perm:=G[1][st][d+1]^(-1);
    for i in [1..d] do Add(inv, G[1][st][i^perm]+n); od;
    Add(inv,perm);
    Add(G[1],inv);
  od;

  return MinimizeAutom(G);
end);



################################################################################
##
#F AddInversesTrack. . . . . . . .Adds to the generating set of the self-similar
##                               group inverse elements and the identity element

InstallGlobalFunction(AddInversesTrack,function(H)
  local d,n,G,idEl,st,i,perm,inv, track_s, track_l;

##  track_s - new generators in terms of old ones
##  track_l - old generators in terms of new ones

  d:=Length(H[1][1])-1;
  n:=Length(H[1]);
  if n<1 or d<1 then return fail; fi;
  idEl:=[];
  for i in [1..d] do Add(idEl,1); od;
  Add(idEl,());
  G:=[[idEl]];
  for i in [1..n] do Add(G[1],StructuralCopy(H[1][i])); od;

  for st in [2..n+1] do
    for i in [1..d] do G[1][st][i]:=G[1][st][i]+1; od;
  od;

  for st in [2..n+1] do
    inv:=[];
    perm:=G[1][st][d+1]^(-1);
    for i in [1..d] do Add(inv, G[1][st][i^perm]+n); od;
    Add(inv,perm);
    Add(G[1],inv);
  od;
#  Print("G=",G,"\n");
  track_s:=[0];
  Append(track_s,[1..Length(G[1])-1]);
  return MinimizeAutomTrack(G,track_s,[2..Length(G[1])]);
end);


################################################################################
##
#F FindNucleus. . . . . . . . . . . . . . . . . . . . .Tries to find the nucleus
##                                                     of the self-similar group

InstallGlobalFunction(FindNucleus,function(H)
  local G,g,Pairs,i,j,PairsToAdd,AssocWPairsToAdd,res,ContPairs,n,d,found,num,IsPairContracts,AddPairs,lev,maxlev,tmp,Nucl,IsElemInNucleus,
    nucl_final, cur_nucl, cur_nucl_tmp, Hi, track_s, track_l, G_track, automgens, cur_nucl_length;
  IsPairContracts:=function(i,j,lev)
    local t,res;
    if lev>maxlev then maxlev:=lev; fi;

    # ContPairs[i][j] may take the following values:
    # -1 - [i,j] was not met before
    # 1  - [i,j] contracts
    # 2  - [i,j] was met above in the tree

    if (ContPairs[i][j]=1) then return true; fi;
    if Pairs[i][j]<>0 then
      ContPairs[i][j]:=1;
      return true;
    fi;
    if ContPairs[i][j]=2 then return false; fi;
    t:=1; res:=true;
    ContPairs[i][j]:=2;
    while res and (t<=d) do
      res:=IsPairContracts(G[1][i][t],G[1][j][t^G[1][i][d+1]],lev+1);
      t:=t+1;
    od;
    if res then
             ContPairs[i][j]:=1;
             return true;
           else return false;
    fi;
  end;

  AddPairs:=function(i,j)
    local tmp,l,CurNum;
    if Pairs[i][j]>0 then return Pairs[i][j]; fi;
    Pairs[i][j]:=num;
    CurNum:=num;
    Add(PairsToAdd,[]);
    num:=num+1;
    tmp:=[];
    for l in [1..d] do
      Add(tmp,AddPairs(G[1][i][l],G[1][j][l^G[1][i][d+1]]));
    od;
    Add(tmp,G[1][i][d+1]*G[1][j][d+1]);
    Append(PairsToAdd[CurNum-n],tmp);
    AssocWPairsToAdd[CurNum-n]:=cur_nucl[i]*cur_nucl[j];
    return CurNum;
  end;

  IsElemInNucleus:=function(g)
    local i,res;
    if g in tmp then
      for i in [Position(tmp,g)..Length(tmp)] do
        if not (tmp[i] in Nucl) then Add(Nucl,tmp[i]); fi;
      od;
      return g=tmp[1];
    fi;
    Add(tmp,g);
    res:=false; i:=1;
    while (not res) and i<=d do
      res:=IsElemInNucleus(G[1][g][i]);
      i:=i+1;
    od;
    tmp:=tmp{[1..Length(tmp)-1]};
    return res;
  end;

#  ******************  FindNucleus itself *******************************



  automgens:=UnderlyingAutomFamily(H)!.automgens;
  d:=UnderlyingAutomFamily(H)!.deg;
  cur_nucl:=[One(UnderlyingAutomFamily(H))];

  Hi:=AddInversesTrack([AutomatonList(H)]);
#  Print("Gi=",Gi,"\n");
  G:=Hi[1];

  track_s:=Hi[2];
  track_l:=Hi[3];

  for i in [2..Length(track_s)] do Add(cur_nucl,automgens[track_s[i]]); od;

  found:=false;

  while not found do
    res:=true; maxlev:=0; ContPairs:=[];
    Pairs:=InvestigatePairs(G);
    n:=Length(G[1]);
#    Print("n=",n,"\n");
    Info(InfoAutomata, 3, "n=",n);
    for i in [1..n] do
      Add(ContPairs,[1]);
      for j in [1..n-1] do
        if i=1 then Add(ContPairs[i],1);
               else Add(ContPairs[i],-1);
        fi;
      od;
    od;
    i:=1;

    while res and (i<=n) do
      j:=1;
      while res and (j<=n) do
        #Print("i=",i,",j=",j,"\n");
        if ContPairs[i][j]=-1 then res:=IsPairContracts(i,j,0); fi;
        if not res then
          PairsToAdd:=[];
          AssocWPairsToAdd:=[];
#  num represents current number of generators
          num:=n+1;
          AssocWPairsToAdd:=[];
          AddPairs(i,j);
          Info(InfoAutomata, 3, "Elements added:",List(AssocWPairsToAdd,x->x!.word));
          Append(G[1],PairsToAdd);
#          Print("G=",G,"\n");
          Append(cur_nucl,AssocWPairsToAdd);
          G_track:=AddInversesTrack(G);
#          Print("G_track=",G_track,"\n");
          G:=G_track[1];
          cur_nucl_tmp:=[];
          cur_nucl_tmp:=[One(UnderlyingAutomFamily(H))];
          cur_nucl_length:=Length(cur_nucl);
          for i in [2..Length(G_track[2])] do
            if G_track[2][i]<=cur_nucl_length then
              Add(cur_nucl_tmp,cur_nucl[G_track[2][i]]);
            else
              Add(cur_nucl_tmp,cur_nucl[G_track[2][i]-cur_nucl_length]^-1);
            fi;
          od;
          cur_nucl:=StructuralCopy(cur_nucl_tmp);
        fi;
        j:=j+1;
      od;
      i:=i+1;
    od;
    if res then
      found:=true;
    fi;
  od;

  Nucl:=[];
# first add elements of cycles
  for i in [1..Length(G[1])] do
    tmp:=[];
    if not (i in Nucl) then IsElemInNucleus(i); fi;
  od;

# now add sections of elements of cycles
  repeat
    found:=false;
    for g in Nucl do
      for i in [1..d] do
        if not (G[1][g][i] in Nucl) then
          found:=true;
          Add(Nucl,G[1][g][i]);
        fi;
      od;
    od;
  until not found;
#  Print("Nucleus:",Nucl,"\n");

  nucl_final:=[];
  for i in Nucl do Add(nucl_final,cur_nucl[i]); od;
  return [nucl_final,cur_nucl,G[1]];
end);



################################################################################
##
#F InversePerm. . . . . . . . . . . .Gives permutation on the set of generators
##                                      which pushes each element to its inverse

InstallGlobalFunction(InversePerm,function(G)
  local i,j,viewed,inv,found;
  viewed:=[]; inv:=();
  for i in [1..Length(G[1])] do
    if not (i in viewed) then
      j:=1; found:=false;
      while j<=Length(G[1]) and not found do
        #Print("[",i,",",j,"]\n");
        if IsOneWord([i,j],G) then
          found:=true;
          if i<>j then
            inv:=inv*(i,j);
            Add(viewed,i);
            Add(viewed,j);
          else
            Add(viewed,i);
          fi;
        fi;
        j:=j+1;
      od;
    fi;
  od;
  return inv;
end);


################################################################################
##
#F PortraitOfWord. . . . . . . . . . . . . . . Finds the portrait boundary of an
##                                                element in a contracting group

InstallGlobalFunction(PortraitOfWord,function(w,G)
  local PortraitIter, bndry,inv,d,PermList;

  PortraitIter:=function(v,lev,plist)
    local i,j,tmpv,sigma;
    for i in [1..Length(G[1])] do
      tmpv:=StructuralCopy(v);
      Add(tmpv,i);
      if IsOneWord(tmpv,G) then
        Add(bndry,[lev,i^inv]);
        return;
      fi;
    od;

    for i in [1..d] do
      tmpv:=[]; sigma:=();
      for j in v do
        Add(tmpv,G[1][j][i^sigma]);
        sigma:=sigma*G[1][j][d+1];
      od;
      if i=1 then Add(plist,sigma);fi;
      Add(plist,[]);
      PortraitIter(tmpv,lev+1,plist[i+1]);
    od;
  end;

  d:=Length(G[1][1])-1;
  bndry:=[d];
  PermList:=[];
  inv:=InversePerm(G);
  PortraitIter(w,0,PermList);
  return [bndry,PermList];
end);


################################################################################
##
#F WritePortraitToFile. . . . . . . . . . .Writes portrait in a file in the form
##                                                       understandable by Maple

InstallGlobalFunction(WritePortraitToFile,function(p,file,add)
  local WritePerm;

  WritePerm:=function(perm)
    local j;
    AppendTo(file,"[ ");
    if Length(perm)>0 then
      AppendTo(file,"`",perm[1],"`");
      for j in [2..Length(perm)] do
        AppendTo(file,", ");
        WritePerm(perm[j]);
      od;
    fi;
    AppendTo(file," ]");
  end;


  if add then AppendTo(file,"[ ",p[1],", ");
    else PrintTo(file,"[ ",p[1],", ");
  fi;
  WritePerm(p[2]);
  AppendTo(file, " ]");
end);


################################################################################
##
#F WritePortraitsToFile. . . . . . . . . . . . .Writes portraitso of elements of
##                          a list in a file in the form understandable by Maple

InstallGlobalFunction(WritePortraitsToFile,function(lst,G,file,add)
  local WritePerm,i,p;

  if add then AppendTo(file,"[ ");
    else PrintTo(file,"[ ");
  fi;

  for i in [1..Length(lst)] do
    if i=1 then
        AppendTo(file,"[ ",lst[i],", ");
    else
        AppendTo(file,", [ ",lst[i],", ");
    fi;
    p:=PortraitOfWord(lst[i],G);
    WritePortraitToFile(p,file,true);
    AppendTo(file,"]");

  od;
end);


################################################################################
##
#F PortraitsOfWordPowers. . . . . . Finds the sequence of portrait boundaries of
##                                          word's powers in a contracting group

InstallGlobalFunction(PortraitsOfWordPowers,function(w,G)
  local list,d,v;
  v:=StructuralCopy(w);
  d:=Length(G[1][1])-1;
  list:=[StructuralCopy(w),PortraitOfWord(v,G)];
  while list[Length(list)]<>[[d,[0,1]],[]] do
    Append(v,w);
    Add(list, PortraitOfWord(v,G));
  od;
  return list;
end);


################################################################################
##
#F AutomGroupGrowth. . . . . . . . . . . . . . . . . . . . . . . .Finds number of elements
##                                                         of the length up to n

InstallGlobalFunction(AutomGroupGrowth,function(n,G)
  local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,inverse,H;

  inverse:=function(w)
    local i, iw;
    iw:=[];
    for i in [1..Length(w)] do
      iw[i]:=w[Length(w)-i+1]^inv;
    od;
    return iw;
  end;

  gr:=1; len:=1;
  H:=AddInverses(G);
  if G<>H then
    Info(InfoAutomata, 3, "Inverses were added. Automaton was minimized. Now generator set is:\n",H);
    G:=H;
  fi;
  inv:=InversePerm(G);
  GrList:=[1,Length(G[1])];
  ElList:=[];
  for i in [1..Length(G[1])] do
    Add(ElList,[i]);
  od;

  while len<n do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for j in [2..Length(G[1])] do
        v:=StructuralCopy(ElList[i]);
        Add(v,j);
        New:=true;
        k:=1;
        while New and k<=oldgr do
          tmpv:=StructuralCopy(v);
          Append(tmpv,inverse(ElList[k]));
          if IsOneWord(tmpv,G) then New:=false; fi;
          k:=k+1;
        od;
        if New then Add(ElList,v); fi;
      od;
    od;
    Add(GrList,Length(ElList));
    Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList));
    len:=len+1;
  od;

  return GrList;
end);


################################################################################
##
#F AutomGroupGrowthFast. . . . . . . . . .Computes the growth function while the number of
##               elements is not greater than n and length is not greater than m

InstallGlobalFunction(AutomGroupGrowthFast,function(n,m,G)
  local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,inverse,H;

  inverse:=function(w)
    local i, iw;
    iw:=[];
    for i in [1..Length(w)] do
      iw[i]:=w[Length(w)-i+1]^inv;
    od;
    return iw;
  end;

  gr:=1; len:=1;
  H:=AddInverses(G);
  if G<>H then
    Info(InfoAutomata, 3, "Inverses were added. Now generator set is:\n",H);
    G:=H;
  fi;
  inv:=InversePerm(G);
  GrList:=[1,Length(G[1])];
  ElList:=[];
  for i in [1..Length(G[1])] do
    Add(ElList,[i]);
  od;

  while Length(ElList)<n and len<m do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for j in [2..Length(G[1])] do
        v:=StructuralCopy(ElList[i]);
        Add(v,j);
        New:=true;
        k:=1;
        while New and k<=oldgr do
          tmpv:=StructuralCopy(v);
          Append(tmpv,inverse(ElList[k]));
          if IsOneWord(tmpv,G) then New:=false; fi;
          k:=k+1;
        od;
        if New then Add(ElList,v); fi;
      od;
    od;
    Add(GrList,Length(ElList));
    Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList));
    len:=len+1;
  od;

  return GrList;
end);



################################################################################
##
#F AutomGroupElements . . . . . . . . . . . . . . . . . . .Enumerates all elements of
##                                     a self-similar group up to a given length

InstallGlobalFunction(AutomGroupElements,function(n,G)
  local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,inverse,H;

  inverse:=function(w)
    local i, iw;
    iw:=[];
    for i in [1..Length(w)] do
      iw[i]:=w[Length(w)-i+1]^inv;
    od;
    return iw;
  end;

  gr:=1; len:=1;
  H:=AddInverses(G);
  if [G[1]]<>H then
    Info(InfoAutomata, 3, "Inverses were added. Automaton was minimized. Now generator set is:\n",H);
    G:=H;
  fi;
  inv:=InversePerm(G);
  GrList:=[1,Length(G[1])];
  ElList:=[];
  for i in [1..Length(G[1])] do
    Add(ElList,[i]);
  od;

  while len<n do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for j in [2..Length(G[1])] do
        v:=StructuralCopy(ElList[i]);
        Add(v,j);
        New:=true;
        if len=1 then k:=1; else k:=GrList[len-1]; fi;
        while New and k<=oldgr do
          tmpv:=StructuralCopy(v);
          Append(tmpv,inverse(ElList[k]));
          if IsOneWord(tmpv,G) then New:=false; fi;
          k:=k+1;
        od;
        if New then Add(ElList,v); fi;
      od;
    od;
    Add(GrList,Length(ElList));
    Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList));
    len:=len+1;
  od;

  return ElList;
end);


################################################################################
##
#M FiniteGroupId . . . . . . . . . . Computes a finite group of permutations
##    generated by a self-similar group (in case of infinite group doesn't stop)

InstallMethod(FiniteGroupId, "FiniteGroupId(IsList, IsPosInt)", true,
              [IsList, IsCyclotomic],
function(G,size)
  local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,IsNewRel,inverse,H,FinG,tmpl,push,ProductEls,act,rels, LongCycle;

  inverse:=function(w)
    local i, iw;
    iw:=[];
    for i in [1..Length(w)] do
      iw[i]:=w[Length(w)-i+1]^inv;
    od;
    return iw;
  end;

  ProductEls:=function(i,j)
    local t,v,tmpv;
    v:=StructuralCopy(ElList[i]);
    Append(v,ElList[j]);
    for t in [1..Length(ElList)] do
      tmpv:=StructuralCopy(v);
      Append(tmpv,inverse(ElList[t]));
      if IsOneWord(tmpv,G) then return t; fi;
    od;
  end;

  LongCycle:=function(n)
    local l,i;
    l:=[];
    for i in [2..n] do Add(l,i); od;
    Add(l,1);
    return PermList(l);
  end;

  IsNewRel:=function(v)
    local  tmp,i,j,cyc,cycr,v_cyc,r_cyc,r,r_cyc_inv;
    cyc:=LongCycle(Length(v));
    for i in [0..Length(v)-1] do
      v_cyc:=Permuted(v,cyc^i);
      if v_cyc[1]=v_cyc[Length(v)]^inv then return false; fi;
      for r in rels do
        cycr:=LongCycle(Length(r));
        for j in [0..Length(r)-1] do
          r_cyc:=Permuted(r,cycr^j);
          r_cyc_inv:=inverse(Permuted(r,cycr^j));
          if PositionSublist(v_cyc,r_cyc) <> fail or PositionSublist(v_cyc,r_cyc_inv) <> fail then
            return false;
          fi;
        od;
      od;
    od;
    return true;
  end;

  gr:=1; len:=1;
  H:=AddInverses(G);
  if [G[1]]<>H then
    Info(InfoAutomata, 3, "Inverses were added. Automaton was minimized. Now generator set is:\n",H);
    G:=H;
  fi;
  inv:=InversePerm(G);
  GrList:=[1,Length(G[1])];
  ElList:=[]; rels:=[];
  for i in [1..Length(G[1])] do
    Add(ElList,[i]);
  od;
  while GrList[len+1]>GrList[len] and GrList[len+1]<size do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for j in [2..Length(G[1])] do
        v:=StructuralCopy(ElList[i]);
        if j<>v[Length(v)]^inv then
          Add(v,j);
          New:=true;
          if len=1 then k:=1; else k:=GrList[len-1]+1; fi;
          while New and k<=oldgr do
            tmpv:=StructuralCopy(v);
            Append(tmpv,inverse(ElList[k]));
            if IsOneWord(tmpv,G) then
              New:=false;
## show relations
              if IsNewRel(tmpv) then
                Add(rels,tmpv);
                Info(InfoAutomata, 3, v,"*",ElList[k],"^(-1)=1");
#               Print(tmpv,"\n");
              fi;
            fi;
            k:=k+1;
          od;
          if New then Add(ElList,v); fi;
        fi;
      od;
    od;
    Add(GrList,Length(ElList));
    Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList));
    len:=len+1;
  od;

  if GrList[len+1]>GrList[len] then return fail; fi;
# in case of finite group construct Cayley table
  FinG:=[()];
  for i in [2..Length(ElList)] do
    act:=();
    tmpl:=[];
    while Length(tmpl)<Length(ElList) do
      j:=1;
      while j in tmpl do j:=j+1; od;
      Add(tmpl,j);
      push:=ProductEls(j,i);
      while push<>j do
        Add(tmpl,push);
        act:=act*(j,push);
        push:=ProductEls(push,i);
      od;
    od;
    Add(FinG,act);
  od;

  return Group(FinG);
end);



################################################################################
##
#F FiniteGroupId . . . . . . . . . . . . Computes a finite group of permutations
##    generated by a self-similar group (in case of infinite group doesn't stop)


InstallMethod(FiniteGroupId, "FiniteGroupId(IsList)",
              [IsList],
function(G)
  return FiniteGroupId(G,infinity);
end);


################################################################################
##
#F MarkovOperator. . . . . . . . . . . . . .Computes a matrix of Markov operator
##                                related to group G on the n-th level of a tree

InstallGlobalFunction(MarkovOperator,function(G,n)
  local H,inv,i,el,j,m,d;
  d:=Length(G[1][1])-1;
  H:=AddInverses(G);
  inv:= InversePerm(H);
  m:=[];
  for i in [1..d^n] do Add(m,[]); od;
  for i in [1..d^n] do
    for j in [1..d^n] do m[i][j]:=0; od;
  od;
  for el in [2..Length(H[1])] do
    m:=m+GeneratorActionOnLevelAsMatrix(H,el,n);
  od;
  return m;
end);


################################################################################
##
#F IsOneWordSubs. . . . . . . . . . . . Determines if the word in terms of given
##                                                         generators is trivial

InstallGlobalFunction(IsOneWordSubs,function(w,subs,G)
  local i,v;
  v:=[];
  for i in w do Append(v,subs[i]); od;
  return IsOneWord(v,G);
end);


################################################################################
##
#M FindRelsSubs. . . . . . . . . . . .Finds group relations between given elements
##                                     stops after investigating "size" elements
##                                      or when it finds "num_of_rels" relations

InstallMethod(FindRelsSubs, "FindRelsSubs(subs_words,names,G,size,num_of_rels)", true,
              [IsList, IsList, IsAutomGroup, IsCyclotomic, IsCyclotomic],
function(subs_words,names,G,size,num_of_rels)
  local gens, Gi, H, rel, rels, rels0, k, track_s, track_l, AssocW, FindRelsLocal, gens_autom, i, j, subs, subs1, w_list, FindRelsSubsLocal, w_ext, w, automgens, numstates, F, cur_gen;

  AssocW:=function(w)
     return Product(List(w, i -> gens[i]));
  end;

  FindRelsSubsLocal:=function(subs,G)
    local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,IsNewRelS,inverse,inverseS,H,FinG,tmpl,push,ProductEls,act,rels, LongCycle,invslist,invs,origlength,w,invadded,AssocWrels;

    inverse:=function(w)
      local i, iw;
      iw:=[];
      for i in [1..Length(w)] do
        iw[i]:=w[Length(w)-i+1]^inv;
      od;
      return iw;
    end;

    inverseS:=function(w)
      local i, iw;
      iw:=[];
      for i in [1..Length(w)] do
        iw[i]:=w[Length(w)-i+1]^invs;
      od;
      return iw;
    end;

    ProductEls:=function(i,j)
      local t,v,tmpv;
      v:=StructuralCopy(ElList[i]);
      Append(v,ElList[j]);
      for t in [1..Length(ElList)] do
        tmpv:=StructuralCopy(v);
        Append(tmpv,inverse(ElList[t]));
        if IsOneWord(tmpv,G) then return t; fi;
      od;
    end;

    LongCycle:=function(n)
      local l,i;
      l:=[];
      for i in [2..n] do Add(l,i); od;
      Add(l,1);
      return PermList(l);
    end;

    IsNewRelS:=function(v)
      local  tmp,i,j,cyc,cycr,v_cyc,r_cyc,r,r_cyc_inv;
      cyc:=LongCycle(Length(v));
      for i in [0..Length(v)-1] do
        v_cyc:=Permuted(v,cyc^i);
        if v_cyc[1]=v_cyc[Length(v)]^invs then return false; fi;
        for r in rels do
          cycr:=LongCycle(Length(r));
          for j in [0..Length(r)-1] do
            r_cyc:=Permuted(r,cycr^j);
            r_cyc_inv:=inverseS(Permuted(r,cycr^j));
            if PositionSublist(v_cyc,r_cyc) <> fail or PositionSublist(v_cyc,r_cyc_inv) <> fail then
              return false;
            fi;
          od;
        od;
      od;
      return true;
    end;
#************************ FindRelsSubsLocal itself ****************************************************

    rels:=[];
    inv:=InversePerm(G);
  #check if there are any identity elements in subs list
    for i in [1..Length(subs)] do
      if IsOneWord(subs[i],G) then
        Error(AssocW([i]),"=id, remove this element from a list and try again");
      fi;
    od;

    AssocWrels:=[];

  #check if there are any equal elements in subs list
    invslist:=[];
    for i in [1..Length(subs)] do
      for j in [i..Length(subs)] do
        if i<>j and IsOneWord(Concatenation(subs[i],inverse(subs[j])),G) then
          Error(AssocW([i]),"=",AssocW([j]),", remove one of these elements from a list and try again");
        fi;

  #      Print(IsOneWord(Append(StructuralCopy(subs[i]),subs[j]),G),"\n");
  #      Print(Concatenation(subs[i],subs[j]),"\n");

        if IsOneWord(Concatenation(subs[i],subs[j]),G) then
          invslist[i]:=j; invslist[j]:=i;
          Add(rels,[i,j]);
          Add(AssocWrels,AssocW([i,j]));
          Info(InfoAutomata, 3, AssocW([i,j]));
        fi;
      od;
    od;

  # add inverses to subs list
    origlength:=Length(subs);
    invadded:=false;
    for i in [1..origlength] do
      if not IsBound(invslist[i]) then
        invadded:=true;
        Add(subs,inverse(subs[i]));
        Add(gens,gens[i]^-1);
        invslist[i]:=Length(subs);
        invslist[Length(subs)]:=i;
      fi;
    od;

    invs:=PermList(invslist);

    GrList:=[1,Length(subs)+1];
    ElList:=[];

    gr:=1; len:=1;

    for i in [1..Length(subs)] do
      Add(ElList,[i]);
    od;
    while GrList[len+1]>GrList[len] and GrList[len+1]<size and Length(rels)<num_of_rels do
      for i in [GrList[len]..GrList[len+1]-1] do
        oldgr:=Length(ElList);
        for j in [1..Length(subs)] do
          v:=StructuralCopy(ElList[i]);
          if j<>v[Length(v)]^invs then
            Add(v,j);
            New:=true;
  #          k:=1;
            if len=1 then k:=1; else k:=GrList[len-1]; fi;
            while New and k<=oldgr do
              tmpv:=StructuralCopy(v);
              Append(tmpv,inverseS(ElList[k]));
              if IsOneWordSubs(tmpv,subs,G) then
                New:=false;
  ## show relations
                if IsNewRelS(tmpv) then
                  Add(rels,tmpv);
                  if Length(AssocW(tmpv))>0 then
                    Add(AssocWrels,AssocW(tmpv));
                    Info(InfoAutomata, 3, AssocW(tmpv));
                  fi;
                fi;
              fi;
              k:=k+1;
            od;
            if New then Add(ElList,v); fi;
          fi;
        od;
      od;
      Add(GrList,Length(ElList)+1);
  #    Print("ElList[",len,"]=",ElList,"\n");
      Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList)+1);
      len:=len+1;
    od;
    return AssocWrels;
  end;


#************************ FindRelsSubsMain itself ****************************************************

  if Length(subs_words)<>Length(names) then
    Error("The number of names must coincide with the number of generators");
  fi;
  F:=FreeGroup(names);

# gens is a mutable list of generators
  gens:=[];
  for i in GeneratorsOfGroup(F) do Add(gens,i); od;

  automgens:=UnderlyingAutomFamily(G)!.automgens;
  numstates:=UnderlyingAutomFamily(G)!.numstates;

  subs1:=[];

#convert associative words into lists
  for w in subs_words do
    w_list:=[];
    w_ext:=ExtRepOfObj(w!.word);
    for i in [1..Length(w_ext)/2] do
      if w_ext[2*i]>0 then
        cur_gen:=w_ext[2*i-1];
      else
        cur_gen:=w_ext[2*i-1]+numstates;
      fi;
      for j in [1..AbsInt(w_ext[2*i])] do Add(w_list,cur_gen); od;
    od;
    Add(subs1,ShallowCopy(w_list));
  od;


  Gi:=AddInversesTrack([AutomatonList(G)]);
#  Print("Gi=",Gi,"\n");
  H:=Gi[1];

  track_s:=Gi[2];
  track_l:=Gi[3];

  subs:=[];

  for w in subs1 do
    w_list:=[];
    for i in [1..Length(w)] do Add(w_list,track_l[w[i]]); od;
    Add(subs,ShallowCopy(w_list));
  od;
  rels0:=[];

#  for k in [1..Length(AutomatonList(G))] do
#  Print("Beam\n");
#    if track_l[k]=1 then Add(rels0,AssocW([k]));
#      elif track_s[track_l[k]]<>k then Add(rels0,AssocW([k,track_s[track_l[k]]+Length(AutomatonList(G))]));
#    fi;
#  od;


  rels:=FindRelsSubsLocal(subs,H);
  if rels=fail then return fail; fi;
  Append(rels0,rels);
#  Print(rels0);
  return rels0;
end);

################################################################################
##
#M FindRelsSubs. . . . . . . . . . . . . .Finds group relations between given elements
##                                     stops after investigating "size" elements
##

InstallMethod(FindRelsSubs, "FindRelsSubs(subs_words,names,G,size)", true,
              [IsList, IsList, IsAutomGroup, IsCyclotomic],
function(subs_words,names,G,size)
  return FindRelsSubs(subs_words,names,G,size,infinity);
end);


################################################################################
##
#M FindRelsSubs. . . . . . . . . . . . . .Finds group relations between given elements
##
##
InstallMethod(FindRelsSubs, "FindRelsSubs(subs_words,names,G)",
              [IsList, IsList, IsAutomGroup],
function(subs_words,names,G)
  return FindRelsSubs(subs_words,names,G,infinity,infinity);
end);


################################################################################
##
#M FindRelsSubsSG. . . . . . . . . . .Finds relations between given elements
##                                         in the subsemigroup generated by them
##                                     stops after investigating "size" elements
##                                     and when it finds "num_of_rels" relations

InstallOtherMethod(FindRelsSubsSG, "FindRelsSubsSG(subs_words,names,G,size,num_of_rels)", true,
              [IsList, IsList, IsAutomGroup, IsCyclotomic, IsCyclotomic],
function(subs_words,names,G,size,num_of_rels)
  local gens, Gi, H, rel, rels, rels0, k, track_s, track_l, AssocW, gens_autom, i, j, subs, subs1, w_list, FindRelsSubsSGLocal, w_ext, w, automgens, numstates, F, cur_gen;

  AssocW:=function(w)
     return Product(List(w, i -> gens[i]));
  end;

  FindRelsSubsSGLocal:=function(subs,G)
    local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,IsNewRelS,inverse,inverseS,H,FinG,tmpl,push,ProductEls,act,rels, LongCycle,invslist,invs,origlength,w,invadded,Expand,rel,New_rel,AssocWrels;

    #inverse as a word over generators of automaton
    inverse:=function(w)
      local i, iw;
      iw:=[];
      for i in [1..Length(w)] do
        iw[i]:=w[Length(w)-i+1]^inv;
      od;
      return iw;
    end;

    ProductEls:=function(i,j)
      local t,v,tmpv;
      v:=StructuralCopy(ElList[i]);
      Append(v,ElList[j]);
      for t in [1..Length(ElList)] do
        tmpv:=StructuralCopy(v);
        Append(tmpv,inverse(ElList[t]));
        if IsOneWord(tmpv,G) then return t; fi;
      od;
    end;

    #rewrites a word over subs in terms of generators of automaton
    Expand:=function(v)
    local i,tmpv;
      tmpv:=[];
      for i in [1..Length(v)] do
        Append(tmpv,subs[v[i]]);
      od;
      return tmpv;
    end;

  #************************ FindRelsSubsSGLocal itself ****************************************************

    rels:=[];
    AssocWrels:=[];

    inv:=InversePerm(G);
  #check if there are any identity elements in subs list
    for i in [1..Length(subs)] do
      if IsOneWord(subs[i],G) then
        Error(AssocW([i]),"=id, remove this element from the list and try again");
      fi;
    od;

  #check if there are any equal elements in subs list
  #  invslist:=[];
    for i in [1..Length(subs)] do
      for j in [i..Length(subs)] do
        if i<>j and IsOneWord(Concatenation(subs[i],inverse(subs[j])),G) then
          Error(AssocW([i]),"=",AssocW([j]),", remove one of these elements from the list and try again");
        fi;

  #      Print(IsOneWord(Append(StructuralCopy(subs[i]),subs[j]),G),"\n");
  #      Print(Concatenation(subs[i],subs[j]),"\n");

  #      if IsOneWord(Concatenation(subs[i],subs[j]),G) then
  #        invslist[i]:=j; invslist[j]:=i;
  #        Add(rels,[i,j]);
  #        Print("[",i,",",j,"]=1\n");
  #      fi;
      od;
    od;

    GrList:=[1,Length(subs)+1];
    ElList:=[];

    gr:=1; len:=1;

    for i in [1..Length(subs)] do
      Add(ElList,[i]);
    od;
    while GrList[len+1]>GrList[len] and GrList[len+1]<size and Length(rels)<num_of_rels do
      for i in [GrList[len]..GrList[len+1]-1] do
        oldgr:=Length(ElList);
        for j in [1..Length(subs)] do
          v:=StructuralCopy(ElList[i]);
          Add(v,j);
# New stands for New element
          New:=true;
          if IsOneWord(Expand(v),G) then
            New:=false;
            Add(rels,[v,1]);
            if Length(AssocW(v))>0 then
              Add(AssocWrels,[AssocW(v),One(F)]);
              Info(InfoAutomata, 3, AssocW(v),"=e");
            fi;
          else
            k:=1;
            while New and k<=oldgr do
              tmpv:=Expand(v);
#              Print("v=",v,"; tmpv=",tmpv,"\n");
              Append(tmpv,inverse(Expand(ElList[k])));
              if IsOneWord(tmpv,G) then
                New:=false;
## show relations
                New_rel:=true;
                for rel in rels do
                  if PositionSublist(v,rel[1]) <> fail then New_rel:=false; fi;
                od;
                if New_rel then
                  Add(rels,[v,ElList[k]]);
#                  if Length(AssocW(v))>0 then
                  Add(AssocWrels,[AssocW(v),AssocW(ElList[k])]);
                  Info(InfoAutomata, 3, AssocW(v),"=",AssocW(ElList[k]));
#                  fi;
                fi;
              fi;

              k:=k+1;
            od;
          fi;
          if New then Add(ElList,v); fi;
        od;
      od;
      Add(GrList,Length(ElList)+1);
      Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList)+1);
      len:=len+1;
    od;
    return AssocWrels;
  end;

#  *********************** FindRelsSubsSGMain itself ****************************************************

  if Length(subs_words)<>Length(names) then
    Error("The number of names must coincide with the number of generators");
  fi;
  F:=FreeGroup(names);

# gens is a mutable list of generators
  gens:=[];
  for i in GeneratorsOfGroup(F) do Add(gens,i); od;

  automgens:=UnderlyingAutomFamily(G)!.automgens;
  numstates:=UnderlyingAutomFamily(G)!.numstates;

  subs1:=[];

#convert associative words into lists
  for w in subs_words do
    w_list:=[];
    w_ext:=ExtRepOfObj(w!.word);
    for i in [1..Length(w_ext)/2] do
      if w_ext[2*i]>0 then
        cur_gen:=w_ext[2*i-1];
      else
        cur_gen:=w_ext[2*i-1]+numstates;
      fi;
      for j in [1..AbsInt(w_ext[2*i])] do Add(w_list,cur_gen); od;
    od;
    Add(subs1,ShallowCopy(w_list));
  od;


  Gi:=AddInversesTrack([AutomatonList(G)]);
#  Print("Gi=",Gi,"\n");
  H:=Gi[1];

  track_s:=Gi[2];
  track_l:=Gi[3];

  subs:=[];

  for w in subs1 do
    w_list:=[];
    for i in [1..Length(w)] do Add(w_list,track_l[w[i]]); od;
    Add(subs,ShallowCopy(w_list));
  od;
  rels0:=[];

#  for k in [1..Length(AutomatonList(G))] do
#  Print("Beam\n");
#    if track_l[k]=1 then Add(rels0,AssocW([k]));
#      elif track_s[track_l[k]]<>k then Add(rels0,AssocW([k,track_s[track_l[k]]+Length(AutomatonList(G))]));
#    fi;
#  od;


  rels:=FindRelsSubsSGLocal(subs,H);
  if rels=fail then return fail; fi;
  Append(rels0,rels);
#  Print(rels0);
  return rels0;
end);


################################################################################
##
#M FindRelsSubsSG. . . . . . . . . . .Finds relations between given elements
##                                         in the subsemigroup generated by them
##                                     stops after investigating "size" elements

InstallMethod(FindRelsSubsSG, "FindRelsSubsSG(subs_words,names,G,size)", true,
              [IsList, IsList, IsAutomGroup, IsCyclotomic],
function(subs_words,names,G,size)
  return FindRelsSubsSG(subs_words,names,G,size,infinity);
end);


################################################################################
##
#M FindRelsSubsSG. . . . . . . . . . . . .Finds relations between given elements
##                                         in the subsemigroup generated by them

InstallMethod(FindRelsSubsSG, "FindRelsSubsSG(subs_words,names,G)",
              [IsList, IsList, IsAutomGroup],
function(subs_words,names,G)
  return FindRelsSubsSG(subs_words,names,G,infinity,infinity);
end);




################################################################################
##
#M FindRels . . . . . . . . . Fing relatoins in terms of the original generators
##
##
InstallMethod(FindRels, "FindRels(G,size,num_of_rels)", true,
              [IsAutomGroup, IsCyclotomic, IsCyclotomic],
function(G,size,num_of_rels)
  local gens, Gi, H, rel, rels, rels0, k, track_s, track_l, AssocW, FindRelsLocal;

  AssocW:=function(w)
     #Print(w);
     return Product(List(w, i -> gens[i]));
  end;


  FindRelsLocal:=function(subs,G)
    local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,IsNewRelS,inverse,inverseS,H,FinG,tmpl,push,ProductEls,act,rels, LongCycle,invslist,invs,origlength,w,invadded,tmpv_orig,AssocWrels;

    inverse:=function(w)
      local i, iw;
      iw:=[];
      for i in [1..Length(w)] do
        iw[i]:=w[Length(w)-i+1]^inv;
      od;
      return iw;
    end;

    inverseS:=function(w)
      local i, iw;
      iw:=[];
      for i in [1..Length(w)] do
        iw[i]:=w[Length(w)-i+1]^invs;
      od;
      return iw;
    end;

    ProductEls:=function(i,j)
      local t,v,tmpv;
      v:=StructuralCopy(ElList[i]);
      Append(v,ElList[j]);
      for t in [1..Length(ElList)] do
        tmpv:=StructuralCopy(v);
        Append(tmpv,inverse(ElList[t]));
        if IsOneWord(tmpv,G) then return t; fi;
      od;
    end;

    LongCycle:=function(n)
      local l,i;
      l:=[];
      for i in [2..n] do Add(l,i); od;
      Add(l,1);
      return PermList(l);
    end;

    IsNewRelS:=function(v)
      local  tmp,i,j,cyc,cycr,v_cyc,r_cyc,r,r_cyc_inv;
      cyc:=LongCycle(Length(v));
      for i in [0..Length(v)-1] do
        v_cyc:=Permuted(v,cyc^i);
        if v_cyc[1]=v_cyc[Length(v)]^invs then return false; fi;
        for r in rels do
          cycr:=LongCycle(Length(r));
          for j in [0..Length(r)-1] do
            r_cyc:=Permuted(r,cycr^j);
            r_cyc_inv:=inverseS(Permuted(r,cycr^j));
            if PositionSublist(v_cyc,r_cyc) <> fail or PositionSublist(v_cyc,r_cyc_inv) <> fail then
              return false;
            fi;
          od;
        od;
      od;
      return true;
    end;
#************************ FinRelsLocal itself ****************************************************

    rels:=[];
    AssocWrels:=[];
    inv:=InversePerm(G);


    invslist:=[];
    for i in [1..Length(subs)] do
      for j in [i..Length(subs)] do
#        Print(AssocW([Gi[2][i+1],Gi[2][j+1]])!.word,"\n");
        if IsOneWord(Concatenation(subs[i],subs[j]),G) then
          invslist[i]:=j; invslist[j]:=i;
          if Length(AssocW([Gi[2][i+1],Gi[2][j+1]])!.word)>0 then
            Add(rels,[i,j]);
            Add(AssocWrels,AssocW([Gi[2][i+1],Gi[2][j+1]]));
            Info(InfoAutomata, 3, AssocW([Gi[2][i+1],Gi[2][j+1]])!.word);
          fi;
        fi;
      od;
    od;

    invs:=PermList(invslist);

    GrList:=[1,Length(subs)+1];
    ElList:=[];

    gr:=1; len:=1;

    for i in [1..Length(subs)] do
      Add(ElList,[i]);
    od;
    while GrList[len+1]>GrList[len] and GrList[len+1]<size and Length(rels)<num_of_rels do
      for i in [GrList[len]..GrList[len+1]-1] do
        oldgr:=Length(ElList);
        for j in [1..Length(subs)] do
          v:=StructuralCopy(ElList[i]);
          if j<>v[Length(v)]^invs then
            Add(v,j);
            New:=true;
 #          k:=1;
            if len=1 then k:=1; else k:=GrList[len-1]; fi;
            while New and k<=oldgr do
              tmpv:=StructuralCopy(v);
              Append(tmpv,inverseS(ElList[k]));
              if IsOneWordSubs(tmpv,subs,G) then
                New:=false;
## show relations
                if IsNewRelS(tmpv) then
# tmpv in the original generators
                  tmpv_orig:=[];
                  for k in [1..Length(tmpv)] do
                    tmpv_orig[k]:=Gi[2][tmpv[k]+1];
                  od;
                  Add(rels,tmpv);
                  if Length(AssocW(tmpv_orig)!.word)>0 then
                    Add(AssocWrels,AssocW(tmpv_orig));
                    Info(InfoAutomata, 3, AssocW(tmpv_orig)!.word);
                  fi;
#                 Print(tmpv,"\n");
                fi;
              fi;
              k:=k+1;
            od;
            if New then Add(ElList,v); fi;
          fi;
        od;
      od;
      Add(GrList,Length(ElList)+1);
 #    Print("ElList[",len,"]=",ElList,"\n");
      Info(InfoAutomata, 3, "Length not greater than ",len+1,": ",Length(ElList)+1);
      len:=len+1;
    od;
    return AssocWrels;
  end;

#************************ FinRels itself ****************************************************

  gens:=UnderlyingAutomFamily(G)!.automgens;

  Gi:=AddInversesTrack([AutomatonList(G)]);
#  Print("Gi=",Gi,"\n");
  H:=Gi[1];

  track_s:=Gi[2];
  track_l:=Gi[3];
  rels0:=[];

#  for k in [1..Length(AutomatonList(G))] do
#  Print("Beam\n");
#    if track_l[k]=1 then Add(rels0,AssocW([k]));
#      elif track_s[track_l[k]]<>k then Add(rels0,AssocW([k,track_s[track_l[k]]+Length(AutomatonList(G))]));
#    fi;
#  od;


  rels:=FindRelsLocal(List([2..Length(H[1])],i->[i]),H);
  Append(rels0,rels);
#  Print(rels0);
  return rels0;
end);


################################################################################
##
#M FindRels . . . . . . . . . Finds relatoins in terms of the original generators
##
##
InstallMethod(FindRels, "FindRels(G,size)", true,
              [IsAutomGroup, IsCyclotomic],
function(G,size)
  return FindRels(G,size,infinity);
end);



################################################################################
##
#M FindRels . . . . . . . . . Finds relatoins in terms of the original generators
##
##
InstallMethod(FindRels, "FindRels(G)",
              [IsAutomGroup],
function(G)
  return FindRels(G,infinity,infinity);
end);


################################################################################
##
#M FindRels . . . . . . . . . Fing relatoins in terms of the original generators
##
##
InstallMethod(FindRels, "FindRels(G)",
              [IsAutomGroup],
function(G)
  return FindRels(G,infinity,infinity);
end);


################################################################################
##
#F OrdersOfGroupElementsMain . . . . . Enumerates all elements of a self-similar
##             group up to length n and tries to find their orders up to order O
##                  returns true if all the orders are finite and fail otherwise
##         in case stop=true returns fail as soon as it finds suspicious element

InstallGlobalFunction(OrdersOfGroupElementsMain,function(n,O,stop,G)
  local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,inverse,H, periodic, order_v;

  inverse:=function(w)
    local i, iw;
    iw:=[];
    for i in [1..Length(w)] do
      iw[i]:=w[Length(w)-i+1]^inv;
    od;
    return iw;
  end;

  gr:=1; len:=1; periodic:=true;

  H:=AddInverses(G);
  if [G[1]]<>H then
    Info(InfoAutomata, 3, "Inverses were added. Automaton was minimized. Now generator set is:\n",H);
    G:=H;
  fi;
  inv:=InversePerm(G);
  GrList:=[1,Length(G[1])];
  ElList:=[];
  for i in [1..Length(G[1])] do
    Add(ElList,[i]);
  od;

  for v in ElList do
    order_v:=OrderOfElement(v,G,O);
    Info(InfoAutomata, 3, "Order of ", v, ": ", order_v);
    if order_v = fail then
      if stop then return fail;
        else periodic:=fail;
      fi;
    fi;
  od;

  while len<n do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for j in [2..Length(G[1])] do
        v:=StructuralCopy(ElList[i]);
        Add(v,j);
        New:=true;
        if len=1 then k:=1; else k:=GrList[len-1]; fi;
        while New and k<=oldgr do
          tmpv:=StructuralCopy(v);
          Append(tmpv,inverse(ElList[k]));
          if IsOneWord(tmpv,G) then New:=false; fi;
          k:=k+1;
        od;
        if New then
          Add(ElList,v);
          order_v:=OrderOfElement(v,G,O);
          Info(InfoAutomata, 3, "Order of ", v, ": ", order_v);

          if order_v = fail then
            if stop then return fail;
              else periodic:=fail;
            fi;
          fi;

        fi;
      od;
    od;
    Add(GrList,Length(ElList));
#    Print("Length not greater than ",len+1,": ",Length(ElList),"\n");
    len:=len+1;
  od;

  return periodic;
end);


################################################################################
##
#F OrdersOfGroupElements . . . . . . . Enumerates all elements of a self-similar
##             group up to length n and tries to find their orders up to order O
##                  returns true if all the orders are finite and fail otherwise

InstallGlobalFunction(OrdersOfGroupElements,function(n,O,G)
  return OrdersOfGroupElementsMain(n,O,false,G);
end);


################################################################################
##
#F PeriodicityGuess. . . . . . . . . . Enumerates all elements of a self-similar
##             group up to length n and tries to find their orders up to order O
##                  returns true if all the orders are finite and fail otherwise
##                           returns fail as soon as it finds suspicious element

InstallGlobalFunction(PeriodicityGuess,function(n,O,G)
  return OrdersOfGroupElementsMain(n,O,true,G);
end);


################################################################################
##
#F FindTransitiveElements . . . . . . .Finds all elements of a group G which are
##                      transitive on a level lev and have length no more than n
##                in case stop=true stops when it finds first transitive element

InstallGlobalFunction(FindTransitiveElements,function(n,lev,stop,G)
  local gr,len, ElList, GrList,inv,i,j,k,oldgr,v,tmpv,New,inverse,H, TransElList;

  inverse:=function(w)
    local i, iw;
    iw:=[];
    for i in [1..Length(w)] do
      iw[i]:=w[Length(w)-i+1]^inv;
    od;
    return iw;
  end;

  gr:=1; len:=1;

  H:=AddInverses(G);
  if [G[1]]<>H then
    Info(InfoAutomata, 3, "Inverses were added. Automaton was minimized. Now generator set is:\n",H);
    G:=H;
  fi;
  inv:=InversePerm(G);
  GrList:=[1,Length(G[1])];
  ElList:=[];
  TransElList:=[];

  for i in [1..Length(G[1])] do
    Add(ElList,[i]);
  od;

  for v in ElList do
    if IsWordTransitiveOnLevel(G,v,lev) then
      if stop then return v;
        else Add(TransElList,v);
      fi;
    fi;
  od;

  while len<n do
    for i in [GrList[len]+1..GrList[len+1]] do
      oldgr:=Length(ElList);
      for j in [2..Length(G[1])] do
        v:=StructuralCopy(ElList[i]);
        Add(v,j);
        New:=true;
        if len=1 then k:=1; else k:=GrList[len-1]; fi;
        while New and k<=oldgr do
          tmpv:=StructuralCopy(v);
          Append(tmpv,inverse(ElList[k]));
          if IsOneWord(tmpv,G) then New:=false; fi;
          k:=k+1;
        od;
        if New then
          Add(ElList,v);

          if IsWordTransitiveOnLevel(G,v,lev) then
            if stop then return v;
              else Add(TransElList,v);
            fi;
          fi;

        fi;
      od;
    od;
    Add(GrList,Length(ElList));
#    Print("Length not greater than ",len+1,": ",Length(ElList),"\n");
    len:=len+1;
  od;

  return TransElList;
end);

#E
